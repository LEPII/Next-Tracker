{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@formbricks/types/errorHandlers.ts","/turbopack/[project]/node_modules/@formbricks/js/src/methodQueue.ts","/turbopack/[project]/node_modules/@formbricks/js/src/shared/loadFormbricks.ts"],"sourcesContent":["export type Result<T, E = Error> = { ok: true; data: T } | { ok: false; error: E };\n\nexport const ok = <T, E>(data: T): Result<T, E> => ({ ok: true, data });\n\nexport const okVoid = <E>(): Result<void, E> => ({ ok: true, data: undefined });\n\nexport const err = <E = Error>(error: E): Result<never, E> => ({\n  ok: false,\n  error,\n});\n\n/**\n * Applies the given function `fn` to the data property of the input `result` object\n * and returns a new `Result` object with the transformed data property.\n *\n * @template T The type of the input data.\n * @template R The type of the output data.\n *\n * @param {function(value: T): R} fn The function to apply to the data property of the input `result` object.\n * @returns {function(result: Result<T>): Result<R>} A new function that takes in a `Result<T>` object and returns a new `Result<R>` object.\n *\n * @example\n * const divideByTwo = (num: number): Result<number> => {\n *   if (num === 0) {\n *     return { ok: false, error: \"Cannot divide zero\" };\n *   }\n *\n *   return { ok: true, data: num / 2 };\n * }\n *\n * const wrappedDivideByTwo = wrap(divideByTwo);\n *\n * const result1: Result<number> = { ok: true, data: 10 };\n * const result2: Result<number> = { ok: false, error: \"Invalid input\" };\n * const result3: Result<number> = { ok: true, data: 0 };\n *\n * console.log(wrappedDivideByTwo(result1)); // { ok: true, data: 5 }\n * console.log(wrappedDivideByTwo(result2)); // { ok: false, error: \"Invalid input\" }\n * console.log(wrappedDivideByTwo(result3)); // { ok: false, error: \"Cannot divide zero\" }\n */\n\nexport const wrap =\n  <T, R>(fn: (value: T) => R) =>\n  (result: Result<T>): Result<R> =>\n    result.ok === true ? { ok: true, data: fn(result.data) } : result;\n\n/**\n * Matches the given `result` object against its `ok` property and invokes the `onSuccess` function\n * if `ok` is `true`, or the `onError` function if `ok` is `false`. Returns the result of the invoked function. Match a Result object and run a function depending on the result.\n *\n * @template TSuccess - Type of the success value\n * @template TError - Type of the error value\n * @template TReturn - Type of the return value\n *\n * @param {Result<TSuccess, TError>} result The `Result` object to match against.\n * @param {(value: TSuccess) => TReturn} onSuccess The function to invoke if `result.ok` is `true`.\n * @param {(error: TError) => TReturn} onError The function to invoke if `result.ok` is `false`.\n *\n * @returns {TReturn} The result of the invoked function.\n *\n * @example\n * const test = (): Result<string, Error> => {\n *  return err(new Error(\"error happened\"));\n * }\n *\n * const result = test();\n *\n * match(result, (value) => {\n *  console.log(value); // never run with this example\n * }, (error) => {\n *  console.log(error); // Error: error happened\n * });\n */\nexport const match = <TSuccess, TError, TReturn>(\n  result: Result<TSuccess, TError>,\n  onSuccess: (value: TSuccess) => TReturn,\n  onError: (error: TError) => TReturn\n): TReturn => (result.ok === true ? onSuccess(result.data) : onError(result.error));\n\n/**\n * Wraps a function `fn` that may throw an error into a new function that returns a `Result` object.\n * If the wrapped function throws an error, the returned `Result` object will have an `ok` property of `false`\n * and an `error` property containing the thrown error. Otherwise, the returned `Result` object will have an\n * `ok` property of `true` and a `data` property containing the result of the wrapped function.\n *\n * @template T The type of the result value.\n * @template A An array of the types of the arguments expected by the wrapped function.\n *\n * @param {(...args: A) => T} fn The function to wrap.\n * @returns {(...args: A) => Result<T>} A new function that returns a `Result` object.\n *\n * @example\n * function divideByTwo(num: number): number {\n *   if (num === 0) {\n *     throw new Error(\"Cannot divide zero\");\n *   }\n *   return num / 2;\n * }\n *\n * const wrappedDivideByTwo = wrapThrows(divideByTwo);\n *\n * const result1: Result<number> = wrappedDivideByTwo(10); // { ok: true, data: 5 }\n * const result2: Result<number> = wrappedDivideByTwo(0); // { ok: false, error: Error(\"Cannot divide zero\") }\n */\nexport const wrapThrows =\n  <T, A extends any[]>(fn: (...args: A) => T): ((...args: A) => Result<T>) =>\n  (...args: A): Result<T> => {\n    try {\n      return {\n        ok: true,\n        data: fn(...args),\n      };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error,\n      };\n    }\n  };\n\nexport const wrapThrowsAsync =\n  <T, A extends any[]>(fn: (...args: A) => Promise<T>) =>\n  async (...args: A): Promise<Result<T>> => {\n    try {\n      return {\n        ok: true,\n        data: await fn(...args),\n      };\n    } catch (error) {\n      return {\n        ok: false,\n        error: error as Error,\n      };\n    }\n  };\n","// Simple queue for formbricks methods\n\nexport class MethodQueue {\n  private queue: (() => Promise<void>)[] = [];\n  private isExecuting = false;\n\n  add = (method: () => Promise<void>) => {\n    this.queue.push(method);\n    this.run();\n  };\n\n  private runNext = async () => {\n    if (this.isExecuting) return;\n\n    const method = this.queue.shift();\n    if (method) {\n      this.isExecuting = true;\n      try {\n        await method();\n      } finally {\n        this.isExecuting = false;\n        if (this.queue.length > 0) {\n          this.runNext();\n        }\n      }\n    }\n  };\n\n  run = async () => {\n    if (!this.isExecuting && this.queue.length > 0) {\n      await this.runNext();\n    }\n  };\n\n  clear = () => {\n    this.queue = [];\n  };\n}\n","import { Result, wrapThrowsAsync } from \"../../../types/errorHandlers\";\nimport { MethodQueue } from \"../methodQueue\";\n\nlet isInitializing = false;\nlet isInitialized = false;\nconst methodQueue = new MethodQueue();\n\n// Load the SDK, return the result\nconst loadFormbricksSDK = async (apiHost: string, sdkType: \"app\" | \"website\"): Promise<Result<void>> => {\n  if (!window.formbricks) {\n    const res = await fetch(`${apiHost}/api/packages/${sdkType}`);\n\n    // Failed to fetch the app package\n    if (!res.ok) {\n      return { ok: false, error: new Error(`Failed to load Formbricks ${sdkType} SDK`) };\n    }\n\n    const sdkScript = await res.text();\n    const scriptTag = document.createElement(\"script\");\n    scriptTag.innerHTML = sdkScript;\n    document.head.appendChild(scriptTag);\n\n    const getFormbricks = async () =>\n      new Promise<void>((resolve, reject) => {\n        const checkInterval = setInterval(() => {\n          if (window.formbricks) {\n            clearInterval(checkInterval);\n            resolve();\n          }\n        }, 100);\n\n        setTimeout(() => {\n          clearInterval(checkInterval);\n          reject(new Error(`Formbricks ${sdkType} SDK loading timed out`));\n        }, 10000);\n      });\n\n    try {\n      await getFormbricks();\n      return { ok: true, data: undefined };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error: new Error(error.message ?? `Failed to load Formbricks ${sdkType} SDK`),\n      };\n    }\n  }\n\n  return { ok: true, data: undefined };\n};\n\n// TODO: @pandeymangg - Fix these types\n// type FormbricksAppMethods = {\n//   [K in keyof TFormbricksApp]: TFormbricksApp[K] extends Function ? K : never;\n// }[keyof TFormbricksApp];\n\n// type FormbricksWebsiteMethods = {\n//   [K in keyof TFormbricksWebsite]: TFormbricksWebsite[K] extends Function ? K : never;\n// }[keyof TFormbricksWebsite];\n\nexport const loadFormbricksToProxy = async (prop: string, sdkType: \"app\" | \"website\", ...args: any[]) => {\n  const executeMethod = async () => {\n    try {\n      //  @ts-expect-error\n      return await (window.formbricks[prop] as Function)(...args);\n    } catch (error) {\n      console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n      throw error;\n    }\n  };\n\n  if (!isInitialized) {\n    if (isInitializing) {\n      methodQueue.add(executeMethod);\n    } else {\n      if (prop === \"init\") {\n        isInitializing = true;\n\n        const initialize = async () => {\n          const { apiHost } = args[0];\n          const loadSDKResult = await wrapThrowsAsync(loadFormbricksSDK)(apiHost, sdkType);\n\n          if (!loadSDKResult.ok) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${loadSDKResult.error.message}`);\n            return;\n          }\n\n          try {\n            const result = await (window.formbricks[prop] as Function)(...args);\n            isInitialized = true;\n            isInitializing = false;\n\n            return result;\n          } catch (error) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n            throw error;\n          }\n        };\n\n        methodQueue.add(initialize);\n      } else {\n        console.error(\n          \"ðŸ§± Formbricks - Global error: You need to call formbricks.init before calling any other method\"\n        );\n        return;\n      }\n    }\n  } else {\n    // @ts-expect-error\n    if (window.formbricks && typeof window.formbricks[prop] !== \"function\") {\n      console.error(\n        `ðŸ§± Formbricks - Global error: Formbricks ${sdkType} SDK does not support method ${String(prop)}`\n      );\n      return;\n    }\n\n    methodQueue.add(executeMethod);\n    return;\n  }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@formbricks/js/src/app.ts"],"sourcesContent":["import { TFormbricksApp } from \"@formbricks/js-core/app\";\nimport { TFormbricksWebsite } from \"@formbricks/js-core/website\";\n\nimport { loadFormbricksToProxy } from \"./shared/loadFormbricks\";\n\ndeclare global {\n  interface Window {\n    formbricks: TFormbricksApp | TFormbricksWebsite;\n  }\n}\n\nconst formbricksProxyHandler: ProxyHandler<TFormbricksApp> = {\n  get(_target, prop, _receiver) {\n    return (...args: any[]) => loadFormbricksToProxy(prop as string, \"app\", ...args);\n  },\n};\n\nconst formbricksApp: TFormbricksApp = new Proxy({} as TFormbricksApp, formbricksProxyHandler);\nexport default formbricksApp;\n"],"names":[],"mappings":";;;;;;AAWA,MAAM,yBAAuD;IAC3D,KAAI,OAAA,EAAS,IAAA,EAAM,SAAA;QACjB,OAAO,CAAA,GAAI,OAAgB,CAAA,GAAA,2KAAA,CAAA,IAAA,EAAsB,MAAgB,UAAU;IAC7E;AACF;AAEA,MAAM,gBAAgC,IAAI,MAAM,CAAA,GAAsB"}},
    {"offset": {"line": 170, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}