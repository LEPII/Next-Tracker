{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/errors.ts"],"sourcesContent":["export class EscapedError extends Error {\n  /**\n   * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data\n   * directly into the HTML body\n   */\n  constructor(message: string) {\n    /* c8 ignore next */\n    super(htmlSafe(message));\n    Object.setPrototypeOf(this, EscapedError.prototype);\n  }\n}\n\nexport class MissingStateParamError extends Error {\n  static message = 'Missing state parameter in Authorization Response.';\n  status = 400;\n  statusCode = 400;\n\n  constructor() {\n    /* c8 ignore next */\n    super(MissingStateParamError.message);\n    Object.setPrototypeOf(this, MissingStateParamError.prototype);\n  }\n}\n\nexport class MalformedStateCookieError extends Error {\n  static message = 'Your state cookie is not valid JSON.';\n  status = 400;\n  statusCode = 400;\n\n  constructor() {\n    /* c8 ignore next */\n    super(MalformedStateCookieError.message);\n    Object.setPrototypeOf(this, MalformedStateCookieError.prototype);\n  }\n}\n\nexport class MissingStateCookieError extends Error {\n  static message = 'Missing state cookie from login request (check login URL, callback URL and cookie config).';\n  status = 400;\n  statusCode = 400;\n\n  constructor() {\n    /* c8 ignore next */\n    super(MissingStateCookieError.message);\n    Object.setPrototypeOf(this, MissingStateCookieError.prototype);\n  }\n}\n\nexport class ApplicationError extends EscapedError {\n  /**\n   * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data\n   * directly into the HTML body\n   */\n  constructor(rpError: Error) {\n    /* c8 ignore next */\n    super(rpError.message);\n    Object.setPrototypeOf(this, ApplicationError.prototype);\n  }\n}\n\nexport class IdentityProviderError extends EscapedError {\n  /**\n   * The 'error_description' parameter from the AS response.\n   * **WARNING** This can contain user input and is only escaped using basic escaping for putting untrusted data\n   * directly into the HTML body\n   */\n  errorDescription?: string;\n  /**\n   * The 'error' parameter from the AS response\n   * **WARNING** This can contain user input and is only escaped using basic escaping for putting untrusted data\n   * directly into the HTML body\n   */\n  error?: string;\n\n  /**\n   * **WARNING** The message can contain user input and is only escaped using basic escaping for putting untrusted data\n   * directly into the HTML body\n   */\n  constructor(rpError: { message: string; error?: string; error_description?: string }) {\n    /* c8 ignore next */\n    super(rpError.message);\n    this.error = htmlSafe(rpError.error);\n    this.errorDescription = htmlSafe(rpError.error_description);\n    Object.setPrototypeOf(this, IdentityProviderError.prototype);\n  }\n}\n\nexport class DiscoveryError extends EscapedError {\n  constructor(error: Error | (Error & { _errors: Error[] }), issuerBaseUrl: string) {\n    /* c8 ignore next */\n    super(`Discovery requests failing for ${issuerBaseUrl}, ${error.message}`);\n    Object.setPrototypeOf(this, DiscoveryError.prototype);\n  }\n}\n\nexport class UserInfoError extends EscapedError {\n  constructor(msg: string) {\n    /* c8 ignore next */\n    super(`Userinfo request failing with: ${msg}`);\n    Object.setPrototypeOf(this, UserInfoError.prototype);\n  }\n}\n\nexport class BackchannelLogoutError extends Error {\n  constructor(public code: string, public description: string) {\n    /* c8 ignore next */\n    super(description);\n    Object.setPrototypeOf(this, BackchannelLogoutError.prototype);\n  }\n}\n\n// eslint-disable-next-line max-len\n// Basic escaping for putting untrusted data directly into the HTML body, per: https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#rule-1-html-encode-before-inserting-untrusted-data-into-html-element-content.\nexport function htmlSafe(input?: string): string | undefined {\n  return (\n    input &&\n    input\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#39;')\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAa,qBAAqB;IAChC;;;QAIA,YAAY,OAAe,CAAA;QACzB,kBAAA,GACA,KAAK,CAAC,SAAS;QACf,OAAO,cAAc,CAAC,IAAI,EAAE,aAAa,SAAS;IACpD;;AATF,QAAA,YAAA,GAAA;AAYA,MAAa,+BAA+B;IAK1C,aAAA;QACE,kBAAA,GACA,KAAK,CAAC,uBAAuB,OAAO;QALtC,IAAA,CAAA,MAAM,GAAG;QACT,IAAA,CAAA,UAAU,GAAG;QAKX,OAAO,cAAc,CAAC,IAAI,EAAE,uBAAuB,SAAS;IAC9D;;AATF,QAAA,sBAAA,GAAA;AACS,uBAAA,OAAO,GAAG;AAWnB,MAAa,kCAAkC;IAK7C,aAAA;QACE,kBAAA,GACA,KAAK,CAAC,0BAA0B,OAAO;QALzC,IAAA,CAAA,MAAM,GAAG;QACT,IAAA,CAAA,UAAU,GAAG;QAKX,OAAO,cAAc,CAAC,IAAI,EAAE,0BAA0B,SAAS;IACjE;;AATF,QAAA,yBAAA,GAAA;AACS,0BAAA,OAAO,GAAG;AAWnB,MAAa,gCAAgC;IAK3C,aAAA;QACE,kBAAA,GACA,KAAK,CAAC,wBAAwB,OAAO;QALvC,IAAA,CAAA,MAAM,GAAG;QACT,IAAA,CAAA,UAAU,GAAG;QAKX,OAAO,cAAc,CAAC,IAAI,EAAE,wBAAwB,SAAS;IAC/D;;AATF,QAAA,uBAAA,GAAA;AACS,wBAAA,OAAO,GAAG;AAWnB,MAAa,yBAAyB;IACpC;;;QAIA,YAAY,OAAc,CAAA;QACxB,kBAAA,GACA,KAAK,CAAC,QAAQ,OAAO;QACrB,OAAO,cAAc,CAAC,IAAI,EAAE,iBAAiB,SAAS;IACxD;;AATF,QAAA,gBAAA,GAAA;AAYA,MAAa,8BAA8B;IAczC;;;QAIA,YAAY,OAAwE,CAAA;QAClF,kBAAA,GACA,KAAK,CAAC,QAAQ,OAAO;QACrB,IAAI,CAAC,KAAK,GAAG,SAAS,QAAQ,KAAK;QACnC,IAAI,CAAC,gBAAgB,GAAG,SAAS,QAAQ,iBAAiB;QAC1D,OAAO,cAAc,CAAC,IAAI,EAAE,sBAAsB,SAAS;IAC7D;;AAxBF,QAAA,qBAAA,GAAA;AA2BA,MAAa,uBAAuB;IAClC,YAAY,KAA6C,EAAE,aAAqB,CAAA;QAC9E,kBAAA,GACA,KAAK,CAAC,CAAA,+BAAA,EAAkC,cAAa,EAAA,EAAK,MAAM,OAAO,CAAA,CAAE;QACzE,OAAO,cAAc,CAAC,IAAI,EAAE,eAAe,SAAS;IACtD;;AALF,QAAA,cAAA,GAAA;AAQA,MAAa,sBAAsB;IACjC,YAAY,GAAW,CAAA;QACrB,kBAAA,GACA,KAAK,CAAC,CAAA,+BAAA,EAAkC,IAAG,CAAE;QAC7C,OAAO,cAAc,CAAC,IAAI,EAAE,cAAc,SAAS;IACrD;;AALF,QAAA,aAAA,GAAA;AAQA,MAAa,+BAA+B;IAC1C,YAAmB,IAAY,EAAS,WAAmB,CAAA;QACzD,kBAAA,GACA,KAAK,CAAC;QAFW,IAAA,CAAA,IAAI,GAAJ;QAAqB,IAAA,CAAA,WAAW,GAAX;QAGtC,OAAO,cAAc,CAAC,IAAI,EAAE,uBAAuB,SAAS;IAC9D;;AALF,QAAA,sBAAA,GAAA;AAQA,mCAAmC;AACnC,4PAA4P;AAC5P,SAAgB,SAAS,KAAc;IACrC,OACE,SACA,MACG,OAAO,CAAC,MAAM,SACd,OAAO,CAAC,MAAM,QACd,OAAO,CAAC,MAAM,QACd,OAAO,CAAC,MAAM,UACd,OAAO,CAAC,MAAM;AAErB;AAVA,QAAA,QAAA,GAAA"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/debug.ts"],"sourcesContent":["import createDebug, { Debugger } from 'debug';\n\nexport default (name: string): Debugger => createDebug('nextjs-auth0').extend(name);\n"],"names":[],"mappings":";;;;;AAAA,MAAA,UAAA,QAAA,eAAA;AAEA,QAAA,OAAA,GAAe,CAAC,OAA2B,CAAA,GAAA,QAAA,OAAW,EAAC,gBAAgB,MAAM,CAAC"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/hkdf.ts"],"sourcesContent":["import hkdf from '@panva/hkdf';\n\nconst BYTE_LENGTH = 32;\nconst ENCRYPTION_INFO = 'JWE CEK';\nconst SIGNING_INFO = 'JWS Cookie Signing';\nconst digest = 'sha256';\n\n/**\n *\n * Derives appropriate sized keys from the end-user provided secret random string/passphrase using\n * HKDF (HMAC-based Extract-and-Expand Key Derivation Function) defined in RFC 8569.\n *\n * @see https://tools.ietf.org/html/rfc5869\n *\n */\nexport const encryption = (secret: string): Promise<Uint8Array> =>\n  hkdf(digest, secret, '', ENCRYPTION_INFO, BYTE_LENGTH);\nexport const signing = (secret: string): Promise<Uint8Array> => hkdf(digest, secret, '', SIGNING_INFO, BYTE_LENGTH);\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,SAAA,QAAA,eAAA;AAEA,MAAM,cAAc;AACpB,MAAM,kBAAkB;AACxB,MAAM,eAAe;AACrB,MAAM,SAAS;AAEf;;;;;;;IAQO,MAAM,aAAa,CAAC,SACzB,CAAA,GAAA,OAAA,OAAI,EAAC,QAAQ,QAAQ,IAAI,iBAAiB;AAD/B,QAAA,UAAU,GAAA;AAEhB,MAAM,UAAU,CAAC,SAAwC,CAAA,GAAA,OAAA,OAAI,EAAC,QAAQ,QAAQ,IAAI,cAAc;AAA1F,QAAA,OAAO,GAAA"}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 141, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/session/abstract-session.ts"],"sourcesContent":["import createDebug from '../utils/debug';\nimport { CookieSerializeOptions } from 'cookie';\nimport { Config, GetConfig } from '../config';\nimport { Auth0RequestCookies, Auth0ResponseCookies } from '../http';\n\nconst debug = createDebug('session');\n\nexport interface SessionPayload<Session> {\n  header: {\n    /**\n     * Timestamp (in secs) when the session was created.\n     */\n    iat: number;\n    /**\n     * Timestamp (in secs) when the session was last touched.\n     */\n    uat: number;\n    /**\n     * Timestamp (in secs) when the session expires.\n     */\n    exp: number;\n  };\n\n  /**\n   * The session data.\n   */\n  data: Session;\n}\n\nconst epoch = (): number => (Date.now() / 1000) | 0; // eslint-disable-line no-bitwise\nexport type Header = { iat: number; uat: number; exp: number; [propName: string]: unknown };\nconst assert = (bool: boolean, msg: string) => {\n  if (!bool) {\n    throw new Error(msg);\n  }\n};\n\nexport abstract class AbstractSession<Session> {\n  protected getConfig: (req: Auth0RequestCookies) => Config | Promise<Config>;\n\n  constructor(getConfig: GetConfig) {\n    this.getConfig = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  }\n\n  abstract getSession(req: Auth0RequestCookies): Promise<SessionPayload<Session> | undefined | null>;\n\n  abstract setSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    session: Session,\n    uat: number,\n    iat: number,\n    exp: number,\n    cookieOptions: CookieSerializeOptions,\n    isNewSession: boolean\n  ): Promise<void>;\n\n  abstract deleteSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    cookieOptions: CookieSerializeOptions\n  ): Promise<void>;\n\n  public async read(req: Auth0RequestCookies): Promise<[Session?, number?]> {\n    const config = await this.getConfig(req);\n    const { rollingDuration, absoluteDuration } = config.session;\n\n    try {\n      const existingSessionValue = await this.getSession(req);\n\n      if (existingSessionValue) {\n        const { header, data } = existingSessionValue;\n        const { iat, uat, exp } = header;\n\n        // check that the existing session isn't expired based on options when it was established\n        assert(exp > epoch(), 'it is expired based on options when it was established');\n\n        // check that the existing session isn't expired based on current rollingDuration rules\n        if (rollingDuration) {\n          assert(uat + rollingDuration > epoch(), 'it is expired based on current rollingDuration rules');\n        }\n\n        // check that the existing session isn't expired based on current absoluteDuration rules\n        if (typeof absoluteDuration === 'number') {\n          assert(iat + absoluteDuration > epoch(), 'it is expired based on current absoluteDuration rules');\n        }\n\n        return [data, iat];\n      }\n    } catch (err) {\n      debug('error handling session %O', err);\n    }\n\n    return [];\n  }\n\n  public async save(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    session: Session | null | undefined,\n    createdAt?: number\n  ): Promise<void> {\n    const config = await this.getConfig(req);\n    const {\n      cookie: { transient, ...cookieConfig }\n    } = config.session;\n\n    if (!session) {\n      await this.deleteSession(req, res, cookieConfig);\n      return;\n    }\n\n    const isNewSession = typeof createdAt === 'undefined';\n    const uat = epoch();\n    const iat = typeof createdAt === 'number' ? createdAt : uat;\n    const exp = this.calculateExp(iat, uat, config);\n\n    const cookieOptions: CookieSerializeOptions = {\n      ...cookieConfig\n    };\n    if (!transient) {\n      cookieOptions.expires = new Date(exp * 1000);\n    }\n\n    await this.setSession(req, res, session, uat, iat, exp, cookieOptions, isNewSession);\n  }\n\n  private calculateExp(iat: number, uat: number, config: Config): number {\n    const { absoluteDuration } = config.session;\n    const { rolling, rollingDuration } = config.session;\n\n    if (typeof absoluteDuration !== 'number') {\n      return uat + (rollingDuration as number);\n    }\n    if (!rolling) {\n      return iat + absoluteDuration;\n    }\n    return Math.min(uat + (rollingDuration as number), iat + absoluteDuration);\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,QAAA,eAAA;AAKA,MAAM,QAAQ,CAAA,GAAA,QAAA,OAAW,EAAC;AAwB1B,MAAM,QAAQ,IAAc,AAAC,KAAK,GAAG,KAAK,OAAQ,GAAG,iCAAiC;AAEtF,MAAM,SAAS,CAAC,MAAe;IAC7B,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,MAAM;;AAEpB;AAEA,MAAsB;IAGpB,YAAY,SAAoB,CAAA;QAC9B,IAAI,CAAC,SAAS,GAAG,OAAO,cAAc,aAAa,YAAY,IAAM;IACvE;IAqBO,MAAM,KAAK,GAAwB,EAAA;QACxC,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS,CAAC;QACpC,MAAM,EAAE,eAAe,EAAE,gBAAgB,EAAE,GAAG,OAAO,OAAO;QAE5D,IAAI;YACF,MAAM,uBAAuB,MAAM,IAAI,CAAC,UAAU,CAAC;YAEnD,IAAI,sBAAsB;gBACxB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG;gBACzB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;gBAE1B,yFAAyF;gBACzF,OAAO,MAAM,SAAS;gBAEtB,uFAAuF;gBACvF,IAAI,iBAAiB;oBACnB,OAAO,MAAM,kBAAkB,SAAS;;gBAG1C,wFAAwF;gBACxF,IAAI,OAAO,qBAAqB,UAAU;oBACxC,OAAO,MAAM,mBAAmB,SAAS;;gBAG3C,OAAO;oBAAC;oBAAM;iBAAI;;UAEpB,OAAO,KAAK;YACZ,MAAM,6BAA6B;;QAGrC,OAAO,EAAE;IACX;IAEO,MAAM,KACX,GAAwB,EACxB,GAAyB,EACzB,OAAmC,EACnC,SAAkB,EAAA;QAElB,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS,CAAC;QACpC,MACE,KACE,OAAO,OAAO,CAAA,MADsB,EAAtC,EAAU,SAAS,EAAA,GAAA,IAAK,eAAY,QAAA,MAAA,CAAA,IAA5B;YAAA;SAA8B;QAGxC,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK;YACnC;;QAGF,MAAM,eAAe,OAAO,cAAc;QAC1C,MAAM,MAAM;QACZ,MAAM,MAAM,OAAO,cAAc,WAAW,YAAY;QACxD,MAAM,MAAM,IAAI,CAAC,YAAY,CAAC,KAAK,KAAK;QAExC,MAAM,gBAAa,OAAA,MAAA,CAAA,CAAA,GACd;QAEL,IAAI,CAAC,WAAW;YACd,cAAc,OAAO,GAAG,IAAI,KAAK,MAAM;;QAGzC,MAAM,IAAI,CAAC,UAAU,CAAC,KAAK,KAAK,SAAS,KAAK,KAAK,KAAK,eAAe;IACzE;IAEQ,aAAa,GAAW,EAAE,GAAW,EAAE,MAAc,EAAA;QAC3D,MAAM,EAAE,gBAAgB,EAAE,GAAG,OAAO,OAAO;QAC3C,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,GAAG,OAAO,OAAO;QAEnD,IAAI,OAAO,qBAAqB,UAAU;YACxC,OAAO,MAAO;;QAEhB,IAAI,CAAC,SAAS;YACZ,OAAO,MAAM;;QAEf,OAAO,KAAK,GAAG,CAAC,MAAO,iBAA4B,MAAM;IAC3D;;AArGF,QAAA,eAAA,GAAA"}},
    {"offset": {"line": 219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/session/stateless-session.ts"],"sourcesContent":["import * as jose from 'jose';\nimport { CookieSerializeOptions, serialize } from 'cookie';\nimport createDebug from '../utils/debug';\nimport { Config } from '../config';\nimport { encryption } from '../utils/hkdf';\nimport { AbstractSession, Header, SessionPayload } from './abstract-session';\nimport { Auth0RequestCookies, Auth0ResponseCookies } from '../http';\n\nconst debug = createDebug('stateless-session');\n\nconst MAX_COOKIE_SIZE = 4096;\nconst alg = 'dir';\nconst enc = 'A256GCM';\n\nconst notNull = <T>(value: T | null): value is T => value !== null;\n\nexport class StatelessSession<\n  Session extends { [key: string]: any } = { [key: string]: any }\n> extends AbstractSession<Session> {\n  private keys?: Uint8Array[];\n  private chunkSize?: number;\n\n  constructor(protected config: Config) {\n    super(config);\n  }\n\n  private async getChunkSize(config: Config): Promise<number> {\n    if (this.chunkSize === undefined) {\n      const {\n        cookie: { transient, ...cookieConfig },\n        name: sessionName\n      } = config.session;\n      const cookieOptions: CookieSerializeOptions = {\n        ...cookieConfig\n      };\n      if (!transient) {\n        cookieOptions.expires = new Date();\n      }\n\n      const emptyCookie = serialize(`${sessionName}.0`, '', cookieOptions);\n      this.chunkSize = MAX_COOKIE_SIZE - emptyCookie.length;\n    }\n    return this.chunkSize;\n  }\n\n  public async getKeys(config: Config): Promise<Uint8Array[]> {\n    if (!this.keys) {\n      const secret = config.secret;\n      const secrets = Array.isArray(secret) ? secret : [secret];\n      this.keys = await Promise.all(secrets.map(encryption));\n    }\n    return this.keys;\n  }\n\n  public async encrypt(payload: jose.JWTPayload, { iat, uat, exp }: Header, key: Uint8Array): Promise<string> {\n    return await new jose.EncryptJWT({ ...payload }).setProtectedHeader({ alg, enc, uat, iat, exp }).encrypt(key);\n  }\n\n  private async decrypt(jwe: string, keys: Uint8Array[]): Promise<jose.JWTDecryptResult> {\n    let err;\n    for (const key of keys) {\n      try {\n        return await jose.jwtDecrypt(jwe, key);\n      } catch (e) {\n        err = e;\n      }\n    }\n    throw err;\n  }\n\n  async getSession(req: Auth0RequestCookies): Promise<SessionPayload<Session> | undefined | null> {\n    const config = await this.getConfig(req);\n    const { name: sessionName } = config.session;\n    const cookies = req.getCookies();\n    let existingSessionValue: string | undefined;\n    if (sessionName in cookies) {\n      // get JWE from un-chunked session cookie\n      debug('reading session from %s cookie', sessionName);\n      existingSessionValue = cookies[sessionName];\n    } else if (`${sessionName}.0` in cookies) {\n      // get JWE from chunked session cookie\n      // iterate all cookie names\n      // match and filter for the ones that match sessionName.<number>\n      // sort by chunk index\n      // concat\n      existingSessionValue = Object.entries(cookies)\n        .map(([cookie, value]): [string, string] | null => {\n          const match = cookie.match(`^${sessionName}\\\\.(\\\\d+)$`);\n          if (match) {\n            return [match[1], value as string];\n          }\n          return null;\n        })\n        .filter(notNull)\n        .sort(([a], [b]) => {\n          return parseInt(a, 10) - parseInt(b, 10);\n        })\n        .map(([i, chunk]) => {\n          debug('reading session chunk from %s.%d cookie', sessionName, i);\n          return chunk;\n        })\n        .join('');\n    }\n    if (existingSessionValue) {\n      const keys = await this.getKeys(config);\n      const { protectedHeader, payload } = await this.decrypt(existingSessionValue, keys);\n      return { header: protectedHeader as unknown as Header, data: payload as Session };\n    }\n    return;\n  }\n\n  async setSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    session: Session,\n    uat: number,\n    iat: number,\n    exp: number,\n    cookieOptions: CookieSerializeOptions\n  ): Promise<void> {\n    const config = await this.getConfig(req);\n    const { name: sessionName } = config.session;\n    const cookies = req.getCookies();\n\n    debug('found session, creating signed session cookie(s) with name %o(.i)', sessionName);\n    const [key] = await this.getKeys(config);\n    const value = await this.encrypt(session, { iat, uat, exp }, key);\n\n    const chunkSize = await this.getChunkSize(config);\n    const chunkCount = Math.ceil(value.length / chunkSize);\n\n    const existingCookies = new Set(\n      Object.keys(cookies).filter((cookie) => cookie.match(`^${sessionName}(?:\\\\.\\\\d)?$`))\n    );\n\n    if (chunkCount > 1) {\n      debug('cookie size greater than %d, chunking', this.chunkSize);\n      for (let i = 0; i < chunkCount; i++) {\n        const chunkValue = value.slice(i * chunkSize, (i + 1) * chunkSize);\n        const chunkCookieName = `${sessionName}.${i}`;\n        res.setCookie(chunkCookieName, chunkValue, cookieOptions);\n        existingCookies.delete(chunkCookieName);\n      }\n    } else {\n      res.setCookie(sessionName, value, cookieOptions);\n      existingCookies.delete(sessionName);\n    }\n\n    // When the number of chunks changes due to the cookie size changing,\n    // you need to delete any obsolete cookies.\n    existingCookies.forEach((cookie) => res.clearCookie(cookie, cookieOptions));\n  }\n\n  async deleteSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    cookieOptions: CookieSerializeOptions\n  ): Promise<void> {\n    const config = await this.getConfig(req);\n    const { name: sessionName } = config.session;\n    const cookies = req.getCookies();\n\n    for (const cookieName of Object.keys(cookies)) {\n      if (cookieName.match(`^${sessionName}(?:\\\\.\\\\d)?$`)) {\n        res.clearCookie(cookieName, cookieOptions);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 371, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/signed-cookies.ts"],"sourcesContent":["import * as jose from 'jose';\n\nexport const getCookieValue = async (k: string, v: string, keys: Uint8Array[]): Promise<string | undefined> => {\n  if (!v) {\n    return undefined;\n  }\n  const [value, signature] = v.split('.');\n  const flattenedJWS = {\n    protected: jose.base64url.encode(JSON.stringify({ alg: 'HS256', b64: false, crit: ['b64'] })),\n    payload: `${k}=${value}`,\n    signature\n  };\n  for (const key of keys) {\n    try {\n      await jose.flattenedVerify(flattenedJWS, key, {\n        algorithms: ['HS256']\n      });\n      return value;\n    } catch (e) {}\n  }\n  return;\n};\n\nexport const generateCookieValue = async (cookie: string, value: string, key: Uint8Array): Promise<string> => {\n  const { signature } = await new jose.FlattenedSign(new TextEncoder().encode(`${cookie}=${value}`))\n    .setProtectedHeader({ alg: 'HS256', b64: false, crit: ['b64'] })\n    .sign(key);\n  return `${value}.${signature}`;\n};\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,QAAA,YAAA;AAEO,MAAM,iBAAiB,OAAO,GAAW,GAAW;IACzD,IAAI,CAAC,GAAG;QACN,OAAO;;IAET,MAAM,CAAC,OAAO,UAAU,GAAG,EAAE,KAAK,CAAC;IACnC,MAAM,eAAe;QACnB,WAAW,KAAK,SAAS,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;YAAE,KAAK;YAAS,KAAK;YAAO,MAAM;gBAAC;aAAM;QAAA;QACzF,SAAS,CAAA,EAAG,EAAC,CAAA,EAAI,MAAK,CAAE;QACxB;;IAEF,KAAK,MAAM,OAAO,KAAM;QACtB,IAAI;YACF,MAAM,KAAK,eAAe,CAAC,cAAc,KAAK;gBAC5C,YAAY;oBAAC;iBAAQ;;YAEvB,OAAO;UACP,OAAO,GAAG,CAAA;;IAEd;AACF;AAnBa,QAAA,cAAc,GAAA;AAqBpB,MAAM,sBAAsB,OAAO,QAAgB,OAAe;IACvE,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAI,KAAK,aAAa,CAAC,IAAI,cAAc,MAAM,CAAC,CAAA,EAAG,OAAM,CAAA,EAAI,MAAK,CAAE,GAC7F,kBAAkB,CAAC;QAAE,KAAK;QAAS,KAAK;QAAO,MAAM;YAAC;SAAM;IAAA,GAC5D,IAAI,CAAC;IACR,OAAO,CAAA,EAAG,MAAK,CAAA,EAAI,UAAS,CAAE;AAChC;AALa,QAAA,mBAAmB,GAAA"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/session/stateful-session.ts"],"sourcesContent":["import { CookieSerializeOptions } from 'cookie';\nimport createDebug from '../utils/debug';\nimport { AbstractSession, SessionPayload } from './abstract-session';\nimport { generateCookieValue, getCookieValue } from '../utils/signed-cookies';\nimport { signing } from '../utils/hkdf';\nimport { Auth0RequestCookies, Auth0ResponseCookies } from '../http';\nimport { Config } from '../config';\n\nconst debug = createDebug('stateful-session');\n\nexport interface SessionStore<Session> {\n  /**\n   * Gets the session from the store given a session ID.\n   */\n  get(sid: string): Promise<SessionPayload<Session> | null | undefined>;\n\n  /**\n   * Upsert a session in the store given a session ID and `SessionData`.\n   */\n  set(sid: string, session: SessionPayload<Session>): Promise<void>;\n\n  /**\n   * Destroys the session with the given session ID.\n   */\n  delete(sid: string): Promise<void>;\n}\n\nexport class StatefulSession<\n  Session extends { [key: string]: any } = { [key: string]: any }\n> extends AbstractSession<Session> {\n  private keys?: Uint8Array[];\n  private store?: SessionStore<Session>;\n\n  private async getStore(config: Config): Promise<SessionStore<Session>> {\n    if (!this.store) {\n      this.store = config.session.store as SessionStore<Session>;\n    }\n    return this.store;\n  }\n\n  private async getKeys(config: Config): Promise<Uint8Array[]> {\n    if (!this.keys) {\n      const secret = config.secret;\n      const secrets = Array.isArray(secret) ? secret : [secret];\n      this.keys = await Promise.all(secrets.map(signing));\n    }\n    return this.keys;\n  }\n\n  async getSession(req: Auth0RequestCookies): Promise<SessionPayload<Session> | undefined | null> {\n    const config = await this.getConfig(req);\n    const { name: sessionName } = config.session;\n    const cookies = req.getCookies();\n    const keys = await this.getKeys(config);\n    const sessionId = await getCookieValue(sessionName, cookies[sessionName], keys);\n\n    if (sessionId) {\n      const store = await this.getStore(config);\n      debug('reading session from %s store', sessionId);\n      return store.get(sessionId);\n    }\n    return;\n  }\n\n  async setSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    session: Session,\n    uat: number,\n    iat: number,\n    exp: number,\n    cookieOptions: CookieSerializeOptions,\n    isNewSession: boolean\n  ): Promise<void> {\n    const config = await this.getConfig(req);\n    const store = await this.getStore(config);\n    const { name: sessionName, genId } = config.session;\n    const cookies = req.getCookies();\n    const keys = await this.getKeys(config);\n    let sessionId = await getCookieValue(sessionName, cookies[sessionName], keys);\n\n    // If this is a new session created by a new login we need to remove the old session\n    // from the store and regenerate the session id to prevent session fixation issue.\n    if (sessionId && isNewSession) {\n      debug('regenerating session id %o to prevent session fixation', sessionId);\n      await store.delete(sessionId);\n      sessionId = undefined;\n    }\n\n    if (!sessionId) {\n      sessionId = await genId!(req, session);\n      debug('generated new session id %o', sessionId);\n    }\n    debug('set session %o', sessionId);\n    const cookieValue = await generateCookieValue(sessionName, sessionId, keys[0]);\n    res.setCookie(sessionName, cookieValue, cookieOptions);\n    await store.set(sessionId, {\n      header: { iat, uat, exp },\n      data: session\n    });\n  }\n\n  async deleteSession(\n    req: Auth0RequestCookies,\n    res: Auth0ResponseCookies,\n    cookieOptions: CookieSerializeOptions\n  ): Promise<void> {\n    const config = await this.getConfig(req);\n    const { name: sessionName } = config.session;\n    const cookies = req.getCookies();\n    const keys = await this.getKeys(config);\n    const sessionId = await getCookieValue(sessionName, cookies[sessionName], keys);\n\n    if (sessionId) {\n      const store = await this.getStore(config);\n      debug('deleting session %o', sessionId);\n      res.clearCookie(sessionName, cookieOptions);\n      await store.delete(sessionId);\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/transient-store.ts"],"sourcesContent":["import { generateCookieValue, getCookieValue } from './utils/signed-cookies';\nimport { signing } from './utils/hkdf';\nimport { Config, GetConfig } from './config';\nimport { Auth0Request, Auth0RequestCookies, Auth0Response } from './http';\n\nexport interface StoreOptions {\n  sameSite?: boolean | 'lax' | 'strict' | 'none';\n  value: string;\n}\n\nexport default class TransientStore {\n  private keys?: Uint8Array[];\n\n  protected getConfig: (req: Auth0RequestCookies) => Config | Promise<Config>;\n\n  constructor(getConfig: GetConfig) {\n    this.getConfig = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  }\n\n  private async getKeys(config: Config): Promise<Uint8Array[]> {\n    if (!this.keys) {\n      const secret = config.secret;\n      const secrets = Array.isArray(secret) ? secret : [secret];\n      this.keys = await Promise.all(secrets.map(signing));\n    }\n    return this.keys;\n  }\n\n  /**\n   * Set a cookie with a value or a generated nonce.\n   *\n   * @param {String} key Cookie name to use.\n   * @param {IncomingMessage} req Server Request object.\n   * @param {ServerResponse} res Server Response object.\n   * @param {Object} opts Options object.\n   * @param {String} opts.sameSite SameSite attribute of `None`, `Lax`, or `Strict`. Defaults to `None`.\n   * @param {String} opts.value Cookie value. Omit this key to store a generated value.\n   *\n   * @return {String} Cookie value that was set.\n   */\n  async save(\n    key: string,\n    req: Auth0Request,\n    res: Auth0Response,\n    { sameSite = 'none', value }: StoreOptions\n  ): Promise<string> {\n    const isSameSiteNone = sameSite === 'none';\n    const config = await this.getConfig(req);\n    const { domain, path, secure } = config.transactionCookie;\n    const basicAttr = {\n      httpOnly: true,\n      secure,\n      domain,\n      path\n    };\n    const [signingKey] = await this.getKeys(config);\n\n    {\n      const cookieValue = await generateCookieValue(key, value, signingKey);\n      // Set the cookie with the SameSite attribute and, if needed, the Secure flag.\n      res.setCookie(key, cookieValue, {\n        ...basicAttr,\n        sameSite,\n        secure: isSameSiteNone ? true : basicAttr.secure\n      });\n    }\n\n    if (isSameSiteNone && config.legacySameSiteCookie) {\n      const cookieValue = await generateCookieValue(`_${key}`, value, signingKey);\n      // Set the fallback cookie with no SameSite or Secure attributes.\n      res.setCookie(`_${key}`, cookieValue, basicAttr);\n    }\n\n    return value;\n  }\n\n  /**\n   * Get a cookie value then delete it.\n   *\n   * @param {String} key Cookie name to use.\n   * @param {IncomingMessage} req Express Request object.\n   * @param {ServerResponse} res Express Response object.\n   *\n   * @return {String|undefined} Cookie value or undefined if cookie was not found.\n   */\n  async read(key: string, req: Auth0Request, res: Auth0Response): Promise<string | undefined> {\n    const cookies = req.getCookies();\n    const cookie = cookies[key];\n    const config = await this.getConfig(req);\n    const cookieConfig = config.transactionCookie;\n\n    const verifyingKeys = await this.getKeys(config);\n    let value = await getCookieValue(key, cookie, verifyingKeys);\n    res.clearCookie(key, cookieConfig);\n\n    if (config.legacySameSiteCookie) {\n      const fallbackKey = `_${key}`;\n      if (!value) {\n        const fallbackCookie = cookies[fallbackKey];\n        value = await getCookieValue(fallbackKey, fallbackCookie, verifyingKeys);\n      }\n      res.clearCookie(fallbackKey, cookieConfig);\n    }\n\n    return value;\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AACA,MAAA;AASA,MAAqB;IAKnB,YAAY,SAAoB,CAAA;QAC9B,IAAI,CAAC,SAAS,GAAG,OAAO,cAAc,aAAa,YAAY,IAAM;IACvE;IAEQ,MAAM,QAAQ,MAAc,EAAA;QAClC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACd,MAAM,SAAS,OAAO,MAAM;YAC5B,MAAM,UAAU,MAAM,OAAO,CAAC,UAAU,SAAS;gBAAC;aAAO;YACzD,IAAI,CAAC,IAAI,GAAG,MAAM,QAAQ,GAAG,CAAC,QAAQ,GAAG,CAAC,OAAA,OAAO;;QAEnD,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA;;;;;;;;;;;QAYA,MAAM,KACJ,GAAW,EACX,GAAiB,EACjB,GAAkB,EAClB,EAAE,WAAW,MAAM,EAAE,KAAK,EAAgB,EAAA;QAE1C,MAAM,iBAAiB,aAAa;QACpC,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS,CAAC;QACpC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,OAAO,iBAAiB;QACzD,MAAM,YAAY;YAChB,UAAU;YACV;YACA;YACA;;QAEF,MAAM,CAAC,WAAW,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC;QAExC;YACE,MAAM,cAAc,MAAM,CAAA,GAAA,iBAAA,mBAAmB,EAAC,KAAK,OAAO;YAC1D,8EAA8E;YAC9E,IAAI,SAAS,CAAC,KAAK,aAAW,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACzB,YAAS;gBACZ;gBACA,QAAQ,iBAAiB,OAAO,UAAU,MAAM;YAAA;;QAIpD,IAAI,kBAAkB,OAAO,oBAAoB,EAAE;YACjD,MAAM,cAAc,MAAM,CAAA,GAAA,iBAAA,mBAAmB,EAAC,CAAA,CAAA,EAAI,IAAG,CAAE,EAAE,OAAO;YAChE,iEAAiE;YACjE,IAAI,SAAS,CAAC,CAAA,CAAA,EAAI,IAAG,CAAE,EAAE,aAAa;;QAGxC,OAAO;IACT;IAEA;;;;;;;;QASA,MAAM,KAAK,GAAW,EAAE,GAAiB,EAAE,GAAkB,EAAA;QAC3D,MAAM,UAAU,IAAI,UAAU;QAC9B,MAAM,SAAS,OAAO,CAAC,IAAI;QAC3B,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS,CAAC;QACpC,MAAM,eAAe,OAAO,iBAAiB;QAE7C,MAAM,gBAAgB,MAAM,IAAI,CAAC,OAAO,CAAC;QACzC,IAAI,QAAQ,MAAM,CAAA,GAAA,iBAAA,cAAc,EAAC,KAAK,QAAQ;QAC9C,IAAI,WAAW,CAAC,KAAK;QAErB,IAAI,OAAO,oBAAoB,EAAE;YAC/B,MAAM,cAAc,CAAA,CAAA,EAAI,IAAG,CAAE;YAC7B,IAAI,CAAC,OAAO;gBACV,MAAM,iBAAiB,OAAO,CAAC,YAAY;gBAC3C,QAAQ,MAAM,CAAA,GAAA,iBAAA,cAAc,EAAC,aAAa,gBAAgB;;YAE5D,IAAI,WAAW,CAAC,aAAa;;QAG/B,OAAO;IACT;;AA/FF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 601, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 605, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/hooks/get-login-state.ts"],"sourcesContent":["import createDebug from '../utils/debug';\nimport { GetLoginState } from '../config';\n\nconst debug = createDebug('get-login-state');\n\n/**\n * Generate the state value for use during login transactions. It is used to store the intended\n * return URL after the user authenticates. State is not used to carry unique PRNG values here\n * because the library utilizes either nonce or PKCE for CSRF protection.\n *\n * @param {IncomingMessage} _req\n * @param {LoginOptions} options\n *\n * @return {object}\n */\nexport const getLoginState: GetLoginState = (options) => {\n  const state = { returnTo: options.returnTo };\n  debug('adding default state %O', state);\n  return state;\n};\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,UAAA,QAAA,eAAA;AAGA,MAAM,QAAQ,CAAA,GAAA,QAAA,OAAW,EAAC;AAE1B;;;;;;;;;IAUO,MAAM,gBAA+B,CAAC;IAC3C,MAAM,QAAQ;QAAE,UAAU,QAAQ,QAAQ;IAAA;IAC1C,MAAM,2BAA2B;IACjC,OAAO;AACT;AAJa,QAAA,aAAa,GAAA"}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 634, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/get-config.ts"],"sourcesContent":["import Joi from 'joi';\nimport { getLoginState } from './hooks/get-login-state';\nimport { Config } from './config';\n\nconst isHttps = /^https:/i;\n\nconst paramsSchema = Joi.object({\n  secret: Joi.alternatives([Joi.string().min(8), Joi.array().items(Joi.string().min(8))]).required(),\n  session: Joi.object({\n    rolling: Joi.boolean().optional().default(true),\n    rollingDuration: Joi.when(Joi.ref('rolling'), {\n      is: true,\n      then: Joi.number().integer().messages({\n        'number.base': '\"session.rollingDuration\" must be provided an integer value when \"session.rolling\" is true'\n      }),\n      otherwise: Joi.boolean().valid(false).messages({\n        'any.only': '\"session.rollingDuration\" must be false when \"session.rolling\" is disabled'\n      })\n    })\n      .optional()\n      .default((parent) => (parent.rolling ? 24 * 60 * 60 : false)), // 1 day when rolling is enabled, else false\n    absoluteDuration: Joi.when(Joi.ref('rolling'), {\n      is: false,\n      then: Joi.number().integer().messages({\n        'number.base': '\"session.absoluteDuration\" must be provided an integer value when \"session.rolling\" is false'\n      }),\n      otherwise: Joi.alternatives([Joi.number().integer(), Joi.boolean().valid(false)])\n    })\n      .optional()\n      .default(7 * 24 * 60 * 60), // 7 days,\n    autoSave: Joi.boolean().optional().default(true),\n    name: Joi.string().token().optional().default('appSession'),\n    store: Joi.object()\n      .optional()\n      .when(Joi.ref('/backchannelLogout'), {\n        not: false,\n        then: Joi.when('/backchannelLogout.store', {\n          not: Joi.exist(),\n          then: Joi.object().required().messages({\n            // eslint-disable-next-line max-len\n            'any.required': `Back-Channel Logout requires a \"backchannelLogout.store\" (you can also reuse \"session.store\" if you have stateful sessions).`\n          })\n        })\n      }),\n    genId: Joi.function().maxArity(2).when(Joi.ref('store'), { then: Joi.required() }),\n    storeIDToken: Joi.boolean().optional().default(true),\n    cookie: Joi.object({\n      domain: Joi.string().optional(),\n      transient: Joi.boolean().optional().default(false),\n      httpOnly: Joi.boolean().optional().default(true),\n      sameSite: Joi.string().valid('lax', 'strict', 'none').optional().default('lax'),\n      secure: Joi.when(Joi.ref('/baseURL'), {\n        is: Joi.string().pattern(isHttps),\n        then: Joi.boolean().valid(true).default(true).messages({\n          'any.only': 'Cookies must be secure when base url is https.'\n        }),\n        otherwise: Joi.boolean().valid(false).default(false).messages({\n          'any.only': 'Cookies set with the `Secure` property wont be attached to http requests'\n        })\n      }),\n      path: Joi.string().uri({ relativeOnly: true }).optional()\n    })\n      .default()\n      .unknown(false)\n  })\n    .default()\n    .unknown(false),\n  auth0Logout: Joi.boolean().optional(),\n  authorizationParams: Joi.object({\n    response_type: Joi.string().optional().valid('id_token', 'code id_token', 'code').default('id_token'),\n    scope: Joi.string()\n      .optional()\n      .pattern(/\\bopenid\\b/, 'contains openid')\n      .default('openid profile email'),\n    response_mode: Joi.string()\n      .optional()\n      .when('response_type', {\n        is: 'code',\n        then: Joi.valid('query', 'form_post'),\n        otherwise: Joi.valid('form_post').default('form_post')\n      })\n  })\n    .optional()\n    .unknown(true)\n    .default(),\n  baseURL: Joi.string()\n    .uri()\n    .required()\n    .when(Joi.ref('authorizationParams.response_mode'), {\n      is: 'form_post',\n      then: Joi.string()\n        .pattern(isHttps)\n        .rule({\n          warn: true,\n          message:\n            \"Using 'form_post' for response_mode may cause issues for you logging in over http, \" +\n            'see https://github.com/auth0/express-openid-connect/blob/master/FAQ.md'\n        })\n    }),\n  clientID: Joi.string().required(),\n  clientSecret: Joi.string()\n    .when(\n      Joi.ref('clientAuthMethod', {\n        adjust: (value) => value && value.includes('client_secret')\n      }),\n      {\n        is: true,\n        then: Joi.string().required().messages({\n          'any.required': '\"clientSecret\" is required for the clientAuthMethod {{clientAuthMethod}}'\n        })\n      }\n    )\n    .when(\n      Joi.ref('idTokenSigningAlg', {\n        adjust: (value) => value && value.startsWith('HS')\n      }),\n      {\n        is: true,\n        then: Joi.string().required().messages({\n          'any.required': '\"clientSecret\" is required for ID tokens with HMAC based algorithms'\n        })\n      }\n    ),\n  clockTolerance: Joi.number().optional().default(60),\n  httpTimeout: Joi.number().optional().default(5000),\n  httpAgent: Joi.object().optional(),\n  enableTelemetry: Joi.boolean().optional().default(true),\n  getLoginState: Joi.function()\n    .optional()\n    .default(() => getLoginState),\n  identityClaimFilter: Joi.array()\n    .optional()\n    .default(['aud', 'iss', 'iat', 'exp', 'nbf', 'nonce', 'azp', 'auth_time', 's_hash', 'at_hash', 'c_hash']),\n  idpLogout: Joi.boolean()\n    .optional()\n    .default((parent) => parent.auth0Logout || false),\n  idTokenSigningAlg: Joi.string().insensitive().not('none').optional().default('RS256'),\n  issuerBaseURL: Joi.string().uri().required(),\n  legacySameSiteCookie: Joi.boolean().optional().default(true),\n  routes: Joi.object({\n    callback: Joi.string().uri({ relativeOnly: true }).required(),\n    postLogoutRedirect: Joi.string().uri({ allowRelative: true }).default('')\n  })\n    .default()\n    .unknown(false),\n  clientAuthMethod: Joi.string()\n    .valid('client_secret_basic', 'client_secret_post', 'client_secret_jwt', 'private_key_jwt', 'none')\n    .optional()\n    .default((parent) => {\n      if (parent.authorizationParams.response_type === 'id_token' && !parent.pushedAuthorizationRequests) {\n        return 'none';\n      }\n\n      if (parent.clientAssertionSigningKey) {\n        return 'private_key_jwt';\n      }\n\n      return 'client_secret_basic';\n    })\n    .when(\n      Joi.ref('authorizationParams.response_type', {\n        adjust: (value) => value && value.includes('code')\n      }),\n      {\n        is: true,\n        then: Joi.string().invalid('none').messages({\n          'any.only': 'Public code flow clients are not supported.'\n        })\n      }\n    )\n    .when(Joi.ref('pushedAuthorizationRequests'), {\n      is: true,\n      then: Joi.string().invalid('none').messages({\n        'any.only': 'Public PAR clients are not supported'\n      })\n    }),\n  clientAssertionSigningKey: Joi.any()\n    .optional()\n    .when(Joi.ref('clientAuthMethod'), {\n      is: 'private_key_jwt',\n      then: Joi.any().required().messages({\n        'any.required': '\"clientAssertionSigningKey\" is required for a \"clientAuthMethod\" of \"private_key_jwt\"'\n      })\n    }),\n  clientAssertionSigningAlg: Joi.string()\n    .optional()\n    .valid('RS256', 'RS384', 'RS512', 'PS256', 'PS384', 'PS512', 'ES256', 'ES256K', 'ES384', 'ES512', 'EdDSA'),\n  transactionCookie: Joi.object({\n    name: Joi.string().default('auth_verification'),\n    domain: Joi.string().default(Joi.ref('/session.cookie.domain')),\n    secure: Joi.boolean().default(Joi.ref('/session.cookie.secure')),\n    sameSite: Joi.string().valid('lax', 'strict', 'none').default(Joi.ref('/session.cookie.sameSite')),\n    path: Joi.string().uri({ relativeOnly: true }).default(Joi.ref('/session.cookie.transient'))\n  })\n    .default()\n    .unknown(false),\n  backchannelLogout: Joi.alternatives([\n    Joi.object({\n      store: Joi.object().optional()\n    }),\n    Joi.boolean()\n  ]).default(false),\n  pushedAuthorizationRequests: Joi.boolean().optional().default(false)\n});\n\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends Array<infer I> ? Array<DeepPartial<I>> : DeepPartial<T[P]>;\n};\n\nexport type ConfigParameters = DeepPartial<Config>;\n\nexport const get = (params: ConfigParameters = {}): Config => {\n  const { value, error, warning } = paramsSchema.validate(params, { allowUnknown: true });\n  if (error) {\n    throw new TypeError(error.details[0].message);\n  }\n  if (warning) {\n    console.warn(warning.message);\n  }\n\n  return value;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 829, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/encoding.ts"],"sourcesContent":["import * as jose from 'jose';\n\n/**\n * Prepare a state object to send.\n *\n * @param {object} stateObject\n *\n * @return {string}\n */\nexport function encodeState(stateObject: { [key: string]: any }): string {\n  // This filters out nonce, code_verifier, and max_age from the state object so that the values are\n  // only stored in its dedicated transient cookie.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { nonce, code_verifier, max_age, ...filteredState } = stateObject;\n  return jose.base64url.encode(JSON.stringify(filteredState));\n}\n\n/**\n * Decode a state value.\n *\n * @param {string} stateValue\n *\n * @return {object|undefined}\n */\nexport function decodeState(stateValue?: string): { [key: string]: any } | undefined {\n  try {\n    return JSON.parse(new TextDecoder().decode(jose.base64url.decode(stateValue as string)));\n  } catch (e) {\n    return undefined;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,QAAA,YAAA;AAEA;;;;;;IAOA,SAAgB,YAAY,WAAmC;IAC7D,kGAAkG;IAClG,iDAAiD;IACjD,6DAA6D;IAC7D,MAAM,EAAE,KAAK,EAAE,aAAa,EAAE,OAAO,EAAA,GAAuB,aAAlB,gBAAa,QAAA,MAAA,CAAK,aAAtD;QAAA;QAAA;QAAA;KAAmD;IACzD,OAAO,KAAK,SAAS,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC;AAC9C;AANA,QAAA,WAAA,GAAA;AAQA;;;;;;IAOA,SAAgB,YAAY,UAAmB;IAC7C,IAAI;QACF,OAAO,KAAK,KAAK,CAAC,IAAI,cAAc,MAAM,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC;MACjE,OAAO,GAAG;QACV,OAAO;;AAEX;AANA,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 872, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/handlers/login.ts"],"sourcesContent":["import urlJoin from 'url-join';\nimport { Config, GetConfig, LoginOptions } from '../config';\nimport TransientStore from '../transient-store';\nimport { encodeState } from '../utils/encoding';\nimport createDebug from '../utils/debug';\nimport { Auth0Request, Auth0Response } from '../http';\nimport { GetClient } from '../client/abstract-client';\n\nconst debug = createDebug('handlers');\n\nfunction getRedirectUri(config: Config): string {\n  return urlJoin(config.baseURL, config.routes.callback);\n}\n\nexport type HandleLogin = (req: Auth0Request, res: Auth0Response, options?: LoginOptions) => Promise<void>;\n\nexport type AuthVerification = {\n  nonce: string;\n  state: string;\n  max_age?: number;\n  code_verifier?: string;\n  response_type?: string;\n};\n\nexport default function loginHandlerFactory(\n  getConfig: GetConfig,\n  getClient: GetClient,\n  transientHandler: TransientStore\n): HandleLogin {\n  const getConfigFn = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  return async (req, res, options = {}) => {\n    const config = await getConfigFn(req);\n    const client = await getClient(config);\n    const returnTo = options.returnTo || config.baseURL;\n\n    const opts = {\n      returnTo,\n      getLoginState: config.getLoginState,\n      ...options\n    };\n\n    // Ensure a redirect_uri, merge in configuration options, then passed-in options.\n    opts.authorizationParams = {\n      redirect_uri: getRedirectUri(config),\n      ...config.authorizationParams,\n      ...(opts.authorizationParams || {})\n    };\n\n    const stateValue = await opts.getLoginState(opts);\n    if (typeof stateValue !== 'object') {\n      throw new Error('Custom state value must be an object.');\n    }\n    stateValue.nonce = client.generateRandomNonce();\n    stateValue.returnTo = stateValue.returnTo || opts.returnTo;\n\n    const responseType = opts.authorizationParams.response_type as string;\n    const usePKCE = responseType.includes('code');\n    if (usePKCE) {\n      debug('response_type includes code, the authorization request will use PKCE');\n      stateValue.code_verifier = client.generateRandomCodeVerifier();\n    }\n\n    const validResponseTypes = ['id_token', 'code id_token', 'code'];\n    if (!validResponseTypes.includes(responseType)) {\n      throw new Error(`response_type should be one of ${validResponseTypes.join(', ')}`);\n    }\n    if (!/\\bopenid\\b/.test(opts.authorizationParams.scope as string)) {\n      throw new Error('scope should contain \"openid\"');\n    }\n\n    const authVerification: AuthVerification = {\n      nonce: client.generateRandomNonce(),\n      state: encodeState(stateValue)\n    };\n\n    if (opts.authorizationParams.max_age) {\n      authVerification.max_age = opts.authorizationParams.max_age;\n    }\n\n    const authParams = { ...opts.authorizationParams, ...authVerification };\n\n    if (usePKCE) {\n      authVerification.code_verifier = client.generateRandomCodeVerifier();\n      authParams.code_challenge_method = 'S256';\n      authParams.code_challenge = await client.calculateCodeChallenge(authVerification.code_verifier);\n    }\n\n    if (responseType !== config.authorizationParams.response_type) {\n      authVerification.response_type = responseType;\n    }\n\n    await transientHandler.save(config.transactionCookie.name, req, res, {\n      sameSite: authParams.response_mode === 'form_post' ? 'none' : config.transactionCookie.sameSite,\n      value: JSON.stringify(authVerification)\n    });\n\n    const authorizationUrl = await client.authorizationUrl(authParams);\n    debug('redirecting to %s', authorizationUrl);\n\n    res.redirect(authorizationUrl);\n  };\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,aAAA,QAAA,eAAA;AAGA,MAAA;AACA,MAAA,UAAA,QAAA,eAAA;AAIA,MAAM,QAAQ,CAAA,GAAA,QAAA,OAAW,EAAC;AAE1B,SAAS,eAAe,MAAc;IACpC,OAAO,CAAA,GAAA,WAAA,OAAO,EAAC,OAAO,OAAO,EAAE,OAAO,MAAM,CAAC,QAAQ;AACvD;AAYA,SAAwB,oBACtB,SAAoB,EACpB,SAAoB,EACpB,gBAAgC;IAEhC,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,IAAM;IACxE,OAAO,OAAO,KAAK,KAAK,UAAU,CAAA,CAAE;QAClC,MAAM,SAAS,MAAM,YAAY;QACjC,MAAM,SAAS,MAAM,UAAU;QAC/B,MAAM,WAAW,QAAQ,QAAQ,IAAI,OAAO,OAAO;QAEnD,MAAM,OAAI,OAAA,MAAA,CAAA;YACR;YACA,eAAe,OAAO,aAAa;QAAA,GAChC;QAGL,iFAAiF;QACjF,KAAK,mBAAmB,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA;YACtB,cAAc,eAAe;QAAO,GACjC,OAAO,mBAAmB,GACzB,KAAK,mBAAmB,IAAI,CAAA;QAGlC,MAAM,aAAa,MAAM,KAAK,aAAa,CAAC;QAC5C,IAAI,OAAO,eAAe,UAAU;YAClC,MAAM,IAAI,MAAM;;QAElB,WAAW,KAAK,GAAG,OAAO,mBAAmB;QAC7C,WAAW,QAAQ,GAAG,WAAW,QAAQ,IAAI,KAAK,QAAQ;QAE1D,MAAM,eAAe,KAAK,mBAAmB,CAAC,aAAuB;QACrE,MAAM,UAAU,aAAa,QAAQ,CAAC;QACtC,IAAI,SAAS;YACX,MAAM;YACN,WAAW,aAAa,GAAG,OAAO,0BAA0B;;QAG9D,MAAM,qBAAqB;YAAC;YAAY;YAAiB;SAAO;QAChE,IAAI,CAAC,mBAAmB,QAAQ,CAAC,eAAe;YAC9C,MAAM,IAAI,MAAM,CAAA,+BAAA,EAAkC,mBAAmB,IAAI,CAAC,MAAK,CAAE;;QAEnF,IAAI,CAAC,aAAa,IAAI,CAAC,KAAK,mBAAmB,CAAC,KAAe,GAAG;YAChE,MAAM,IAAI,MAAM;;QAGlB,MAAM,mBAAqC;YACzC,OAAO,OAAO,mBAAmB;YACjC,OAAO,CAAA,GAAA,WAAA,WAAW,EAAC;;QAGrB,IAAI,KAAK,mBAAmB,CAAC,OAAO,EAAE;YACpC,iBAAiB,OAAO,GAAG,KAAK,mBAAmB,CAAC,OAAO;;QAG7D,MAAM,aAAU,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAQ,KAAK,mBAAmB,GAAK;QAErD,IAAI,SAAS;YACX,iBAAiB,aAAa,GAAG,OAAO,0BAA0B;YAClE,WAAW,qBAAqB,GAAG;YACnC,WAAW,cAAc,GAAG,MAAM,OAAO,sBAAsB,CAAC,iBAAiB,aAAa;;QAGhG,IAAI,iBAAiB,OAAO,mBAAmB,CAAC,aAAa,EAAE;YAC7D,iBAAiB,aAAa,GAAG;;QAGnC,MAAM,iBAAiB,IAAI,CAAC,OAAO,iBAAiB,CAAC,IAAI,EAAE,KAAK,KAAK;YACnE,UAAU,WAAW,aAAa,KAAK,cAAc,SAAS,OAAO,iBAAiB,CAAC,QAAQ;YAC/F,OAAO,KAAK,SAAS,CAAC;;QAGxB,MAAM,mBAAmB,MAAM,OAAO,gBAAgB,CAAC;QACvD,MAAM,qBAAqB;QAE3B,IAAI,QAAQ,CAAC;IACf;AACF;AA7EA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 947, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 951, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/handlers/logout.ts"],"sourcesContent":["import urlJoin from 'url-join';\nimport createDebug from '../utils/debug';\nimport { GetConfig, LogoutOptions } from '../config';\nimport { SessionCache } from '../session-cache';\nimport { Auth0Request, Auth0Response } from '../http';\nimport { GetClient } from '../client/abstract-client';\n\nconst debug = createDebug('logout');\n\nexport type HandleLogout = (req: Auth0Request, res: Auth0Response, options?: LogoutOptions) => Promise<void>;\n\nexport default function logoutHandlerFactory(\n  getConfig: GetConfig,\n  getClient: GetClient,\n  sessionCache: SessionCache\n): HandleLogout {\n  const getConfigFn = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  return async (req, res, options = {}) => {\n    const config = await getConfigFn(req);\n    const client = await getClient(config);\n    let returnURL = options.returnTo || config.routes.postLogoutRedirect;\n    debug('logout() with return url: %s', returnURL);\n\n    try {\n      new URL(returnURL);\n    } catch (_) {\n      returnURL = urlJoin(config.baseURL, returnURL);\n    }\n\n    const isAuthenticated = await sessionCache.isAuthenticated(req.req, res.res);\n    if (!isAuthenticated) {\n      debug('end-user already logged out, redirecting to %s', returnURL);\n      res.redirect(returnURL);\n      return;\n    }\n\n    const idToken = await sessionCache.getIdToken(req.req, res.res);\n    await sessionCache.delete(req.req, res.res);\n\n    if (!config.idpLogout) {\n      debug('performing a local only logout, redirecting to %s', returnURL);\n      res.redirect(returnURL);\n      return;\n    }\n\n    returnURL = await client.endSessionUrl({\n      ...options.logoutParams,\n      post_logout_redirect_uri: returnURL,\n      id_token_hint: idToken\n    });\n\n    debug('logging out of identity provider, redirecting to %s', returnURL);\n    res.redirect(returnURL);\n  };\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,aAAA,QAAA,eAAA;AACA,MAAA,UAAA,QAAA,eAAA;AAMA,MAAM,QAAQ,CAAA,GAAA,QAAA,OAAW,EAAC;AAI1B,SAAwB,qBACtB,SAAoB,EACpB,SAAoB,EACpB,YAA0B;IAE1B,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,IAAM;IACxE,OAAO,OAAO,KAAK,KAAK,UAAU,CAAA,CAAE;QAClC,MAAM,SAAS,MAAM,YAAY;QACjC,MAAM,SAAS,MAAM,UAAU;QAC/B,IAAI,YAAY,QAAQ,QAAQ,IAAI,OAAO,MAAM,CAAC,kBAAkB;QACpE,MAAM,gCAAgC;QAEtC,IAAI;YACF,IAAI,IAAI;UACR,OAAO,GAAG;YACV,YAAY,CAAA,GAAA,WAAA,OAAO,EAAC,OAAO,OAAO,EAAE;;QAGtC,MAAM,kBAAkB,MAAM,aAAa,eAAe,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG;QAC3E,IAAI,CAAC,iBAAiB;YACpB,MAAM,kDAAkD;YACxD,IAAI,QAAQ,CAAC;YACb;;QAGF,MAAM,UAAU,MAAM,aAAa,UAAU,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG;QAC9D,MAAM,aAAa,MAAM,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG;QAE1C,IAAI,CAAC,OAAO,SAAS,EAAE;YACrB,MAAM,qDAAqD;YAC3D,IAAI,QAAQ,CAAC;YACb;;QAGF,YAAY,MAAM,OAAO,aAAa,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACjC,QAAQ,YAAY,GAAA;YACvB,0BAA0B;YAC1B,eAAe;QAAO;QAGxB,MAAM,uDAAuD;QAC7D,IAAI,QAAQ,CAAC;IACf;AACF;AA3CA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/handlers/callback.ts"],"sourcesContent":["import urlJoin from 'url-join';\nimport { AuthorizationParameters, GetConfig, Config } from '../config';\nimport TransientStore from '../transient-store';\nimport { decodeState } from '../utils/encoding';\nimport { SessionCache } from '../session-cache';\nimport { MalformedStateCookieError, MissingStateCookieError, MissingStateParamError } from '../utils/errors';\nimport { Auth0Request, Auth0Response } from '../http';\nimport { GetClient } from '../client/abstract-client';\nimport type { AuthVerification } from './login';\n\nfunction getRedirectUri(config: Config): string {\n  return urlJoin(config.baseURL, config.routes.callback);\n}\n\nexport type AfterCallback = (session: any, state?: Record<string, any>) => Promise<any> | any | undefined;\n\nexport type CallbackOptions = {\n  afterCallback?: AfterCallback;\n\n  redirectUri?: string;\n\n  authorizationParams?: Partial<AuthorizationParameters>;\n};\n\nexport type HandleCallback = (req: Auth0Request, res: Auth0Response, options?: CallbackOptions) => Promise<void>;\n\nexport default function callbackHandlerFactory(\n  getConfig: GetConfig,\n  getClient: GetClient,\n  sessionCache: SessionCache,\n  transientCookieHandler: TransientStore\n): HandleCallback {\n  const getConfigFn = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  return async (req, res, options) => {\n    const config = await getConfigFn(req);\n    const client = await getClient(config);\n    const redirectUri = options?.redirectUri || getRedirectUri(config);\n\n    let tokenResponse;\n\n    let authVerification: AuthVerification;\n    const cookie = await transientCookieHandler.read(config.transactionCookie.name, req, res);\n\n    if (!cookie) {\n      throw new MissingStateCookieError();\n    }\n\n    try {\n      authVerification = JSON.parse(cookie);\n    } catch (_) {\n      throw new MalformedStateCookieError();\n    }\n\n    const {\n      max_age,\n      code_verifier,\n      nonce,\n      state: expectedState,\n      response_type = config.authorizationParams.response_type\n    } = authVerification;\n\n    let callbackParams: URLSearchParams;\n    try {\n      callbackParams = await client.callbackParams(req, expectedState);\n    } catch (err) {\n      err.status = 400;\n      err.statusCode = 400;\n      err.openIdState = decodeState(expectedState);\n      throw err;\n    }\n\n    if (!callbackParams.get('state')) {\n      throw new MissingStateParamError();\n    }\n\n    try {\n      tokenResponse = await client.callback(\n        redirectUri,\n        callbackParams,\n        {\n          max_age: max_age !== undefined ? +max_age : undefined,\n          code_verifier,\n          nonce,\n          state: expectedState,\n          response_type\n        },\n        { exchangeBody: options?.authorizationParams }\n      );\n    } catch (err) {\n      err.status = 400;\n      err.statusCode = 400;\n      err.openIdState = decodeState(expectedState);\n      throw err;\n    }\n\n    const openidState: { returnTo?: string } = decodeState(expectedState as string)!;\n    let session = await sessionCache.fromTokenEndpointResponse(req, res, tokenResponse);\n\n    if (options?.afterCallback) {\n      session = await options.afterCallback(session, openidState);\n    }\n\n    if (session) {\n      await sessionCache.create(req.req, res.res, session);\n    }\n\n    res.redirect(openidState.returnTo || config.baseURL);\n  };\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,aAAA,QAAA,eAAA;AAGA,MAAA;AAEA,MAAA;AAKA,SAAS,eAAe,MAAc;IACpC,OAAO,CAAA,GAAA,WAAA,OAAO,EAAC,OAAO,OAAO,EAAE,OAAO,MAAM,CAAC,QAAQ;AACvD;AAcA,SAAwB,uBACtB,SAAoB,EACpB,SAAoB,EACpB,YAA0B,EAC1B,sBAAsC;IAEtC,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,IAAM;IACxE,OAAO,OAAO,KAAK,KAAK;QACtB,MAAM,SAAS,MAAM,YAAY;QACjC,MAAM,SAAS,MAAM,UAAU;QAC/B,MAAM,cAAc,CAAA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,WAAW,KAAI,eAAe;QAE3D,IAAI;QAEJ,IAAI;QACJ,MAAM,SAAS,MAAM,uBAAuB,IAAI,CAAC,OAAO,iBAAiB,CAAC,IAAI,EAAE,KAAK;QAErF,IAAI,CAAC,QAAQ;YACX,MAAM,IAAI,SAAA,uBAAuB;;QAGnC,IAAI;YACF,mBAAmB,KAAK,KAAK,CAAC;UAC9B,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,yBAAyB;;QAGrC,MAAM,EACJ,OAAO,EACP,aAAa,EACb,KAAK,EACL,OAAO,aAAa,EACpB,gBAAgB,OAAO,mBAAmB,CAAC,aAAa,EACzD,GAAG;QAEJ,IAAI;QACJ,IAAI;YACF,iBAAiB,MAAM,OAAO,cAAc,CAAC,KAAK;UAClD,OAAO,KAAK;YACZ,IAAI,MAAM,GAAG;YACb,IAAI,UAAU,GAAG;YACjB,IAAI,WAAW,GAAG,CAAA,GAAA,WAAA,WAAW,EAAC;YAC9B,MAAM;;QAGR,IAAI,CAAC,eAAe,GAAG,CAAC,UAAU;YAChC,MAAM,IAAI,SAAA,sBAAsB;;QAGlC,IAAI;YACF,gBAAgB,MAAM,OAAO,QAAQ,CACnC,aACA,gBACA;gBACE,SAAS,YAAY,YAAY,CAAC,UAAU;gBAC5C;gBACA;gBACA,OAAO;gBACP;eAEF;gBAAE,cAAc,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,mBAAmB;YAAA;UAE9C,OAAO,KAAK;YACZ,IAAI,MAAM,GAAG;YACb,IAAI,UAAU,GAAG;YACjB,IAAI,WAAW,GAAG,CAAA,GAAA,WAAA,WAAW,EAAC;YAC9B,MAAM;;QAGR,MAAM,cAAqC,CAAA,GAAA,WAAA,WAAW,EAAC;QACvD,IAAI,UAAU,MAAM,aAAa,yBAAyB,CAAC,KAAK,KAAK;QAErE,IAAI,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,aAAa,EAAE;YAC1B,UAAU,MAAM,QAAQ,aAAa,CAAC,SAAS;;QAGjD,IAAI,SAAS;YACX,MAAM,aAAa,MAAM,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG,EAAE;;QAG9C,IAAI,QAAQ,CAAC,YAAY,QAAQ,IAAI,OAAO,OAAO;IACrD;AACF;AAlFA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1066, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1070, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/utils/logout-token-verifier.ts"],"sourcesContent":["import {\n  createRemoteJWKSet,\n  FlattenedJWSInput,\n  GetKeyFunction,\n  JWSHeaderParameters,\n  jwtVerify,\n  JWTPayload\n} from 'jose';\nimport { Config } from '../config';\nimport { IssuerMetadata } from '../client/abstract-client';\n\ntype GetKeyFn = GetKeyFunction<JWSHeaderParameters, FlattenedJWSInput>;\n\nexport type VerifyLogoutToken = (\n  logoutToken: string,\n  config: Config,\n  issuerMetadata: IssuerMetadata\n) => Promise<JWTPayload>;\n\nexport default function getLogoutTokenVerifier(): VerifyLogoutToken {\n  let remoteJwkSet: GetKeyFn;\n\n  return async (logoutToken: string, config: Config, issuerMetadata: IssuerMetadata) => {\n    let keyInput: Uint8Array | GetKeyFn;\n    if (config.idTokenSigningAlg === 'RS256') {\n      if (!remoteJwkSet) {\n        remoteJwkSet = createRemoteJWKSet(new URL(issuerMetadata.jwks_uri!));\n      }\n      keyInput = remoteJwkSet;\n    } else {\n      keyInput = new TextEncoder().encode(config.clientSecret as string);\n    }\n    const { payload } = await jwtVerify(logoutToken, keyInput as Uint8Array, {\n      issuer: issuerMetadata.issuer,\n      audience: config.clientID,\n      algorithms: [config.idTokenSigningAlg],\n      requiredClaims: ['iat']\n    });\n\n    if (!('sid' in payload) && !('sub' in payload)) {\n      throw new Error('either \"sid\" or \"sub\" (or both) claims must be present');\n    }\n\n    if ('nonce' in payload) {\n      throw new Error('\"nonce\" claim is prohibited');\n    }\n\n    if (!('events' in payload)) {\n      throw new Error('\"events\" claim is missing');\n    }\n\n    if (typeof payload.events !== 'object' || payload.events === null) {\n      throw new Error('\"events\" claim must be an object');\n    }\n\n    if (!('http://schemas.openid.net/event/backchannel-logout' in (payload as { events?: any }).events)) {\n      throw new Error('\"http://schemas.openid.net/event/backchannel-logout\" member is missing in the \"events\" claim');\n    }\n\n    if (\n      typeof (payload as { events?: any }).events['http://schemas.openid.net/event/backchannel-logout'] !== 'object'\n    ) {\n      throw new Error(\n        '\"http://schemas.openid.net/event/backchannel-logout\" member in the \"events\" claim must be an object'\n      );\n    }\n\n    return payload;\n  };\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAmBA,SAAwB;IACtB,IAAI;IAEJ,OAAO,OAAO,aAAqB,QAAgB;QACjD,IAAI;QACJ,IAAI,OAAO,iBAAiB,KAAK,SAAS;YACxC,IAAI,CAAC,cAAc;gBACjB,eAAe,CAAA,GAAA,OAAA,kBAAkB,EAAC,IAAI,IAAI,eAAe,QAAS;;YAEpE,WAAW;eACN;YACL,WAAW,IAAI,cAAc,MAAM,CAAC,OAAO,YAAsB;;QAEnE,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,OAAA,SAAS,EAAC,aAAa,UAAwB;YACvE,QAAQ,eAAe,MAAM;YAC7B,UAAU,OAAO,QAAQ;YACzB,YAAY;gBAAC,OAAO,iBAAiB;aAAC;YACtC,gBAAgB;gBAAC;aAAM;;QAGzB,IAAI,CAAC,CAAC,SAAS,OAAO,KAAK,CAAC,CAAC,SAAS,OAAO,GAAG;YAC9C,MAAM,IAAI,MAAM;;QAGlB,IAAI,WAAW,SAAS;YACtB,MAAM,IAAI,MAAM;;QAGlB,IAAI,CAAC,CAAC,YAAY,OAAO,GAAG;YAC1B,MAAM,IAAI,MAAM;;QAGlB,IAAI,OAAO,QAAQ,MAAM,KAAK,YAAY,QAAQ,MAAM,KAAK,MAAM;YACjE,MAAM,IAAI,MAAM;;QAGlB,IAAI,CAAC,CAAC,wDAAyD,QAA6B,MAAM,GAAG;YACnG,MAAM,IAAI,MAAM;;QAGlB,IACE,OAAQ,QAA6B,MAAM,CAAC,qDAAqD,KAAK,UACtG;YACA,MAAM,IAAI,MACR;;QAIJ,OAAO;IACT;AACF;AAlDA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1119, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1123, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/handlers/backchannel-logout.ts"],"sourcesContent":["import { Auth0Request, Auth0Response } from '../http';\nimport { Config, GetConfig } from '../config';\nimport { GetClient } from '../client/abstract-client';\nimport getLogoutTokenVerifier from '../utils/logout-token-verifier';\nimport { BackchannelLogoutError } from '../utils/errors';\nimport { JWTPayload } from 'jose';\n\nconst getStore = (config: Config) => {\n  const {\n    session: { store },\n    backchannelLogout\n  } = config;\n  return typeof backchannelLogout === 'boolean' ? store! : backchannelLogout.store;\n};\n\nexport type HandleBackchannelLogout = (req: Auth0Request, res: Auth0Response) => Promise<void>;\n\nexport default function backchannelLogoutHandlerFactory(\n  getConfig: GetConfig,\n  getClient: GetClient\n): HandleBackchannelLogout {\n  const getConfigFn = typeof getConfig === 'function' ? getConfig : () => getConfig;\n  const verifyLogoutToken = getLogoutTokenVerifier();\n  return async (req, res) => {\n    const config = await getConfigFn(req);\n    const client = await getClient(config);\n    res.setHeader('cache-control', 'no-store');\n    const body = new URLSearchParams(await req.getBody());\n    const logoutToken = body.get('logout_token');\n    if (!logoutToken) {\n      throw new BackchannelLogoutError('invalid_request', 'Missing Logout Token');\n    }\n    let token: JWTPayload;\n    try {\n      token = await verifyLogoutToken(logoutToken, config, await client.getIssuerMetadata());\n    } catch (e) {\n      throw new BackchannelLogoutError('invalid_request', e.message);\n    }\n    const {\n      clientID,\n      session: { absoluteDuration, rolling: rollingEnabled, rollingDuration }\n    } = config;\n    const store = getStore(config);\n    const maxAge =\n      (rollingEnabled\n        ? Math.min(absoluteDuration as number, rollingDuration as number)\n        : (absoluteDuration as number)) * 1000;\n    const now = (Date.now() / 1000) | 0;\n    const payload = {\n      header: { iat: now, uat: now, exp: now + maxAge, maxAge },\n      data: {}\n    };\n    try {\n      const { sid, sub } = token;\n      await Promise.all([\n        sid && store.set(`sid|${clientID}|${sid}`, payload),\n        sub && store.set(`sub|${clientID}|${sub}`, payload)\n      ]);\n    } catch (e) {\n      throw new BackchannelLogoutError('application_error', e.message);\n    }\n    res.send204();\n  };\n}\n\nexport type IsLoggedOut = (user: { [key: string]: any }, config: Config) => Promise<boolean>;\n\nexport const isLoggedOut: IsLoggedOut = async (user, config) => {\n  const { clientID } = config;\n  const store = getStore(config);\n  const { sid, sub } = user;\n  const [logoutSid, logoutSub] = await Promise.all([\n    store.get(`sid|${clientID}|${sid}`),\n    store.get(`sub|${clientID}|${sub}`)\n  ]);\n  return !!(logoutSid || logoutSub);\n};\n\nexport type DeleteSub = (sub: string, config: Config) => Promise<void>;\n\nexport const deleteSub: DeleteSub = async (sub, config) => {\n  const { clientID } = config;\n  const store = getStore(config);\n  await store.delete(`sub|${clientID}|${sub}`);\n};\n"],"names":[],"mappings":";;;;;;AAGA,MAAA,0BAAA,QAAA,eAAA;AACA,MAAA;AAGA,MAAM,WAAW,CAAC;IAChB,MAAM,EACJ,SAAS,EAAE,KAAK,EAAE,EAClB,iBAAiB,EAClB,GAAG;IACJ,OAAO,OAAO,sBAAsB,YAAY,QAAS,kBAAkB,KAAK;AAClF;AAIA,SAAwB,gCACtB,SAAoB,EACpB,SAAoB;IAEpB,MAAM,cAAc,OAAO,cAAc,aAAa,YAAY,IAAM;IACxE,MAAM,oBAAoB,CAAA,GAAA,wBAAA,OAAsB;IAChD,OAAO,OAAO,KAAK;QACjB,MAAM,SAAS,MAAM,YAAY;QACjC,MAAM,SAAS,MAAM,UAAU;QAC/B,IAAI,SAAS,CAAC,iBAAiB;QAC/B,MAAM,OAAO,IAAI,gBAAgB,MAAM,IAAI,OAAO;QAClD,MAAM,cAAc,KAAK,GAAG,CAAC;QAC7B,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,SAAA,sBAAsB,CAAC,mBAAmB;;QAEtD,IAAI;QACJ,IAAI;YACF,QAAQ,MAAM,kBAAkB,aAAa,QAAQ,MAAM,OAAO,iBAAiB;UACnF,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,sBAAsB,CAAC,mBAAmB,EAAE,OAAO;;QAE/D,MAAM,EACJ,QAAQ,EACR,SAAS,EAAE,gBAAgB,EAAE,SAAS,cAAc,EAAE,eAAe,EAAE,EACxE,GAAG;QACJ,MAAM,QAAQ,SAAS;QACvB,MAAM,SACJ,CAAC,iBACG,KAAK,GAAG,CAAC,kBAA4B,mBACpC,gBAA2B,IAAI;QACtC,MAAM,MAAM,AAAC,KAAK,GAAG,KAAK,OAAQ;QAClC,MAAM,UAAU;YACd,QAAQ;gBAAE,KAAK;gBAAK,KAAK;gBAAK,KAAK,MAAM;gBAAQ;YAAM;YACvD,MAAM,CAAA;;QAER,IAAI;YACF,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;YACrB,MAAM,QAAQ,GAAG,CAAC;gBAChB,OAAO,MAAM,GAAG,CAAC,CAAA,IAAA,EAAO,SAAQ,CAAA,EAAI,IAAG,CAAE,EAAE;gBAC3C,OAAO,MAAM,GAAG,CAAC,CAAA,IAAA,EAAO,SAAQ,CAAA,EAAI,IAAG,CAAE,EAAE;aAC5C;UACD,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,sBAAsB,CAAC,qBAAqB,EAAE,OAAO;;QAEjE,IAAI,OAAO;IACb;AACF;AA9CA,QAAA,OAAA,GAAA;AAkDO,MAAM,cAA2B,OAAO,MAAM;IACnD,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,MAAM,QAAQ,SAAS;IACvB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG;IACrB,MAAM,CAAC,WAAW,UAAU,GAAG,MAAM,QAAQ,GAAG,CAAC;QAC/C,MAAM,GAAG,CAAC,CAAA,IAAA,EAAO,SAAQ,CAAA,EAAI,IAAG,CAAE;QAClC,MAAM,GAAG,CAAC,CAAA,IAAA,EAAO,SAAQ,CAAA,EAAI,IAAG,CAAE;KACnC;IACD,OAAO,CAAC,CAAC,CAAC,aAAa,SAAS;AAClC;AATa,QAAA,WAAW,GAAA;AAajB,MAAM,YAAuB,OAAO,KAAK;IAC9C,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,MAAM,QAAQ,SAAS;IACvB,MAAM,MAAM,MAAM,CAAC,CAAA,IAAA,EAAO,SAAQ,CAAA,EAAI,IAAG,CAAE;AAC7C;AAJa,QAAA,SAAS,GAAA"}},
    {"offset": {"line": 1196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1200, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/client/abstract-client.ts"],"sourcesContent":["import { Config } from '../config';\nimport { Auth0Request } from '../http';\n\nexport type Telemetry = {\n  name: string;\n  version: string;\n};\n\nexport interface CallbackParamsType {\n  access_token?: string;\n  code?: string;\n  error?: string;\n  error_description?: string;\n  error_uri?: string;\n  expires_in?: string;\n  id_token?: string;\n  state?: string;\n  token_type?: string;\n  session_state?: string;\n  response?: string;\n\n  [key: string]: any;\n}\n\nexport interface CallbackExtras {\n  exchangeBody?: Record<string, any>;\n  clientAssertionPayload?: Record<string, any>;\n}\n\nexport interface OpenIDCallbackChecks {\n  max_age?: number;\n  nonce?: string;\n  response_type: string;\n  state?: string;\n  code_verifier?: string;\n}\n\nexport interface TokenEndpointResponse {\n  access_token?: string;\n  token_type?: string;\n  id_token?: string;\n  refresh_token?: string;\n  scope?: string;\n  expires_in?: number;\n  [key: string]: unknown;\n}\n\nexport interface EndSessionParameters {\n  id_token_hint?: string;\n  post_logout_redirect_uri: string;\n  state?: string;\n  client_id?: string;\n  logout_hint?: string;\n\n  [key: string]: any;\n}\n\nexport type ClientAuthMethod = 'client_secret_basic' | 'client_secret_post' | 'private_key_jwt' | 'none';\n\nexport interface AuthorizationParameters {\n  acr_values?: string;\n  audience?: string;\n  claims_locales?: string;\n  client_id?: string;\n  code_challenge_method?: string;\n  code_challenge?: string;\n  display?: string;\n  id_token_hint?: string;\n  login_hint?: string;\n  max_age?: number;\n  nonce?: string;\n  prompt?: string;\n  redirect_uri?: string;\n  registration?: string;\n  request_uri?: string;\n  request?: string;\n  resource?: string | string[];\n  response_mode?: string;\n  response_type?: string;\n  scope?: string;\n  state?: string;\n  ui_locales?: string;\n\n  [key: string]: unknown;\n}\n\nexport type IssuerMetadata = {\n  issuer: string;\n  jwks_uri?: string;\n};\n\nexport abstract class AbstractClient {\n  constructor(protected config: Config, protected telemetry: Telemetry) {}\n  abstract authorizationUrl(parameters: Record<string, unknown>): Promise<string>;\n  abstract callbackParams(req: Auth0Request, expectedState: string): Promise<URLSearchParams>;\n  abstract callback(\n    redirectUri: string,\n    parameters: URLSearchParams,\n    checks: OpenIDCallbackChecks,\n    extras: CallbackExtras\n  ): Promise<TokenEndpointResponse>;\n  abstract endSessionUrl(parameters: EndSessionParameters): Promise<string>;\n  abstract userinfo(accessToken: string): Promise<Record<string, unknown>>;\n  abstract refresh(\n    refreshToken: string,\n    extras: { exchangeBody?: Record<string, any> }\n  ): Promise<TokenEndpointResponse>;\n  abstract generateRandomCodeVerifier(): string;\n  abstract generateRandomNonce(): string;\n  abstract calculateCodeChallenge(codeVerifier: string): Promise<string> | string;\n  abstract getIssuerMetadata(): Promise<IssuerMetadata>;\n}\n\nexport type GetClient = (config: Config) => Promise<AbstractClient>;\n"],"names":[],"mappings":";;;;;AA2FA,MAAsB;IACpB,YAAsB,MAAc,EAAY,SAAoB,CAAA;QAA9C,IAAA,CAAA,MAAM,GAAN;QAA0B,IAAA,CAAA,SAAS,GAAT;IAAuB;;AADzE,QAAA,cAAA,GAAA"}},
    {"offset": {"line": 1212, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/index.ts"],"sourcesContent":["export {\n  MissingStateParamError,\n  MissingStateCookieError,\n  MalformedStateCookieError,\n  IdentityProviderError,\n  ApplicationError\n} from './utils/errors';\nexport { StatelessSession } from './session/stateless-session';\nexport { AbstractSession, SessionPayload } from './session/abstract-session';\nexport { StatefulSession, SessionStore } from './session/stateful-session';\nexport { default as TransientStore } from './transient-store';\nexport {\n  Config,\n  GetConfig,\n  SessionConfig,\n  CookieConfig,\n  LoginOptions,\n  LogoutOptions,\n  AuthorizationParameters\n} from './config';\nexport { get as getConfig, ConfigParameters, DeepPartial } from './get-config';\nexport { default as loginHandler, HandleLogin } from './handlers/login';\nexport { default as logoutHandler, HandleLogout } from './handlers/logout';\nexport { default as callbackHandler, CallbackOptions, AfterCallback, HandleCallback } from './handlers/callback';\nexport {\n  default as backchannelLogoutHandler,\n  HandleBackchannelLogout,\n  isLoggedOut,\n  IsLoggedOut,\n  DeleteSub,\n  deleteSub\n} from './handlers/backchannel-logout';\nexport { TokenEndpointResponse, AbstractClient, Telemetry } from './client/abstract-client';\nexport { SessionCache } from './session-cache';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,0BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,sBAAsB;IAAA;AAAA;AACtB,OAAA,cAAA,CAAA,SAAA,2BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,uBAAuB;IAAA;AAAA;AACvB,OAAA,cAAA,CAAA,SAAA,6BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,yBAAyB;IAAA;AAAA;AACzB,OAAA,cAAA,CAAA,SAAA,yBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,qBAAqB;IAAA;AAAA;AACrB,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,gBAAgB;IAAA;AAAA;AAElB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,oBAAA,gBAAgB;IAAA;AAAA;AACzB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,mBAAA,eAAe;IAAA;AAAA;AACxB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,mBAAA,eAAe;IAAA;AAAA;AACxB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,mBAAA,OAAO;IAAA;AAAA;AAUhB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,aAAA,GAAG;IAAA;AAAA;AACZ,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,SAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,iBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,UAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,YAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,4BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,sBAAA,OAAO;IAAA;AAAA;AAEP,OAAA,cAAA,CAAA,SAAA,eAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,qBAAA,WAAW;IAAA;AAAA;AAGX,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,qBAAA,SAAS;IAAA;AAAA;AAEX,IAAA;AAAgC,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,kBAAA,cAAc;IAAA;AAAA"}},
    {"offset": {"line": 1339, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/assert.ts"],"sourcesContent":["import { GetServerSidePropsContext } from 'next';\n\nexport const assertReqRes = (req: unknown, res: unknown): void => {\n  if (!req) {\n    throw new Error('Request is not available');\n  }\n  if (!res) {\n    throw new Error('Response is not available');\n  }\n};\n\nexport const assertCtx = ({ req, res }: GetServerSidePropsContext<any>): void => {\n  assertReqRes(req, res);\n};\n"],"names":[],"mappings":";;;;;AAEO,MAAM,eAAe,CAAC,KAAc;IACzC,IAAI,CAAC,KAAK;QACR,MAAM,IAAI,MAAM;;IAElB,IAAI,CAAC,KAAK;QACR,MAAM,IAAI,MAAM;;AAEpB;AAPa,QAAA,YAAY,GAAA;AASlB,MAAM,YAAY,CAAC,EAAE,GAAG,EAAE,GAAG,EAAkC;IACpE,CAAA,GAAA,QAAA,YAAY,EAAC,KAAK;AACpB;AAFa,QAAA,SAAS,GAAA"}},
    {"offset": {"line": 1361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1365, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/errors.ts"],"sourcesContent":["/**\n * @ignore\n */\nexport function appendCause(errorMessage: string, cause?: Error): string {\n  if (!cause) return errorMessage;\n  const separator = errorMessage.endsWith('.') ? '' : '.';\n  return `${errorMessage}${separator} CAUSE: ${cause.message}`;\n}\n\ntype AuthErrorOptions = {\n  code: string;\n  message: string;\n  name: string;\n  cause?: Error;\n  status?: number;\n};\n\n/**\n * The base class for all SDK errors.\n *\n * Because part of the error message can come from the OpenID Connect `error` query parameter we\n * do some basic escaping which makes sure the default error handler is safe from XSS.\n *\n * **IMPORTANT** If you write your own error handler, you should **not** render the error\n * without using a templating engine that will properly escape it for other HTML contexts first.\n *\n * Note that the error message of the {@link AuthError.cause | underlying error} is **not** escaped\n * in any way, so do **not** render it without escaping it first!\n *\n * @category Server\n */\nexport abstract class AuthError extends Error {\n  /**\n   * A machine-readable error code that remains stable within a major version of the SDK. You\n   * should rely on this error code to handle errors. In contrast, the error message is not part of\n   * the API and can change anytime. Do **not** parse or otherwise rely on the error message to\n   * handle errors.\n   */\n  public readonly code: string;\n\n  /**\n   * The error class name.\n   */\n  public readonly name: string;\n\n  /**\n   * The underlying error, if any.\n   *\n   * **IMPORTANT** When this error is from the Identity Provider ({@link IdentityProviderError}) it can contain user\n   * input and is only escaped using basic escaping for putting untrusted data directly into the HTML body.\n   *\n   * You should **not** render this error without using a templating engine that will properly escape it for other\n   * HTML contexts first.\n   */\n  public readonly cause?: Error;\n\n  /**\n   * The HTTP status code, if any.\n   */\n  public readonly status?: number;\n\n  constructor(options: AuthErrorOptions) {\n    /* c8 ignore next */\n    super(appendCause(options.message, options.cause));\n    this.code = options.code;\n    this.name = options.name;\n    this.cause = options.cause;\n    this.status = options.status;\n  }\n}\n\n/**\n * Error codes for {@link AccessTokenError}.\n *\n * @category Server\n */\nexport enum AccessTokenErrorCode {\n  MISSING_SESSION = 'ERR_MISSING_SESSION',\n  MISSING_ACCESS_TOKEN = 'ERR_MISSING_ACCESS_TOKEN',\n  MISSING_REFRESH_TOKEN = 'ERR_MISSING_REFRESH_TOKEN',\n  EXPIRED_ACCESS_TOKEN = 'ERR_EXPIRED_ACCESS_TOKEN',\n  INSUFFICIENT_SCOPE = 'ERR_INSUFFICIENT_SCOPE',\n  FAILED_REFRESH_GRANT = 'ERR_FAILED_REFRESH_GRANT'\n}\n\n/**\n * The error thrown by {@link GetAccessToken}.\n *\n * @see the {@link AuthError.code | code property} contains a machine-readable error code that\n * remains stable within a major version of the SDK. You should rely on this error code to handle\n * errors. In contrast, the error message is not part of the API and can change anytime. Do **not**\n * parse or otherwise rely on the error message to handle errors.\n *\n * @see {@link AccessTokenErrorCode} for the list of all possible error codes.\n * @category Server\n */\nexport class AccessTokenError extends AuthError {\n  constructor(code: AccessTokenErrorCode, message: string, cause?: Error) {\n    /* c8 ignore next */\n    super({ code: code, message: message, name: 'AccessTokenError', cause });\n\n    // Capturing stack trace, excluding constructor call from it.\n    Error.captureStackTrace(this, this.constructor);\n    Object.setPrototypeOf(this, AccessTokenError.prototype);\n  }\n}\n\n/**\n * @ignore\n */\ninterface HttpError extends Error {\n  status: number;\n  statusCode: number;\n}\n\n/**\n * @ignore\n */\nexport type HandlerErrorCause = Error | AuthError | HttpError;\n\ntype HandlerErrorOptions = {\n  code: string;\n  message: string;\n  name: string;\n  cause: HandlerErrorCause;\n};\n\n/**\n * The base class for errors thrown by API route handlers. It extends {@link AuthError}.\n *\n * Because part of the error message can come from the OpenID Connect `error` query parameter we\n * do some basic escaping which makes sure the default error handler is safe from XSS.\n *\n * **IMPORTANT** If you write your own error handler, you should **not** render the error message\n * without using a templating engine that will properly escape it for other HTML contexts first.\n *\n * @see the {@link AuthError.cause | cause property} contains the underlying error.\n * **IMPORTANT** When this error is from the Identity Provider ({@link IdentityProviderError}) it can contain user\n * input and is only escaped using basic escaping for putting untrusted data directly into the HTML body.\n * You should **not** render this error without using a templating engine that will properly escape it for other\n * HTML contexts first.\n *\n * @see the {@link AuthError.status | status property} contains the HTTP status code of the error,\n * if any.\n *\n * @category Server\n */\nexport class HandlerError extends AuthError {\n  constructor(options: HandlerErrorOptions) {\n    let status: number | undefined;\n    if ('status' in options.cause) status = options.cause.status;\n    /* c8 ignore next */\n    super({ ...options, status });\n  }\n}\n\n/**\n * The error thrown by the callback API route handler. It extends {@link HandlerError}.\n *\n * Because part of the error message can come from the OpenID Connect `error` query parameter we\n * do some basic escaping which makes sure the default error handler is safe from XSS.\n *\n * **IMPORTANT** If you write your own error handler, you should **not** render the error message\n * without using a templating engine that will properly escape it for other HTML contexts first.\n *\n * @see the {@link AuthError.cause | cause property} contains the underlying error.\n * **IMPORTANT** When this error is from the Identity Provider ({@link IdentityProviderError}) it can contain user\n * input and is only escaped using basic escaping for putting untrusted data directly into the HTML body.\n * You should **not** render this error without using a templating engine that will properly escape it for other\n * HTML contexts first.\n *\n * @see the {@link AuthError.status | status property} contains the HTTP status code of the error,\n * if any.\n *\n * @category Server\n */\nexport class CallbackHandlerError extends HandlerError {\n  public static readonly code: string = 'ERR_CALLBACK_HANDLER_FAILURE';\n\n  constructor(cause: HandlerErrorCause) {\n    super({\n      code: CallbackHandlerError.code,\n      message: 'Callback handler failed.',\n      name: 'CallbackHandlerError',\n      cause\n    }); /* c8 ignore next */\n    Object.setPrototypeOf(this, CallbackHandlerError.prototype);\n  }\n}\n\n/**\n * The error thrown by the login API route handler. It extends {@link HandlerError}.\n *\n * @see the {@link AuthError.cause | cause property} contains the underlying error.\n * @category Server\n */\nexport class LoginHandlerError extends HandlerError {\n  public static readonly code: string = 'ERR_LOGIN_HANDLER_FAILURE';\n\n  constructor(cause: HandlerErrorCause) {\n    super({\n      code: LoginHandlerError.code,\n      message: 'Login handler failed.',\n      name: 'LoginHandlerError',\n      cause\n    }); /* c8 ignore next */\n    Object.setPrototypeOf(this, LoginHandlerError.prototype);\n  }\n}\n\n/**\n * The error thrown by the logout API route handler. It extends {@link HandlerError}.\n *\n * @see the {@link AuthError.cause | cause property} contains the underlying error.\n * @category Server\n */\nexport class LogoutHandlerError extends HandlerError {\n  public static readonly code: string = 'ERR_LOGOUT_HANDLER_FAILURE';\n\n  constructor(cause: HandlerErrorCause) {\n    super({\n      code: LogoutHandlerError.code,\n      message: 'Logout handler failed.',\n      name: 'LogoutHandlerError',\n      cause\n    }); /* c8 ignore next */\n    Object.setPrototypeOf(this, LogoutHandlerError.prototype);\n  }\n}\n\n/**\n * The error thrown by the profile API route handler. It extends {@link HandlerError}.\n *\n * @see the {@link AuthError.cause | cause property} contains the underlying error.\n * @category Server\n */\nexport class ProfileHandlerError extends HandlerError {\n  public static readonly code: string = 'ERR_PROFILE_HANDLER_FAILURE';\n\n  constructor(cause: HandlerErrorCause) {\n    super({\n      code: ProfileHandlerError.code,\n      message: 'Profile handler failed.',\n      name: 'ProfileHandlerError',\n      cause\n    }); /* c8 ignore next */\n    Object.setPrototypeOf(this, ProfileHandlerError.prototype);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1553, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1557, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/auth0-request-cookies.ts"],"sourcesContent":["export default abstract class Auth0RequestCookies {\n  public abstract getCookies(): Record<string, string>;\n}\n"],"names":[],"mappings":";;;;AAAA,MAA8B;;AAA9B,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1568, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/auth0-request.ts"],"sourcesContent":["import Auth0RequestCookies from './auth0-request-cookies';\n\nexport default abstract class Auth0Request<Req = any> extends Auth0RequestCookies {\n  protected constructor(public req: Req) {\n    super();\n  }\n\n  public abstract getUrl(): string;\n  public abstract getMethod(): string;\n  public abstract getBody(): Promise<Record<string, string> | string> | Record<string, string> | string;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,0BAAA,QAAA,eAAA;AAEA,MAA8B,qBAAgC,wBAAA,OAAmB;IAC/E,YAA6B,GAAQ,CAAA;QACnC,KAAK;QADsB,IAAA,CAAA,GAAG,GAAH;IAE7B;;AAHF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1581, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1585, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/auth0-response-cookies.ts"],"sourcesContent":["import { CookieSerializeOptions } from 'cookie';\n\nexport default abstract class Auth0ResponseCookies {\n  public abstract setCookie(name: string, value: string, options?: CookieSerializeOptions): void;\n\n  public clearCookie(name: string, options: CookieSerializeOptions = {}): void {\n    const { domain, path, secure, sameSite } = options;\n    const clearOptions: CookieSerializeOptions = {\n      domain,\n      path,\n      maxAge: 0\n    };\n    // If SameSite=None is set, the cookie Secure attribute must also be set (or the cookie will be blocked)\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite#none\n    if (sameSite === 'none') {\n      clearOptions.secure = secure;\n      clearOptions.sameSite = sameSite;\n    }\n    this.setCookie(name, '', clearOptions);\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,MAA8B;IAGrB,YAAY,IAAY,EAAE,UAAkC,CAAA,CAAE,EAAA;QACnE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG;QAC3C,MAAM,eAAuC;YAC3C;YACA;YACA,QAAQ;;QAEV,wGAAwG;QACxG,qFAAqF;QACrF,IAAI,aAAa,QAAQ;YACvB,aAAa,MAAM,GAAG;YACtB,aAAa,QAAQ,GAAG;;QAE1B,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI;IAC3B;;AAjBF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1611, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/auth0-response.ts"],"sourcesContent":["import Auth0ResponseCookies from './auth0-response-cookies';\n\nexport default abstract class Auth0Response<Res = any> extends Auth0ResponseCookies {\n  protected constructor(public res: Res) {\n    super();\n  }\n\n  public abstract redirect(location: string, status?: number): void;\n\n  public abstract send204(): void;\n\n  public abstract setHeader(name: string, value: string): void;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA,2BAAA,QAAA,eAAA;AAEA,MAA8B,sBAAiC,yBAAA,OAAoB;IACjF,YAA6B,GAAQ,CAAA;QACnC,KAAK;QADsB,IAAA,CAAA,GAAG,GAAH;IAE7B;;AAHF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1624, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/node-request.ts"],"sourcesContent":["import { IncomingMessage } from 'http';\nimport { parse } from 'cookie';\nimport Auth0Request from './auth0-request';\n\nexport default class NodeRequest extends Auth0Request<IncomingMessage> {\n  public constructor(public req: IncomingMessage) {\n    /* c8 ignore next */\n    super(req);\n  }\n\n  public getUrl() {\n    return this.req.url as string;\n  }\n\n  public getMethod() {\n    return this.req.method as string;\n  }\n\n  public getBody() {\n    return (this.req as IncomingMessage & { body: Record<string, string> }).body;\n  }\n\n  public getCookies(): Record<string, string> {\n    return parse(this.req.headers.cookie || '');\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA,kBAAA,QAAA,eAAA;AAEA,MAAqB,oBAAoB,gBAAA,OAA6B;IACpE,YAA0B,GAAoB,CAAA;QAC5C,kBAAA,GACA,KAAK,CAAC;QAFkB,IAAA,CAAA,GAAG,GAAH;IAG1B;IAEO,SAAM;QACX,OAAO,IAAI,CAAC,GAAG,CAAC,GAAa;IAC/B;IAEO,YAAS;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,MAAgB;IAClC;IAEO,UAAO;QACZ,OAAQ,IAAI,CAAC,GAA0D,CAAC,IAAI;IAC9E;IAEO,aAAU;QACf,OAAO,CAAA,GAAA,SAAA,KAAK,EAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,IAAI;IAC1C;;AApBF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1654, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1658, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/node-response.ts"],"sourcesContent":["import { ServerResponse } from 'http';\nimport { CookieSerializeOptions, serialize } from 'cookie';\nimport Auth0Response from './auth0-response';\nimport { htmlSafe } from '../utils/errors';\n\nexport default class NodeResponse<T extends ServerResponse = ServerResponse> extends Auth0Response<ServerResponse> {\n  public constructor(public res: T) {\n    /* c8 ignore next */\n    super(res);\n  }\n\n  public setCookie(name: string, value: string, options?: CookieSerializeOptions) {\n    let cookies = this.res.getHeader('Set-Cookie') || [];\n    if (!Array.isArray(cookies)) {\n      cookies = [cookies as string];\n    }\n\n    this.res.setHeader('Set-Cookie', [\n      ...cookies.filter((cookie) => !cookie.startsWith(`${name}=`)),\n      serialize(name, value, options)\n    ]);\n  }\n\n  public redirect(location: string, status = 302): void {\n    if (this.res.writableEnded) {\n      return;\n    }\n    this.res.writeHead(status, {\n      Location: this.res.getHeader('Location') || location\n    });\n    this.res.end(htmlSafe(location));\n  }\n\n  public send204(): void {\n    this.res.statusCode = 204;\n    this.res.end();\n  }\n\n  public setHeader(name: string, value: string): void {\n    this.res.setHeader(name, value);\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA,mBAAA,QAAA,eAAA;AACA,MAAA;AAEA,MAAqB,qBAAgE,iBAAA,OAA6B;IAChH,YAA0B,GAAM,CAAA;QAC9B,kBAAA,GACA,KAAK,CAAC;QAFkB,IAAA,CAAA,GAAG,GAAH;IAG1B;IAEO,UAAU,IAAY,EAAE,KAAa,EAAE,OAAgC,EAAA;QAC5E,IAAI,UAAU,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,iBAAiB,EAAE;QACpD,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU;YAC3B,UAAU;gBAAC;aAAkB;;QAG/B,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,cAAc;eAC5B,QAAQ,MAAM,CAAC,CAAC,SAAW,CAAC,OAAO,UAAU,CAAC,CAAA,EAAG,KAAI,CAAA,CAAG;YAC3D,CAAA,GAAA,SAAA,SAAS,EAAC,MAAM,OAAO;SACxB;IACH;IAEO,SAAS,QAAgB,EAAE,SAAS,GAAG,EAAA;QAC5C,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;YAC1B;;QAEF,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ;YACzB,UAAU,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,eAAe;;QAE9C,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA,GAAA,SAAA,QAAQ,EAAC;IACxB;IAEO,UAAO;QACZ,IAAI,CAAC,GAAG,CAAC,UAAU,GAAG;QACtB,IAAI,CAAC,GAAG,CAAC,GAAG;IACd;IAEO,UAAU,IAAY,EAAE,KAAa,EAAA;QAC1C,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM;IAC3B;;AAnCF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1701, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1705, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/http/index.ts"],"sourcesContent":["export { default as Auth0Request } from './auth0-request';\nexport { default as Auth0Response } from './auth0-response';\nexport { default as Auth0RequestCookies } from './auth0-request-cookies';\nexport { default as Auth0ResponseCookies } from './auth0-response-cookies';\nexport { default as NodeRequest } from './node-request';\nexport { default as NodeResponse } from './node-response';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,iBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,iBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,kBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,uBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,yBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,0BAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,eAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,gBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,iBAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1761, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-api-request.ts"],"sourcesContent":["import { Auth0Request } from '../auth0-session/http';\nimport { NextApiRequest } from 'next';\n\nexport default class Auth0NextApiRequest extends Auth0Request<NextApiRequest> {\n  public constructor(req: NextApiRequest) {\n    /* c8 ignore next */\n    super(req);\n  }\n\n  public getUrl(): string {\n    return this.req.url as string;\n  }\n  public getMethod(): string {\n    return this.req.method as string;\n  }\n  public getBody(): Record<string, string> {\n    return this.req.body;\n  }\n  public getCookies(): Record<string, string> {\n    return this.req.cookies as Record<string, string>;\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGA,MAAqB,4BAA4B,OAAA,YAA4B;IAC3E,YAAmB,GAAmB,CAAA;QACpC,kBAAA,GACA,KAAK,CAAC;IACR;IAEO,SAAM;QACX,OAAO,IAAI,CAAC,GAAG,CAAC,GAAa;IAC/B;IACO,YAAS;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,MAAgB;IAClC;IACO,UAAO;QACZ,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACtB;IACO,aAAU;QACf,OAAO,IAAI,CAAC,GAAG,CAAC,OAAiC;IACnD;;AAjBF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1784, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1788, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-api-response.ts"],"sourcesContent":["import { NodeResponse } from '../auth0-session/http';\nimport { NextApiResponse } from 'next';\n\nexport default class Auth0NextApiResponse extends NodeResponse<NextApiResponse> {\n  public redirect(location: string, status = 302): void {\n    if (this.res.writableEnded) {\n      return;\n    }\n    this.res.redirect(status, (this.res.getHeader('Location') as string) || location);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGA,MAAqB,6BAA6B,OAAA,YAA6B;IACtE,SAAS,QAAgB,EAAE,SAAS,GAAG,EAAA;QAC5C,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;YAC1B;;QAEF,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,QAAS,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,eAA0B;IAC1E;;AANF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1802, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-request.ts"],"sourcesContent":["import { Auth0Request } from '../auth0-session/http';\nimport { NextRequest } from 'next/server';\n\nexport default class Auth0NextRequest extends Auth0Request<NextRequest> {\n  public constructor(req: NextRequest) {\n    /* c8 ignore next */\n    super(req);\n  }\n\n  public getUrl(): string {\n    return this.req.url as string;\n  }\n  public getMethod(): string {\n    return this.req.method as string;\n  }\n  public async getBody(): Promise<Record<string, string> | string> {\n    return this.req.text();\n  }\n  public getCookies(): Record<string, string> {\n    const { cookies } = this.req;\n    if (typeof cookies.getAll === 'function') {\n      return this.req.cookies.getAll().reduce((memo, { name, value }) => ({ ...memo, [name]: value }), {});\n    }\n    // Edge cookies before Next 13.0.1 have no `getAll` and extend `Map`.\n    const legacyCookies = cookies as unknown as Map<string, string>;\n    return Array.from(legacyCookies.keys()).reduce((memo: { [key: string]: string }, key) => {\n      memo[key] = legacyCookies.get(key) as string;\n      return memo;\n    }, {});\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGA,MAAqB,yBAAyB,OAAA,YAAyB;IACrE,YAAmB,GAAgB,CAAA;QACjC,kBAAA,GACA,KAAK,CAAC;IACR;IAEO,SAAM;QACX,OAAO,IAAI,CAAC,GAAG,CAAC,GAAa;IAC/B;IACO,YAAS;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,MAAgB;IAClC;IACO,MAAM,UAAO;QAClB,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI;IACtB;IACO,aAAU;QACf,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,GAAG;QAC5B,IAAI,OAAO,QAAQ,MAAM,KAAK,YAAY;YACxC,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAK,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,OAAI;oBAAE,CAAC,KAAK,EAAE;gBAAK,IAAK,CAAA;;QAEnG,qEAAqE;QACrE,MAAM,gBAAgB;QACtB,OAAO,MAAM,IAAI,CAAC,cAAc,IAAI,IAAI,MAAM,CAAC,CAAC,MAAiC;YAC/E,IAAI,CAAC,IAAI,GAAG,cAAc,GAAG,CAAC;YAC9B,OAAO;QACT,GAAG,CAAA;IACL;;AA1BF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1840, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1844, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-response.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport type { CookieSerializeOptions } from 'cookie';\nimport { Auth0Response } from '../auth0-session/http';\n\nexport default class Auth0NextResponse extends Auth0Response<NextResponse> {\n  public constructor(res: NextResponse) {\n    /* c8 ignore next */\n    super(res);\n  }\n\n  public setCookie(name: string, value: string, options?: CookieSerializeOptions) {\n    this.res.cookies.set(name, value, options);\n  }\n\n  public clearCookie(name: string, options?: CookieSerializeOptions) {\n    this.setCookie(name, '', { ...options, expires: new Date(0) });\n  }\n\n  public redirect(location: string, status = 302): void {\n    const oldRes = this.res;\n    this.res = new NextResponse(null, { status });\n    oldRes.headers.forEach((value, key) => {\n      this.res.headers.set(key, value);\n    });\n    this.res.headers.set('location', location);\n    for (const cookie of oldRes.cookies.getAll()) {\n      this.res.cookies.set(cookie);\n    }\n  }\n\n  public setHeader(name: string, value: string) {\n    this.res.headers.set(name, value);\n  }\n\n  public send204() {\n    const oldRes = this.res;\n    this.res = new NextResponse(null, { status: 204 });\n    oldRes.headers.forEach((value, key) => {\n      this.res.headers.set(key, value);\n    });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAEA,MAAA;AAEA,MAAqB,0BAA0B,OAAA,aAA2B;IACxE,YAAmB,GAAiB,CAAA;QAClC,kBAAA,GACA,KAAK,CAAC;IACR;IAEO,UAAU,IAAY,EAAE,KAAa,EAAE,OAAgC,EAAA;QAC5E,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,OAAO;IACpC;IAEO,YAAY,IAAY,EAAE,OAAgC,EAAA;QAC/D,IAAI,CAAC,SAAS,CAAC,MAAM,IAAE,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAO,UAAO;YAAE,SAAS,IAAI,KAAK;QAAE;IAC7D;IAEO,SAAS,QAAgB,EAAE,SAAS,GAAG,EAAA;QAC5C,MAAM,SAAS,IAAI,CAAC,GAAG;QACvB,IAAI,CAAC,GAAG,GAAG,IAAI,SAAA,YAAY,CAAC,MAAM;YAAE;QAAM;QAC1C,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO;YAC7B,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK;QAC5B;QACA,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,YAAY;QACjC,KAAK,MAAM,UAAU,OAAO,OAAO,CAAC,MAAM,GAAI;YAC5C,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC;;IAEzB;IAEO,UAAU,IAAY,EAAE,KAAa,EAAA;QAC1C,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM;IAC7B;IAEO,UAAO;QACZ,MAAM,SAAS,IAAI,CAAC,GAAG;QACvB,IAAI,CAAC,GAAG,GAAG,IAAI,SAAA,YAAY,CAAC,MAAM;YAAE,QAAQ;QAAG;QAC/C,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO;YAC7B,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK;QAC5B;IACF;;AApCF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1893, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-request-cookies.ts"],"sourcesContent":["import { Auth0RequestCookies } from '../auth0-session/http';\n\nexport default class Auth0NextRequestCookies extends Auth0RequestCookies {\n  public constructor() {\n    super();\n  }\n\n  public getCookies(): Record<string, string> {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { cookies } = require('next/headers');\n    const cookieStore = cookies();\n    return cookieStore.getAll().reduce(\n      (memo: Record<string, string>, { name, value }: { name: string; value: string }) => ({\n        ...memo,\n        [name]: value\n      }),\n      {}\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAEA,MAAqB,gCAAgC,OAAA,mBAAmB;IACtE,aAAA;QACE,KAAK;IACP;IAEO,aAAU;QACf,8DAA8D;QAC9D,MAAM,EAAE,OAAO,EAAE;QACjB,MAAM,cAAc;QACpB,OAAO,YAAY,MAAM,GAAG,MAAM,CAChC,CAAC,MAA8B,EAAE,IAAI,EAAE,KAAK,EAAmC,GAAK,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAC/E,OAAI;gBACP,CAAC,KAAK,EAAE;YAAK,IAEf,CAAA;IAEJ;;AAhBF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1912, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1916, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/auth0-next-response-cookies.ts"],"sourcesContent":["import type { CookieSerializeOptions } from 'cookie';\nimport { Auth0ResponseCookies } from '../auth0-session/http';\n\nlet warned = false;\n\nconst warn = () => {\n  /* c8 ignore next 8 */\n  if (process.env.NODE_ENV === 'development' && !warned) {\n    console.warn(\n      'nextjs-auth0 is attempting to set cookies from a server component,' +\n        'see https://github.com/auth0/nextjs-auth0#using-this-sdk-with-react-server-components'\n    );\n    warned = true;\n  }\n};\n\nexport default class Auth0NextResponseCookies extends Auth0ResponseCookies {\n  public constructor() {\n    super();\n  }\n\n  public setCookie(name: string, value: string, options?: CookieSerializeOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { cookies } = require('next/headers');\n    const cookieSetter = cookies();\n    try {\n      cookieSetter.set({ ...options, name, value });\n    } catch (_) {\n      warn();\n    }\n  }\n\n  public clearCookie(name: string, options?: CookieSerializeOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { cookies } = require('next/headers');\n    const cookieSetter = cookies();\n    try {\n      cookieSetter.set({ ...options, name, value: '', expires: new Date(0) });\n    } catch (_) {\n      warn();\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AACA,MAAA;AAEA,IAAI,SAAS;AAEb,MAAM,OAAO;IACX,oBAAA,GACA,IAAI,oDAAyB,iBAAiB,CAAC,QAAQ;QACrD,QAAQ,IAAI,CACV,uEACE;QAEJ,SAAS;;AAEb;AAEA,MAAqB,iCAAiC,OAAA,oBAAoB;IACxE,aAAA;QACE,KAAK;IACP;IAEO,UAAU,IAAY,EAAE,KAAa,EAAE,OAAgC,EAAA;QAC5E,8DAA8D;QAC9D,MAAM,EAAE,OAAO,EAAE;QACjB,MAAM,eAAe;QACrB,IAAI;YACF,aAAa,GAAG,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,UAAO;gBAAE;gBAAM;YAAK;UAC1C,OAAO,GAAG;YACV;;IAEJ;IAEO,YAAY,IAAY,EAAE,OAAgC,EAAA;QAC/D,8DAA8D;QAC9D,MAAM,EAAE,OAAO,EAAE;QACjB,MAAM,eAAe;QACrB,IAAI;YACF,aAAa,GAAG,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAM,UAAO;gBAAE;gBAAM,OAAO;gBAAI,SAAS,IAAI,KAAK;YAAE;UACpE,OAAO,GAAG;YACV;;IAEJ;;AAzBF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 1961, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1965, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/http/index.ts"],"sourcesContent":["export { default as Auth0NextApiRequest } from './auth0-next-api-request';\nexport { default as Auth0NextApiResponse } from './auth0-next-api-response';\nexport { default as Auth0NextRequest } from './auth0-next-request';\nexport { default as Auth0NextResponse } from './auth0-next-response';\nexport { default as Auth0NextRequestCookies } from './auth0-next-request-cookies';\nexport { default as Auth0NextResponseCookies } from './auth0-next-response-cookies';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,uBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,0BAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,2BAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,sBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,qBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,uBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,2BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,8BAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,4BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,+BAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 2017, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2021, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/req-helpers.ts"],"sourcesContent":["import type { IncomingMessage } from 'http';\nimport { NextApiRequest } from 'next';\nimport { NextRequest } from 'next/server';\n\ntype Req = IncomingMessage | NextApiRequest | NextRequest | Request | Record<string, any>;\n\nexport const isRequest = (req: Req): boolean => {\n  return req instanceof Request || req.headers instanceof Headers || typeof (req as Request).bodyUsed === 'boolean';\n};\n\nexport const isNextApiRequest = (req: Req) => {\n  return !isRequest(req) && 'query' in req;\n};\n"],"names":[],"mappings":";;;;;AAMO,MAAM,YAAY,CAAC;IACxB,OAAO,eAAe,WAAW,IAAI,OAAO,YAAY,WAAW,OAAQ,IAAgB,QAAQ,KAAK;AAC1G;AAFa,QAAA,SAAS,GAAA;AAIf,MAAM,mBAAmB,CAAC;IAC/B,OAAO,CAAC,CAAA,GAAA,QAAA,SAAS,EAAC,QAAQ,WAAW;AACvC;AAFa,QAAA,gBAAgB,GAAA"}},
    {"offset": {"line": 2034, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/router-helpers.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { isRequest } from '../utils/req-helpers';\n\nexport type AppRouteHandlerFnContext = {\n  params: Record<string, string | string[]>;\n};\n\n/**\n * Handler function for app routes.\n */\nexport type AppRouteHandlerFn<Options = any> = (\n  /**\n   * Incoming request object.\n   */\n  req: NextRequest,\n  /**\n   * Context properties on the request (including the parameters if this was a\n   * dynamic route).\n   */\n  ctx: AppRouteHandlerFnContext,\n\n  opts?: Options\n) => Promise<Response> | Response;\n\n/**\n * Handler function for app routes.\n */\nexport type PageRouteHandlerFn<Options> = (\n  /**\n   * Incoming request object.\n   */\n  req: NextApiRequest,\n  /**\n   * Context properties on the request (including the parameters if this was a\n   * dynamic route).\n   */\n  res: NextApiResponse,\n\n  opts?: Options\n) => Promise<void> | void;\n\nexport type OptionsProvider<Opts> = (req: NextApiRequest | NextRequest) => Opts;\n\nexport type AuthHandler<Opts> = Handler<Opts> & {\n  (provider?: OptionsProvider<Opts>): Handler<Opts>;\n  (options?: Opts): Handler<Opts>;\n};\n\nexport type NextAppRouterHandler = (req: NextRequest, ctx: AppRouteHandlerFnContext) => Promise<Response> | Response;\nexport type NextPageRouterHandler = (req: NextApiRequest, res: NextApiResponse) => Promise<unknown> | unknown;\n\n/**\n * @deprecated use {@link NextPageRouterHandler}\n */\nexport type AppRouterHandler = NextPageRouterHandler;\n/**\n * @deprecated use {@link NextAppRouterHandler}\n */\nexport type PageRouterHandler = NextAppRouterHandler;\n\nexport type Handler<Opts = any> = {\n  (req: NextRequest, ctx: AppRouteHandlerFnContext, options?: Opts): Promise<Response> | Response;\n  (req: NextApiRequest, res: NextApiResponse, options?: Opts): Promise<unknown> | unknown;\n  (req: NextApiRequest | NextRequest, resOrOpts: NextApiResponse | AppRouteHandlerFnContext, options?: Opts):\n    | Promise<Response | unknown>\n    | Response\n    | unknown;\n};\n\nexport const getHandler =\n  <Opts extends Record<string, any>>(\n    appRouteHandler: AppRouteHandlerFn<Opts>,\n    pageRouteHandler: PageRouteHandlerFn<Opts>\n  ) =>\n  (\n    reqOrOptions: NextApiRequest | NextRequest | Opts,\n    resOrCtx: NextApiResponse | AppRouteHandlerFnContext,\n    options?: Opts\n  ) => {\n    if (isRequest(reqOrOptions)) {\n      return appRouteHandler(reqOrOptions as NextRequest, resOrCtx as AppRouteHandlerFnContext, options);\n    }\n    if ('socket' in reqOrOptions) {\n      return pageRouteHandler(reqOrOptions as NextApiRequest, resOrCtx as NextApiResponse, options);\n    }\n    return (req: NextApiRequest | NextRequest, resOrCtxInner: NextApiResponse | AppRouteHandlerFnContext) => {\n      const opts = (\n        typeof reqOrOptions === 'function' ? (reqOrOptions as OptionsProvider<Opts>)(req) : reqOrOptions\n      ) as Opts;\n\n      if (isRequest(req)) {\n        return appRouteHandler(req as NextRequest, resOrCtxInner as AppRouteHandlerFnContext, opts);\n      }\n      return pageRouteHandler(req as NextApiRequest, resOrCtxInner as NextApiResponse, opts);\n    };\n  };\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAoEO,MAAM,aACX,CACE,iBACA,mBAEF,CACE,cACA,UACA;QAEA,IAAI,CAAA,GAAA,cAAA,SAAS,EAAC,eAAe;YAC3B,OAAO,gBAAgB,cAA6B,UAAsC;;QAE5F,IAAI,YAAY,cAAc;YAC5B,OAAO,iBAAiB,cAAgC,UAA6B;;QAEvF,OAAO,CAAC,KAAmC;YACzC,MAAM,OACJ,OAAO,iBAAiB,aAAc,aAAuC,OAAO;YAGtF,IAAI,CAAA,GAAA,cAAA,SAAS,EAAC,MAAM;gBAClB,OAAO,gBAAgB,KAAoB,eAA2C;;YAExF,OAAO,iBAAiB,KAAuB,eAAkC;QACnF;IACF;AA1BW,QAAA,UAAU,GAAA"}},
    {"offset": {"line": 2060, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2064, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/callback.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport {\n  AuthorizationParameters,\n  HandleCallback as BaseHandleCallback,\n  AfterCallback as BaseAfterCallback,\n  HandleLogin as BaseHandleLogin\n} from '../auth0-session';\nimport { Session } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { GetConfig, NextConfig } from '../config';\nimport { CallbackHandlerError, HandlerErrorCause } from '../utils/errors';\nimport { Auth0NextApiRequest, Auth0NextApiResponse, Auth0NextRequest, Auth0NextResponse } from '../http';\nimport { AppRouteHandlerFnContext, AuthHandler, getHandler, Handler, OptionsProvider } from './router-helpers';\n\n/**\n * afterCallback hook for page router {@link AfterCallbackPageRoute} and app router {@link AfterCallbackAppRoute}\n */\nexport type AfterCallback = AfterCallbackPageRoute | AfterCallbackAppRoute;\n\n/**\n * Use this function for validating additional claims on the user's ID token or adding removing items from\n * the session after login.\n *\n * @example Validate additional claims\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   if (session.user.isAdmin) {\n *     return session;\n *   } else {\n *     res.status(401).end('User is not admin');\n *   }\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end();\n *     }\n *   }\n * });\n * ```\n *\n * @example Modify the session after login\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   session.user.customProperty = 'foo';\n *   delete session.refreshToken;\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end();\n *     }\n *   }\n * });\n * ```\n *\n * @example Redirect successful login based on claim\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * const afterCallback = (req, res, session, state) => {\n *   if (!session.user.isAdmin) {\n *     res.setHeader('Location', '/admin');\n *   }\n *   return session;\n * };\n *\n * export default handleAuth({\n *   async callback(req, res) {\n *     try {\n *       await handleCallback(req, res, { afterCallback });\n *     } catch (error) {\n *       res.status(error.status || 500).end(error.message);\n *     }\n *   }\n * });\n * ```\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type AfterCallbackPageRoute = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  session: Session,\n  state?: { [key: string]: any }\n) => Promise<Session | undefined> | Session | undefined;\n\n/**\n * Use this function for validating additional claims on the user's ID token or adding removing items from\n * the session after login.\n *\n * @example Validate additional claims\n *\n * ```js\n * // app/api/auth/[auth0]/route.js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n * import { redirect } from 'next/navigation';\n *\n * const afterCallback = (req, session, state) => {\n *   if (session.user.isAdmin) {\n *     return session;\n *   } else {\n *     redirect('/unauthorized');\n *   }\n * };\n *\n * export default handleAuth({\n *   callback: handleCallback({ afterCallback })\n * });\n * ```\n *\n * @example Modify the session after login\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n * import { NextResponse } from 'next/server';\n *\n * const afterCallback = (req, session, state) => {\n *   session.user.customProperty = 'foo';\n *   delete session.refreshToken;\n *   return session;\n * };\n *\n * export default handleAuth({\n *   callback: handleCallback({ afterCallback })\n * });\n * ```\n *\n * @example Redirect successful login based on claim\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n * import { headers } from 'next/headers';\n *\n * const afterCallback = (req, session, state) => {\n *   if (!session.user.isAdmin) {\n *     headers.set('location', '/admin');\n *   }\n *   return session;\n * };\n *\n * export default handleAuth({\n *   callback: handleCallback({ afterCallback })\n * });\n * ```\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type AfterCallbackAppRoute = (\n  req: NextRequest,\n  session: Session,\n  state?: { [key: string]: any }\n) => Promise<Session | Response | undefined> | Session | Response | undefined;\n\n/**\n * Options to customize the callback handler.\n *\n * @see {@link HandleCallback}\n *\n * @category Server\n */\nexport interface CallbackOptions {\n  afterCallback?: AfterCallback;\n\n  /**\n   * This is useful to specify in addition to {@link BaseConfig.baseURL} when your app runs on multiple domains,\n   * it should match {@link LoginOptions.authorizationParams.redirect_uri}.\n   */\n  redirectUri?: string;\n\n  /**\n   * This is useful to specify instead of {@link NextConfig.organization} when your app has multiple\n   * organizations, it should match {@link LoginOptions.authorizationParams}.\n   */\n  organization?: string;\n\n  /**\n   * This is useful for sending custom query parameters in the body of the code exchange request\n   * for use in Actions/Rules.\n   */\n  authorizationParams?: Partial<AuthorizationParameters>;\n}\n\n/**\n * Options provider for the default callback handler.\n * Use this to generate options that depend on values from the request.\n *\n * @category Server\n */\nexport type CallbackOptionsProvider = OptionsProvider<CallbackOptions>;\n\n/**\n * Use this to customize the default callback handler without overriding it.\n * You can still override the handler if needed.\n *\n * @example Pass an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   callback: handleCallback({ redirectUri: 'https://example.com' })\n * });\n * ```\n *\n * @example Pass a function that receives the request and returns an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   callback: handleCallback((req) => {\n *     return { redirectUri: 'https://example.com' };\n *   })\n * });\n * ```\n *\n * This is useful for generating options that depend on values from the request.\n *\n * @example Override the callback handler\n *\n * ```js\n * import { handleAuth, handleCallback } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   callback: async (req, res) => {\n *     try {\n *       await handleCallback(req, res, {\n *         redirectUri: 'https://example.com'\n *       });\n *     } catch (error) {\n *       console.error(error);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type HandleCallback = AuthHandler<CallbackOptions>;\n\n/**\n * The handler for the `/api/auth/callback` API route.\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type CallbackHandler = Handler<CallbackOptions>;\n\n/**\n * @ignore\n */\nexport default function handleCallbackFactory(handler: BaseHandleCallback, getConfig: GetConfig): HandleCallback {\n  const appRouteHandler = appRouteHandlerFactory(handler, getConfig);\n  const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);\n\n  return getHandler<CallbackOptions>(appRouteHandler, pageRouteHandler) as HandleCallback;\n}\n\nconst applyOptions = (\n  req: NextApiRequest | NextRequest,\n  res: NextApiResponse | undefined,\n  options: CallbackOptions,\n  config: NextConfig\n) => {\n  const opts = { ...options };\n  const idTokenValidator =\n    (afterCallback?: AfterCallback, organization?: string): BaseAfterCallback =>\n    (session, state) => {\n      if (organization) {\n        if (organization.startsWith('org_')) {\n          if (!session.user.org_id) {\n            throw new Error('Organization Id (org_id) claim must be a string present in the ID token');\n          }\n          if (session.user.org_id !== organization) {\n            throw new Error(\n              `Organization Id (org_id) claim value mismatch in the ID token; ` +\n                `expected \"${organization}\", found \"${session.user.org_id}\"`\n            );\n          }\n        } else {\n          if (!session.user.org_name) {\n            throw new Error('Organization Name (org_name) claim must be a string present in the ID token');\n          }\n          if (session.user.org_name !== organization.toLowerCase()) {\n            throw new Error(\n              `Organization Name (org_name) claim value mismatch in the ID token; ` +\n                `expected \"${organization}\", found \"${session.user.org_name}\"`\n            );\n          }\n        }\n      }\n      if (afterCallback) {\n        if (res) {\n          return (afterCallback as AfterCallbackPageRoute)(req as NextApiRequest, res, session, state);\n        } else {\n          return (afterCallback as AfterCallbackAppRoute)(req as NextRequest, session, state);\n        }\n      }\n      return session;\n    };\n  return {\n    ...opts,\n    afterCallback: idTokenValidator(opts.afterCallback, opts.organization || config.organization)\n  };\n};\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory: (\n  handler: BaseHandleLogin,\n  getConfig: GetConfig\n) => (req: NextRequest, ctx: AppRouteHandlerFnContext, options?: CallbackOptions) => Promise<Response> | Response =\n  (handler, getConfig) =>\n  async (req, _ctx, options = {}) => {\n    try {\n      const auth0Req = new Auth0NextRequest(req);\n      const nextConfig = await getConfig(auth0Req);\n      const auth0Res = new Auth0NextResponse(new NextResponse());\n      await handler(auth0Req, auth0Res, applyOptions(req, undefined, options, nextConfig));\n      return auth0Res.res;\n    } catch (e) {\n      throw new CallbackHandlerError(e as HandlerErrorCause);\n    }\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory: (\n  handler: BaseHandleCallback,\n  getConfig: GetConfig\n) => (req: NextApiRequest, res: NextApiResponse, options?: CallbackOptions) => Promise<void> =\n  (handler, getConfig) =>\n  async (req: NextApiRequest, res: NextApiResponse, options = {}): Promise<void> => {\n    try {\n      const auth0Req = new Auth0NextApiRequest(req);\n      const nextConfig = await getConfig(auth0Req);\n      assertReqRes(req, res);\n      return await handler(auth0Req, new Auth0NextApiResponse(res), applyOptions(req, res, options, nextConfig));\n    } catch (e) {\n      throw new CallbackHandlerError(e as HandlerErrorCause);\n    }\n  };\n"],"names":[],"mappings":";;;;AACA,MAAA;AAQA,MAAA;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAuQA;;IAGA,SAAwB,sBAAsB,OAA2B,EAAE,SAAoB;IAC7F,MAAM,kBAAkB,uBAAuB,SAAS;IACxD,MAAM,mBAAmB,wBAAwB,SAAS;IAE1D,OAAO,CAAA,GAAA,iBAAA,UAAU,EAAkB,iBAAiB;AACtD;AALA,QAAA,OAAA,GAAA;AAOA,MAAM,eAAe,CACnB,KACA,KACA,SACA;IAEA,MAAM,OAAI,OAAA,MAAA,CAAA,CAAA,GAAQ;IAClB,MAAM,mBACJ,CAAC,eAA+B,eAChC,CAAC,SAAS;YACR,IAAI,cAAc;gBAChB,IAAI,aAAa,UAAU,CAAC,SAAS;oBACnC,IAAI,CAAC,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACxB,MAAM,IAAI,MAAM;;oBAElB,IAAI,QAAQ,IAAI,CAAC,MAAM,KAAK,cAAc;wBACxC,MAAM,IAAI,MACR,CAAA,+DAAA,CAAiE,GAC/D,CAAA,UAAA,EAAa,aAAY,UAAA,EAAa,QAAQ,IAAI,CAAC,MAAM,CAAA,CAAA,CAAG;;uBAG7D;oBACL,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,EAAE;wBAC1B,MAAM,IAAI,MAAM;;oBAElB,IAAI,QAAQ,IAAI,CAAC,QAAQ,KAAK,aAAa,WAAW,IAAI;wBACxD,MAAM,IAAI,MACR,CAAA,mEAAA,CAAqE,GACnE,CAAA,UAAA,EAAa,aAAY,UAAA,EAAa,QAAQ,IAAI,CAAC,QAAQ,CAAA,CAAA,CAAG;;;;YAKxE,IAAI,eAAe;gBACjB,IAAI,KAAK;oBACP,OAAQ,cAAyC,KAAuB,KAAK,SAAS;uBACjF;oBACL,OAAQ,cAAwC,KAAoB,SAAS;;;YAGjF,OAAO;QACT;IACF,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACK,OAAI;QACP,eAAe,iBAAiB,KAAK,aAAa,EAAE,KAAK,YAAY,IAAI,OAAO,YAAY;IAAC;AAEjG;AAEA;;IAGA,MAAM,yBAIJ,CAAC,SAAS,YACV,OAAO,KAAK,MAAM,UAAU,CAAA,CAAE;QAC5B,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,gBAAgB,CAAC;YACtC,MAAM,aAAa,MAAM,UAAU;YACnC,MAAM,WAAW,IAAI,OAAA,iBAAiB,CAAC,IAAI,SAAA,YAAY;YACvD,MAAM,QAAQ,UAAU,UAAU,aAAa,KAAK,WAAW,SAAS;YACxE,OAAO,SAAS,GAAG;UACnB,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,oBAAoB,CAAC;;IAEnC;AAEF;;IAGA,MAAM,0BAIJ,CAAC,SAAS,YACV,OAAO,KAAqB,KAAsB,UAAU,CAAA,CAAE;QAC5D,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,mBAAmB,CAAC;YACzC,MAAM,aAAa,MAAM,UAAU;YACnC,CAAA,GAAA,SAAA,YAAY,EAAC,KAAK;YAClB,OAAO,MAAM,QAAQ,UAAU,IAAI,OAAA,oBAAoB,CAAC,MAAM,aAAa,KAAK,KAAK,SAAS;UAC9F,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,oBAAoB,CAAC;;IAEnC"}},
    {"offset": {"line": 2139, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2143, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/url-helpers.ts"],"sourcesContent":["/**\n * Helper which tests if a URL can safely be redirected to. Requires the URL to be relative.\n *\n * @param dangerousRedirect\n * @param safeBaseUrl\n */\nexport default function toSafeRedirect(dangerousRedirect: string, safeBaseUrl: URL): string | undefined {\n  let url: URL;\n  try {\n    url = new URL(dangerousRedirect, safeBaseUrl);\n  } catch (e) {\n    return undefined;\n  }\n  if (url.origin === safeBaseUrl.origin) {\n    return url.toString();\n  }\n  return undefined;\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;IAMA,SAAwB,eAAe,iBAAyB,EAAE,WAAgB;IAChF,IAAI;IACJ,IAAI;QACF,MAAM,IAAI,IAAI,mBAAmB;MACjC,OAAO,GAAG;QACV,OAAO;;IAET,IAAI,IAAI,MAAM,KAAK,YAAY,MAAM,EAAE;QACrC,OAAO,IAAI,QAAQ;;IAErB,OAAO;AACT;AAXA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2169, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/login.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport {\n  AuthorizationParameters,\n  HandleLogin as BaseHandleLogin,\n  LoginOptions as BaseLoginOptions\n} from '../auth0-session';\nimport toSafeRedirect from '../utils/url-helpers';\nimport { assertReqRes } from '../utils/assert';\nimport { GetConfig, NextConfig } from '../config';\nimport { HandlerErrorCause, LoginHandlerError } from '../utils/errors';\nimport { Auth0NextApiRequest, Auth0NextApiResponse, Auth0NextRequest, Auth0NextResponse } from '../http';\nimport { AppRouteHandlerFnContext, getHandler, OptionsProvider, Handler, AuthHandler } from './router-helpers';\n\n/**\n * Get login state hook for page router {@link GetLoginStatePageRoute} and app router {@link GetLoginStateAppRoute}.\n */\nexport type GetLoginState = GetLoginStatePageRoute | GetLoginStateAppRoute;\n\n/**\n * Use this to store additional state for the user before they visit the identity provider to log in.\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * const getLoginState = (req, loginOptions) => {\n *   return { basket_id: getBasketId(req) };\n * };\n *\n * export default handleAuth({\n *   login: handleLogin({ getLoginState })\n * });\n * ```\n *\n * @category Server\n */\nexport type GetLoginStatePageRoute = (req: NextApiRequest, options: LoginOptions) => { [key: string]: any };\n\n/**\n * Use this to store additional state for the user before they visit the identity provider to log in.\n *\n * ```js\n * // app/api/auth/[auth0]/route.js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * const getLoginState = (req, loginOptions) => {\n *   return { basket_id: getBasketId(req) };\n * };\n *\n * export default handleAuth({\n *   login: handleLogin({ getLoginState })\n * });\n * ```\n *\n * @category Server\n */\nexport type GetLoginStateAppRoute = (req: NextRequest, options: LoginOptions) => { [key: string]: any };\n\n/**\n * Authorization params to pass to the login handler.\n *\n * @category Server\n */\nexport interface AuthorizationParams extends Partial<AuthorizationParameters> {\n  /**\n   * The name of an OAuth2/social connection. Use it to directly show that\n   * identity provider's login page, skipping the Universal Login page itself.\n   * By default no connection is specified, so the Universal Login page will be displayed.\n   *\n   * ```js\n   * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n   *\n   * export default handleAuth({\n   *   login: async (req, res) => {\n   *     try {\n   *       await handleLogin(req, res, {\n   *         // Get the connection name from the Auth0 Dashboard\n   *         authorizationParams: { connection: 'github' }\n   *       });\n   *     } catch (error) {\n   *       console.error(error);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  connection?: string;\n\n  /**\n   * Provider scopes for OAuth2/social connections, such as GitHub or Google.\n   *\n   * ```js\n   * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n   *\n   * export default handleAuth({\n   *   login: async (req, res) => {\n   *     try {\n   *       await handleLogin(req, res, {\n   *         authorizationParams: {\n   *           connection: 'github',\n   *           connection_scope: 'public_repo read:user'\n   *         }\n   *       });\n   *     } catch (error) {\n   *       console.error(error);\n   *     }\n   *   }\n   * });\n   * ```\n   */\n  connection_scope?: string;\n\n  /**\n   * The invitation id to join an organization.\n   *\n   * To create a link for your user's to accept an organization invite, read the `invitation` and `organization`\n   * query params and pass them to the authorization server to log the user in:\n   *\n   * ```js\n   * // pages/api/invite.js\n   * import { handleLogin } from '@auth0/nextjs-auth0';\n   *\n   * export default async function invite(req, res) {\n   *   try {\n   *     const { invitation, organization } = req.query;\n   *     if (!invitation) {\n   *       res.status(400).end('Missing \"invitation\" parameter');\n   *     }\n   *     await handleLogin(req, res, {\n   *       authorizationParams: {\n   *         invitation,\n   *         organization\n   *       }\n   *     });\n   *   } catch (error) {\n   *     res.status(error.status || 500).end();\n   *   }\n   * } ;\n   * ```\n   *\n   * Your invite url can then take the format:\n   * `https://example.com/api/invite?invitation=invitation_id&organization=org_id_or_name`.\n   */\n  invitation?: string;\n\n  /**\n   * This is useful to specify instead of {@link NextConfig.organization} when your app has multiple\n   * organizations. It should match {@link CallbackOptions.organization}.\n   */\n  organization?: string;\n\n  /**\n   * Provides a hint to Auth0 as to what flow should be displayed. The default behavior is to show a\n   * login page but you can override this by passing 'signup' to show the signup page instead.\n   *\n   * This only affects the New Universal Login Experience.\n   */\n  screen_hint?: string;\n}\n\n/**\n * Options to customize the login handler.\n *\n * @see {@link HandleLogin}\n *\n * @category Server\n */\nexport interface LoginOptions {\n  /**\n   * Override the default {@link BaseConfig.authorizationParams authorizationParams}.\n   */\n  authorizationParams?: AuthorizationParams;\n\n  /**\n   *  URL to return to after login. Overrides the default in {@link BaseConfig.baseURL}.\n   */\n  returnTo?: string;\n\n  /**\n   *  Generate a unique state value for use during login transactions.\n   */\n  getLoginState?: GetLoginState;\n}\n\n/**\n * Options provider for the default login handler.\n * Use this to generate options that depend on values from the request.\n *\n * @category Server\n */\nexport type LoginOptionsProvider = OptionsProvider<LoginOptions>;\n\n/**\n * Use this to customize the default login handler without overriding it.\n * You can still override the handler if needed.\n *\n * @example Pass an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   login: handleLogin({\n *     authorizationParams: { connection: 'github' }\n *   })\n * });\n * ```\n *\n * @example Pass a function that receives the request and returns an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   login: handleLogin((req) => {\n *     return {\n *       authorizationParams: { connection: 'github' }\n *     };\n *   })\n * });\n * ```\n *\n * This is useful for generating options that depend on values from the request.\n *\n * @example Override the login handler\n *\n * ```js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   login: async (req, res) => {\n *     try {\n *       await handleLogin(req, res, {\n *         authorizationParams: { connection: 'github' }\n *       });\n *     } catch (error) {\n *       console.error(error);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type HandleLogin = AuthHandler<LoginOptions>;\n\n/**\n * The handler for the `/api/auth/login` API route.\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type LoginHandler = Handler<LoginOptions>;\n\n/**\n * @ignore\n */\nexport default function handleLoginFactory(handler: BaseHandleLogin, getConfig: GetConfig): HandleLogin {\n  const appRouteHandler = appRouteHandlerFactory(handler, getConfig);\n  const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);\n\n  return getHandler<LoginOptions>(appRouteHandler, pageRouteHandler) as HandleLogin;\n}\n\n/**\n * @ignore\n */\nconst applyOptions = (\n  req: NextApiRequest | NextRequest,\n  options: LoginOptions,\n  dangerousReturnTo: string | undefined | null,\n  config: NextConfig\n): BaseLoginOptions => {\n  let opts: BaseLoginOptions;\n  let getLoginState: GetLoginState | undefined;\n  // eslint-disable-next-line prefer-const\n  ({ getLoginState, ...opts } = options);\n  if (dangerousReturnTo) {\n    const safeBaseUrl = new URL(options.authorizationParams?.redirect_uri || config.baseURL);\n    const returnTo = toSafeRedirect(dangerousReturnTo, safeBaseUrl);\n    opts = { ...opts, returnTo };\n  }\n  if (config.organization) {\n    opts = {\n      ...opts,\n      authorizationParams: { organization: config.organization, ...opts.authorizationParams }\n    };\n  }\n  if (getLoginState) {\n    opts.getLoginState = (_opts) => (getLoginState as GetLoginState)(req as any, _opts as any);\n  }\n  return opts;\n};\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory: (\n  handler: BaseHandleLogin,\n  getConfig: GetConfig\n) => (req: NextRequest, ctx: AppRouteHandlerFnContext, options?: LoginOptions) => Promise<Response> | Response =\n  (handler, getConfig) =>\n  async (req, _ctx, options = {}) => {\n    try {\n      const auth0Req = new Auth0NextRequest(req);\n      const config = await getConfig(auth0Req);\n      const url = new URL(req.url);\n      const dangerousReturnTo = url.searchParams.get('returnTo');\n\n      const auth0Res = new Auth0NextResponse(new NextResponse());\n      await handler(auth0Req, auth0Res, applyOptions(req, options, dangerousReturnTo, config) as BaseLoginOptions);\n      return auth0Res.res;\n    } catch (e) {\n      throw new LoginHandlerError(e as HandlerErrorCause);\n    }\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory: (\n  handler: BaseHandleLogin,\n  getConfig: GetConfig\n) => (req: NextApiRequest, res: NextApiResponse, options?: LoginOptions) => Promise<void> | void =\n  (handler, getConfig) =>\n  async (req, res, options = {}) => {\n    try {\n      const auth0Req = new Auth0NextApiRequest(req);\n      const config = await getConfig(auth0Req);\n      assertReqRes(req, res);\n      const dangerousReturnTo =\n        req.query.returnTo && Array.isArray(req.query.returnTo) ? req.query.returnTo[0] : req.query.returnTo;\n\n      return await handler(\n        auth0Req,\n        new Auth0NextApiResponse(res),\n        applyOptions(req, options, dangerousReturnTo, config) as BaseLoginOptions\n      );\n    } catch (e) {\n      throw new LoginHandlerError(e as HandlerErrorCause);\n    }\n  };\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAMA,MAAA,gBAAA,QAAA,eAAA;AACA,MAAA;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAsPA;;IAGA,SAAwB,mBAAmB,OAAwB,EAAE,SAAoB;IACvF,MAAM,kBAAkB,uBAAuB,SAAS;IACxD,MAAM,mBAAmB,wBAAwB,SAAS;IAE1D,OAAO,CAAA,GAAA,iBAAA,UAAU,EAAe,iBAAiB;AACnD;AALA,QAAA,OAAA,GAAA;AAOA;;IAGA,MAAM,eAAe,CACnB,KACA,SACA,mBACA;;IAEA,IAAI;IACJ,IAAI;IACJ,wCAAwC;IACvC,CAAA,EAAE,aAAa,EAAA,GAAc,OAAA,GAAT,OAAI,QAAA,MAAA,CAAK,SAA7B;QAAA;KAA0B;IAC3B,IAAI,mBAAmB;QACrB,MAAM,cAAc,IAAI,IAAI,CAAA,CAAA,KAAA,QAAQ,mBAAmB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,YAAY,KAAI,OAAO,OAAO;QACvF,MAAM,WAAW,CAAA,GAAA,cAAA,OAAc,EAAC,mBAAmB;QACnD,OAAI,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAQ,OAAI;YAAE;QAAQ;;IAE5B,IAAI,OAAO,YAAY,EAAE;QACvB,OAAI,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACC,OAAI;YACP,qBAAmB,OAAA,MAAA,CAAA;gBAAI,cAAc,OAAO,YAAY;YAAA,GAAK,KAAK,mBAAmB;QAAA;;IAGzF,IAAI,eAAe;QACjB,KAAK,aAAa,GAAG,CAAC,QAAW,cAAgC,KAAY;;IAE/E,OAAO;AACT;AAEA;;IAGA,MAAM,yBAIJ,CAAC,SAAS,YACV,OAAO,KAAK,MAAM,UAAU,CAAA,CAAE;QAC5B,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,gBAAgB,CAAC;YACtC,MAAM,SAAS,MAAM,UAAU;YAC/B,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG;YAC3B,MAAM,oBAAoB,IAAI,YAAY,CAAC,GAAG,CAAC;YAE/C,MAAM,WAAW,IAAI,OAAA,iBAAiB,CAAC,IAAI,SAAA,YAAY;YACvD,MAAM,QAAQ,UAAU,UAAU,aAAa,KAAK,SAAS,mBAAmB;YAChF,OAAO,SAAS,GAAG;UACnB,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,iBAAiB,CAAC;;IAEhC;AAEF;;IAGA,MAAM,0BAIJ,CAAC,SAAS,YACV,OAAO,KAAK,KAAK,UAAU,CAAA,CAAE;QAC3B,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,mBAAmB,CAAC;YACzC,MAAM,SAAS,MAAM,UAAU;YAC/B,CAAA,GAAA,SAAA,YAAY,EAAC,KAAK;YAClB,MAAM,oBACJ,IAAI,KAAK,CAAC,QAAQ,IAAI,MAAM,OAAO,CAAC,IAAI,KAAK,CAAC,QAAQ,IAAI,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,GAAG,IAAI,KAAK,CAAC,QAAQ;YAEtG,OAAO,MAAM,QACX,UACA,IAAI,OAAA,oBAAoB,CAAC,MACzB,aAAa,KAAK,SAAS,mBAAmB;UAEhD,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,iBAAiB,CAAC;;IAEhC"}},
    {"offset": {"line": 2245, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2249, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/logout.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { HandleLogin as BaseHandleLogin, HandleLogout as BaseHandleLogout } from '../auth0-session';\nimport { assertReqRes } from '../utils/assert';\nimport { HandlerErrorCause, LogoutHandlerError } from '../utils/errors';\nimport { Auth0NextApiRequest, Auth0NextApiResponse, Auth0NextRequest, Auth0NextResponse } from '../http';\nimport { AppRouteHandlerFnContext, AuthHandler, Handler, getHandler, OptionsProvider } from './router-helpers';\n\n/**\n * Options to customize the logout handler.\n *\n * @see {@link HandleLogout}\n *\n * @category Server\n */\nexport interface LogoutOptions {\n  /**\n   * URL to return to after logout. Overrides the default\n   * in {@link BaseConfig.routes.postLogoutRedirect routes.postLogoutRedirect}.\n   */\n  returnTo?: string;\n\n  /**\n   * Additional custom parameters to pass to the logout endpoint.\n   */\n  logoutParams?: { [key: string]: any };\n}\n\n/**\n * Options provider for the default logout handler.\n * Use this to generate options that depend on values from the request.\n *\n * @category Server\n */\nexport type LogoutOptionsProvider = OptionsProvider<LogoutOptions>;\n\n/**\n * Use this to customize the default logout handler without overriding it.\n * You can still override the handler if needed.\n *\n * @example Pass an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogout } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   logout: handleLogout({ returnTo: 'https://example.com' })\n * });\n * ```\n *\n * @example Pass a function that receives the request and returns an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogout } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   logout: handleLogout((req) => {\n *     return { returnTo: 'https://example.com' };\n *   })\n * });\n * ```\n *\n * This is useful for generating options that depend on values from the request.\n *\n * @example Override the logout handler\n *\n * ```js\n * import { handleAuth, handleLogout } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   logout: async (req, res) => {\n *     try {\n *       await handleLogout(req, res, {\n *         returnTo: 'https://example.com'\n *       });\n *     } catch (error) {\n *       console.error(error);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type HandleLogout = AuthHandler<LogoutOptions>;\n\n/**\n * The handler for the `/api/auth/logout` API route.\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type LogoutHandler = Handler<LogoutOptions>;\n\n/**\n * @ignore\n */\nexport default function handleLogoutFactory(handler: BaseHandleLogout): HandleLogout {\n  const appRouteHandler = appRouteHandlerFactory(handler);\n  const pageRouteHandler = pageRouteHandlerFactory(handler);\n\n  return getHandler<LogoutOptions>(appRouteHandler, pageRouteHandler) as HandleLogout;\n}\n\nconst appRouteHandlerFactory: (\n  handler: BaseHandleLogin\n) => (req: NextRequest, ctx: AppRouteHandlerFnContext, options?: LogoutOptions) => Promise<Response> | Response =\n  (handler) =>\n  async (req, _ctx, options = {}) => {\n    try {\n      const auth0Res = new Auth0NextResponse(new NextResponse());\n      await handler(new Auth0NextRequest(req), auth0Res, options);\n      return auth0Res.res;\n    } catch (e) {\n      throw new LogoutHandlerError(e as HandlerErrorCause);\n    }\n  };\n\nconst pageRouteHandlerFactory: (\n  handler: BaseHandleLogin\n) => (req: NextApiRequest, res: NextApiResponse, options?: LogoutOptions) => Promise<void> | void =\n  (handler) =>\n  async (req, res, options = {}) => {\n    try {\n      assertReqRes(req, res);\n      return await handler(new Auth0NextApiRequest(req), new Auth0NextApiResponse(res), options);\n    } catch (e) {\n      throw new LogoutHandlerError(e as HandlerErrorCause);\n    }\n  };\n"],"names":[],"mappings":";;;;AACA,MAAA;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AA2FA;;IAGA,SAAwB,oBAAoB,OAAyB;IACnE,MAAM,kBAAkB,uBAAuB;IAC/C,MAAM,mBAAmB,wBAAwB;IAEjD,OAAO,CAAA,GAAA,iBAAA,UAAU,EAAgB,iBAAiB;AACpD;AALA,QAAA,OAAA,GAAA;AAOA,MAAM,yBAGJ,CAAC,UACD,OAAO,KAAK,MAAM,UAAU,CAAA,CAAE;QAC5B,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,iBAAiB,CAAC,IAAI,SAAA,YAAY;YACvD,MAAM,QAAQ,IAAI,OAAA,gBAAgB,CAAC,MAAM,UAAU;YACnD,OAAO,SAAS,GAAG;UACnB,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,kBAAkB,CAAC;;IAEjC;AAEF,MAAM,0BAGJ,CAAC,UACD,OAAO,KAAK,KAAK,UAAU,CAAA,CAAE;QAC3B,IAAI;YACF,CAAA,GAAA,SAAA,YAAY,EAAC,KAAK;YAClB,OAAO,MAAM,QAAQ,IAAI,OAAA,mBAAmB,CAAC,MAAM,IAAI,OAAA,oBAAoB,CAAC,MAAM;UAClF,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,kBAAkB,CAAC;;IAEjC"}},
    {"offset": {"line": 2283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2287, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/backchannel-logout.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { HandleBackchannelLogout as BaseHandleBackchannelLogout } from '../auth0-session';\nimport { Auth0NextApiRequest, Auth0NextApiResponse, Auth0NextRequest, Auth0NextResponse } from '../http';\nimport { AppRouteHandlerFnContext, Handler, getHandler } from './router-helpers';\nimport { GetConfig } from '../config';\n\n/**\n * The handler for the POST `/api/auth/backchannel-logout` API route.\n *\n * @category Server\n */\nexport type HandleBackchannelLogout = Handler;\n\n/**\n * @ignore\n */\nexport default function handleBackchannelLogoutFactory(\n  handler: BaseHandleBackchannelLogout,\n  getConfig: GetConfig\n): HandleBackchannelLogout {\n  const appRouteHandler = appRouteHandlerFactory(handler, getConfig);\n  const pageRouteHandler = pageRouteHandlerFactory(handler, getConfig);\n\n  return getHandler(appRouteHandler, pageRouteHandler) as HandleBackchannelLogout;\n}\n\nconst appRouteHandlerFactory: (\n  handler: BaseHandleBackchannelLogout,\n  getConfig: GetConfig\n) => (req: NextRequest, ctx: AppRouteHandlerFnContext) => Promise<Response> | Response =\n  (handler, getConfig) => async (req) => {\n    try {\n      const auth0Req = new Auth0NextRequest(req);\n      const config = await getConfig(auth0Req);\n      if (!config.backchannelLogout) {\n        return new NextResponse('Back-Channel Logout is not enabled.', { status: 404 });\n      }\n      const auth0Res = new Auth0NextResponse(new NextResponse());\n      await handler(auth0Req, auth0Res);\n      return auth0Res.res;\n    } catch (e) {\n      return NextResponse.json(\n        {\n          error: e.code || 'unknown_error',\n          error_description: e.description || e.message\n        },\n        { status: 400, headers: { 'cache-control': 'no-store' } }\n      );\n    }\n  };\n\nconst pageRouteHandlerFactory: (\n  handler: BaseHandleBackchannelLogout,\n  getConfig: GetConfig\n) => (req: NextApiRequest, res: NextApiResponse) => Promise<void> | void = (handler, getConfig) => async (req, res) => {\n  try {\n    const auth0Req = new Auth0NextApiRequest(req);\n    const config = await getConfig(auth0Req);\n    if (!config.backchannelLogout) {\n      res.status(404).end('Back-Channel Logout is not enabled.');\n      return;\n    }\n    return await handler(auth0Req, new Auth0NextApiResponse(res));\n  } catch (e) {\n    res.setHeader('cache-control', 'no-store');\n    res.status(400).json({\n      error: e.code || 'unknown_error',\n      error_description: e.description || e.message\n    });\n  }\n};\n"],"names":[],"mappings":";;;;AACA,MAAA;AAEA,MAAA;AACA,MAAA;AAUA;;IAGA,SAAwB,+BACtB,OAAoC,EACpC,SAAoB;IAEpB,MAAM,kBAAkB,uBAAuB,SAAS;IACxD,MAAM,mBAAmB,wBAAwB,SAAS;IAE1D,OAAO,CAAA,GAAA,iBAAA,UAAU,EAAC,iBAAiB;AACrC;AARA,QAAA,OAAA,GAAA;AAUA,MAAM,yBAIJ,CAAC,SAAS,YAAc,OAAO;QAC7B,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,gBAAgB,CAAC;YACtC,MAAM,SAAS,MAAM,UAAU;YAC/B,IAAI,CAAC,OAAO,iBAAiB,EAAE;gBAC7B,OAAO,IAAI,SAAA,YAAY,CAAC,uCAAuC;oBAAE,QAAQ;gBAAG;;YAE9E,MAAM,WAAW,IAAI,OAAA,iBAAiB,CAAC,IAAI,SAAA,YAAY;YACvD,MAAM,QAAQ,UAAU;YACxB,OAAO,SAAS,GAAG;UACnB,OAAO,GAAG;YACV,OAAO,SAAA,YAAY,CAAC,IAAI,CACtB;gBACE,OAAO,EAAE,IAAI,IAAI;gBACjB,mBAAmB,EAAE,WAAW,IAAI,EAAE,OAAO;eAE/C;gBAAE,QAAQ;gBAAK,SAAS;oBAAE,iBAAiB;gBAAU;YAAE;;IAG7D;AAEF,MAAM,0BAGqE,CAAC,SAAS,YAAc,OAAO,KAAK;QAC7G,IAAI;YACF,MAAM,WAAW,IAAI,OAAA,mBAAmB,CAAC;YACzC,MAAM,SAAS,MAAM,UAAU;YAC/B,IAAI,CAAC,OAAO,iBAAiB,EAAE;gBAC7B,IAAI,MAAM,CAAC,KAAK,GAAG,CAAC;gBACpB;;YAEF,OAAO,MAAM,QAAQ,UAAU,IAAI,OAAA,oBAAoB,CAAC;UACxD,OAAO,GAAG;YACV,IAAI,SAAS,CAAC,iBAAiB;YAC/B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;gBACnB,OAAO,EAAE,IAAI,IAAI;gBACjB,mBAAmB,EAAE,WAAW,IAAI,EAAE,OAAO;;;IAGnD"}},
    {"offset": {"line": 2343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2347, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/session.ts"],"sourcesContent":["import * as jose from 'jose';\nimport type { TokenEndpointResponse } from '../auth0-session/client/abstract-client';\nimport { NextConfig } from '../config';\n\n/**\n * Key-value store for the user's claims.\n *\n * @category Server\n */\nexport interface Claims {\n  [key: string]: any;\n}\n\n/**\n * The user's session.\n *\n * @category Server\n */\nexport default class Session {\n  /**\n   * Any of the claims from the `id_token`.\n   */\n  user: Claims;\n\n  /**\n   * The ID token.\n   */\n  idToken?: string | undefined;\n\n  /**\n   * The access token.\n   */\n  accessToken?: string | undefined;\n\n  /**\n   * The access token scopes.\n   */\n  accessTokenScope?: string | undefined;\n\n  /**\n   * The expiration of the access token.\n   */\n  accessTokenExpiresAt?: number;\n\n  /**\n   * The refresh token, which is used to request a new access token.\n   *\n   * **IMPORTANT** You need to request the `offline_access` scope on login to get a refresh token\n   * from Auth0.\n   */\n  refreshToken?: string | undefined;\n\n  [key: string]: any;\n\n  constructor(user: Claims) {\n    this.user = user;\n  }\n}\n\n/**\n * @ignore\n */\nexport function fromTokenEndpointResponse(tokenEndpointResponse: TokenEndpointResponse, config: NextConfig): Session {\n  // Get the claims without any OIDC-specific claim.\n  const claims = jose.decodeJwt(tokenEndpointResponse.id_token as string);\n  config.identityClaimFilter.forEach((claim) => {\n    delete claims[claim];\n  });\n\n  const { id_token, access_token, scope, expires_in, expires_at, refresh_token, ...remainder } = tokenEndpointResponse;\n  const storeIDToken = config.session.storeIDToken;\n\n  return Object.assign(\n    new Session({ ...claims }),\n    {\n      accessToken: access_token,\n      accessTokenScope: scope,\n      accessTokenExpiresAt: Math.floor(Date.now() / 1000) + Number(expires_in),\n      refreshToken: refresh_token,\n      ...(storeIDToken && { idToken: id_token })\n    },\n    remainder\n  );\n}\n\n/**\n * @ignore\n */\nexport function fromJson(json: { [key: string]: any } | undefined): Session | null {\n  if (!json) {\n    return null;\n  }\n  return Object.assign(new Session({ ...json.user }), json);\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,QAAA,YAAA;AAaA;;;;IAKA,MAAqB;IAoCnB,YAAY,IAAY,CAAA;QACtB,IAAI,CAAC,IAAI,GAAG;IACd;;AAtCF,QAAA,OAAA,GAAA;AAyCA;;IAGA,SAAgB,0BAA0B,qBAA4C,EAAE,MAAkB;IACxG,kDAAkD;IAClD,MAAM,SAAS,KAAK,SAAS,CAAC,sBAAsB,QAAkB;IACtE,OAAO,mBAAmB,CAAC,OAAO,CAAC,CAAC;QAClC,OAAO,MAAM,CAAC,MAAM;IACtB;IAEA,MAAM,EAAE,QAAQ,EAAE,YAAY,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,aAAa,EAAA,GAAmB,uBAAd,YAAS,QAAA,MAAA,CAAK,uBAAzF;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;KAAsF;IAC5F,MAAM,eAAe,OAAO,OAAO,CAAC,YAAY;IAEhD,OAAO,OAAO,MAAM,CAClB,IAAI,QAAO,OAAA,MAAA,CAAA,CAAA,GAAM,UAAS,OAAA,MAAA,CAAA;QAExB,aAAa;QACb,kBAAkB;QAClB,sBAAsB,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,QAAQ,OAAO;QAC7D,cAAc;IAAa,GACvB,gBAAgB;QAAE,SAAS;IAAQ,IAEzC;AAEJ;AArBA,QAAA,yBAAA,GAAA;AAuBA;;IAGA,SAAgB,SAAS,IAAwC;IAC/D,IAAI,CAAC,MAAM;QACT,OAAO;;IAET,OAAO,OAAO,MAAM,CAAC,IAAI,QAAO,OAAA,MAAA,CAAA,CAAA,GAAM,KAAK,IAAI,IAAK;AACtD;AALA,QAAA,QAAA,GAAA"}},
    {"offset": {"line": 2400, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/get-session.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { SessionCache, Session, get } from '../session';\n\n/**\n * Get the user's session from the server.\n *\n * **In the App Router:**\n *\n * In a route handler:\n *\n * ```js\n * // app/my-api/route.js\n * import { getSession } from '@auth0/nextjs-auth0';\n *\n * export async function GET() {\n *   const { user } = await getSession();\n *   return NextResponse.json({ foo: 'bar' });\n * }\n *\n * // Or, it's slightly more efficient to use the `req`, `res` args if you're\n * // using another part of the SDK like `withApiAuthRequired` or `getAccessToken`.\n * import { getSession, withApiAuthRequired } from '@auth0/nextjs-auth0';\n *\n * const GET = withApiAuthRequired(async function GET(req) {\n *   const res = new NextResponse();\n *   const { user } = await getSession(req, res);\n *   return NextResponse.json({ foo: 'bar' }, res);\n * });\n *\n * export { GET };\n * ```\n *\n * In a page or React Server Component:\n *\n * ```js\n * // app/my-page/page.js\n * import { getSession } from '@auth0/nextjs-auth0';\n *\n * export default async function MyPage({ params, searchParams }) {\n *   const { user } = await getSession();\n *   return <h1>My Page</h1>;\n * }\n * ```\n *\n * **Note:** You can't write to the cookie in a React Server Component, so updates\n * to the session like setting the expiry of the rolling session won't be persisted.\n * For this, we recommend interacting with the session in the middleware.\n *\n * You can also get the session in a page or route in the Edge Runtime:\n *\n * ```js\n * // app/my-api/route.js\n * import { getSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export default async function MyPage({ params, searchParams }) {\n *   const { user } = await getSession();\n *   return <h1>My Page</h1>;\n * }\n *\n * export const runtime = 'edge';\n * ```\n *\n * **Note:** The Edge runtime features are only supported in the App Router.\n *\n * **In the Page Router:**\n *\n * In an API handler:\n *\n * ```js\n * // pages/api/my-api.js\n * import { getSession } from '@auth0/nextjs-auth0';\n *\n * export default async function MyApi(req, res) {\n *   const { user } = await getSession(req, res);\n *   res.status(200).json({ name: user.name });\n * }\n * ```\n *\n * In a page:\n *\n * ```js\n * // pages/my-page.js\n * import { getSession } from '@auth0/nextjs-auth0';\n *\n * export default function About() {\n *   return <div>About</div>;\n * }\n *\n * export async function getServerSideProps(ctx) {\n *   const { user } = await getSession(ctx.req, ctx.res);\n *   return { props: { foo: 'bar' } };\n * }\n * ```\n *\n * **In middleware:**\n *\n * ```js\n * import { NextResponse } from 'next/server';\n * import { getSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export async function middleware(req) {\n *   const res = new NextResponse();\n *   const { user } = await getSession(req, res);\n *   return NextResponse.redirect(new URL('/bar', request.url), res);\n * }\n *\n * export const config = {\n *   matcher: '/foo',\n * };\n *\n * @category Server\n */\nexport type GetSession = (\n  ...args: [IncomingMessage, ServerResponse] | [NextApiRequest, NextApiResponse] | [NextRequest, NextResponse] | []\n) => Promise<Session | null | undefined>;\n\n/**\n * @ignore\n */\nexport default function sessionFactory(sessionCache: SessionCache): GetSession {\n  return async (req?, res?) => {\n    const [session] = await get({ req, res, sessionCache });\n    return session;\n  };\n}\n"],"names":[],"mappings":";;;;AAGA,MAAA;AAmHA;;IAGA,SAAwB,eAAe,YAA0B;IAC/D,OAAO,OAAO,KAAM;QAClB,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;YAAE;YAAK;YAAK;QAAY;QACpD,OAAO;IACT;AACF;AALA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2422, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2426, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/array.ts"],"sourcesContent":["export function intersect(a: Array<string>, b: Array<string>): Set<string> {\n  const set1 = new Set(a);\n  const set2 = new Set(b);\n  return new Set([...set1].filter((x) => set2.has(x)));\n}\n\nexport function match(arr1: Array<string>, arr2: Array<string>): boolean {\n  const set1 = new Set(arr1);\n  const set2 = new Set(arr2);\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i += 1) {\n    const item = arr1[i];\n    if (!set2.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,UAAU,CAAgB,EAAE,CAAgB;IAC1D,MAAM,OAAO,IAAI,IAAI;IACrB,MAAM,OAAO,IAAI,IAAI;IACrB,OAAO,IAAI,IAAI;WAAI;KAAK,CAAC,MAAM,CAAC,CAAC,IAAM,KAAK,GAAG,CAAC;AAClD;AAJA,QAAA,SAAA,GAAA;AAMA,SAAgB,MAAM,IAAmB,EAAE,IAAmB;IAC5D,MAAM,OAAO,IAAI,IAAI;IACrB,MAAM,OAAO,IAAI,IAAI;IAErB,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,EAAE;QAC3B,OAAO;;IAGT,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;QACvC,MAAM,OAAO,IAAI,CAAC,EAAE;QACpB,IAAI,CAAC,KAAK,GAAG,CAAC,OAAO;YACnB,OAAO;;;IAIX,OAAO;AACT;AAhBA,QAAA,KAAA,GAAA"}},
    {"offset": {"line": 2454, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2458, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/cache.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport type { TokenEndpointResponse } from '../auth0-session';\nimport {\n  SessionCache as ISessionCache,\n  AbstractSession,\n  StatefulSession,\n  StatelessSession,\n  isLoggedOut,\n  deleteSub\n} from '../auth0-session';\nimport Session, { fromJson, fromTokenEndpointResponse } from './session';\nimport { Auth0Request, Auth0Response, NodeRequest, NodeResponse } from '../auth0-session/http';\nimport {\n  Auth0NextApiRequest,\n  Auth0NextApiResponse,\n  Auth0NextRequestCookies,\n  Auth0NextResponseCookies,\n  Auth0NextRequest,\n  Auth0NextResponse\n} from '../http';\nimport { isNextApiRequest, isRequest } from '../utils/req-helpers';\nimport { GetConfig, NextConfig } from '../config';\n\ntype Req = IncomingMessage | NextRequest | NextApiRequest;\ntype Res = ServerResponse | NextResponse | NextApiResponse;\n\nexport const getAuth0ReqRes = (req: Req, res: Res): [Auth0Request, Auth0Response] => {\n  if (isRequest(req)) {\n    return [new Auth0NextRequest(req as NextRequest), new Auth0NextResponse(res as NextResponse)];\n  }\n  if (isNextApiRequest(req)) {\n    return [new Auth0NextApiRequest(req as NextApiRequest), new Auth0NextApiResponse(res as NextApiResponse)];\n  }\n  return [new NodeRequest(req as IncomingMessage), new NodeResponse(res as ServerResponse)];\n};\n\nexport default class SessionCache implements ISessionCache<Req, Res, Session> {\n  private cache: WeakMap<Req, Session | null | undefined>;\n  private iatCache: WeakMap<Req, number | undefined>;\n  private sessionStore?: AbstractSession<Session>;\n\n  constructor(public getConfig: GetConfig) {\n    this.cache = new WeakMap();\n    this.iatCache = new WeakMap();\n  }\n\n  public getSessionStore(config: NextConfig): AbstractSession<Session> {\n    if (!this.sessionStore) {\n      this.sessionStore = config.session.store\n        ? new StatefulSession<Session>(config)\n        : new StatelessSession<Session>(config);\n    }\n    return this.sessionStore;\n  }\n\n  private async init(req: Req, res: Res, autoSave = true): Promise<void> {\n    if (!this.cache.has(req)) {\n      const [auth0Req] = getAuth0ReqRes(req, res);\n      const config = await this.getConfig(auth0Req);\n      const sessionStore = this.getSessionStore(config);\n      const [json, iat] = await sessionStore.read(auth0Req);\n      const session = fromJson(json);\n      if (session && config.backchannelLogout && (await isLoggedOut(session.user, config))) {\n        this.cache.set(req, null);\n        await this.save(req, res);\n      } else {\n        this.iatCache.set(req, iat);\n        this.cache.set(req, session);\n        if (config.session.rolling && config.session.autoSave && autoSave) {\n          await this.save(req, res);\n        }\n      }\n    }\n  }\n\n  async save(req: Req, res: Res): Promise<void> {\n    const [auth0Req, auth0Res] = getAuth0ReqRes(req, res);\n    const config = await this.getConfig(auth0Req);\n    const sessionStore = this.getSessionStore(config);\n    await sessionStore.save(auth0Req, auth0Res, this.cache.get(req), this.iatCache.get(req));\n  }\n\n  async create(req: Req, res: Res, session: Session): Promise<void> {\n    const [auth0Req] = getAuth0ReqRes(req, res);\n    const config = await this.getConfig(auth0Req);\n    if (config.backchannelLogout) {\n      await deleteSub(session.user.sub, config);\n    }\n    this.cache.set(req, session);\n    await this.save(req, res);\n  }\n\n  async delete(req: Req, res: Res): Promise<void> {\n    await this.init(req, res, false);\n    this.cache.set(req, null);\n    await this.save(req, res);\n  }\n\n  async isAuthenticated(req: Req, res: Res): Promise<boolean> {\n    await this.init(req, res);\n    const session = this.cache.get(req);\n    return !!session?.user;\n  }\n\n  async getIdToken(req: Req, res: Res): Promise<string | undefined> {\n    await this.init(req, res);\n    const session = this.cache.get(req);\n    return session?.idToken;\n  }\n\n  async set(req: Req, res: Res, session: Session | null | undefined): Promise<void> {\n    await this.init(req, res, false);\n    this.cache.set(req, session);\n    await this.save(req, res);\n  }\n\n  async get(req: Req, res: Res): Promise<Session | null | undefined> {\n    await this.init(req, res);\n    return this.cache.get(req);\n  }\n\n  async fromTokenEndpointResponse(req: Req, res: Res, tokenSet: TokenEndpointResponse): Promise<Session> {\n    const [auth0Req] = getAuth0ReqRes(req, res);\n    const config = await this.getConfig(auth0Req);\n    return fromTokenEndpointResponse(tokenSet, config);\n  }\n}\n\nexport const get = async ({\n  sessionCache,\n  req,\n  res\n}: {\n  sessionCache: SessionCache;\n  req?: Req;\n  res?: Res;\n}): Promise<[(Session | null)?, number?]> => {\n  if (req && res) {\n    return [await sessionCache.get(req, res)];\n  }\n  const auth0Req = new Auth0NextRequestCookies();\n  const config = await sessionCache.getConfig(auth0Req);\n  const sessionStore = sessionCache.getSessionStore(config);\n  const {\n    session: { rolling, autoSave }\n  } = config;\n  const [json, iat] = await sessionStore.read(auth0Req);\n  const session = fromJson(json);\n  if (session && config.backchannelLogout && (await isLoggedOut(session.user, config))) {\n    await set({ session: null, sessionCache });\n    return [];\n  } else {\n    if (rolling && autoSave) {\n      await set({ session, sessionCache, iat });\n    }\n    return [session, iat];\n  }\n};\n\nexport const set = async ({\n  session,\n  sessionCache,\n  iat,\n  req,\n  res\n}: {\n  session?: Session | null;\n  sessionCache: SessionCache;\n  iat?: number;\n  req?: Req;\n  res?: Res;\n}): Promise<void> => {\n  if (req && res) {\n    return sessionCache.set(req, res, session);\n  }\n  const auth0Req = new Auth0NextRequestCookies();\n  const config = await sessionCache.getConfig(auth0Req);\n  const sessionStore = sessionCache.getSessionStore(config);\n  await sessionStore.save(auth0Req, new Auth0NextResponseCookies(), session, iat);\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2611, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/get-access-token.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { AuthorizationParameters } from '../auth0-session';\nimport { AccessTokenError, AccessTokenErrorCode } from '../utils/errors';\nimport { intersect, match } from '../utils/array';\nimport { Session, SessionCache, fromTokenEndpointResponse, get, set } from '../session';\nimport { GetClient } from '../auth0-session/client/abstract-client';\nimport { GetConfig } from '../config';\nimport { getAuth0ReqRes } from './cache';\nimport { Auth0NextRequestCookies } from '../http';\n\n/**\n * After refresh handler for page router {@link AfterRefreshPageRoute} and app router {@link AfterRefreshAppRoute}.\n *\n * @category Server\n */\nexport type AfterRefresh = AfterRefreshPageRoute | AfterRefreshAppRoute;\n\n/**\n * After refresh handler for page router.\n *\n * @category Server\n */\nexport type AfterRefreshPageRoute = (\n  req: NextApiRequest | IncomingMessage,\n  res: NextApiResponse | ServerResponse,\n  session: Session\n) => Promise<Session> | Session;\n\n/**\n * After refresh handler for app router.\n *\n * @category Server\n */\nexport type AfterRefreshAppRoute = (session: Session) => Promise<Session> | Session;\n\n/**\n * Custom options to get an access token.\n *\n * @category Server\n */\nexport interface AccessTokenRequest {\n  /**\n   * A list of desired scopes for your access token.\n   */\n  scopes?: string[];\n\n  /**\n   * If set to `true`, a new access token will be requested with the refresh token grant, regardless of whether\n   * the access token has expired or not.\n   *\n   * **IMPORTANT** You need to request the `offline_access` scope on login to get a refresh token\n   * from Auth0.\n   */\n  refresh?: boolean;\n\n  /**\n   * When the access token request refreshes the tokens using the refresh grant the session is updated with new tokens.\n   * Use this to modify the session after it is refreshed.\n   * Usually used to keep updates in sync with the {@link AfterCallback} hook.\n   *\n   * @see also the {@link AfterRefetch} hook.\n   *\n   * @example Modify the session after refresh\n   *\n   * ```js\n   * // pages/api/my-handler.js\n   * import { getAccessToken } from '@auth0/nextjs-auth0';\n   *\n   * const afterRefresh = (req, res, session) => {\n   *   session.user.customProperty = 'foo';\n   *   delete session.idToken;\n   *   return session;\n   * };\n   *\n   * export default async function MyHandler(req, res) {\n   *   const accessToken = await getAccessToken(req, res, {\n   *     refresh: true,\n   *     afterRefresh,\n   *   });\n   * };\n   * ```\n   */\n  afterRefresh?: AfterRefresh;\n\n  /**\n   * This is useful for sending custom query parameters in the body of the refresh grant request for use in rules.\n   */\n  authorizationParams?: Partial<AuthorizationParameters>;\n}\n\n/**\n * Response from requesting an access token.\n *\n * @category Server\n */\nexport interface GetAccessTokenResult {\n  /**\n   * Access token returned from the token cache.\n   */\n  accessToken?: string | undefined;\n}\n\n/**\n * Get an access token to access an external API from the server.\n *\n * **In the App Router:**\n *\n * In a route handler:\n *\n * ```js\n * // app/my-api/route.js\n * import { NextResponse } from 'next/server';\n * import { getAccessToken } from '@auth0/nextjs-auth0';\n *\n * export async function GET() {\n *   const { accessToken } = await getAccessToken();\n *   return NextResponse.json({ foo: 'bar' });\n * }\n *\n * // Or, it's slightly more efficient to use the `req`, `res` args if you're\n * // using another part of the SDK like `withApiAuthRequired` or `getSession`.\n * import { NextResponse } from 'next/server';\n * import { getAccessToken, withApiAuthRequired } from '@auth0/nextjs-auth0';\n *\n * const GET = withApiAuthRequired(async function GET(req) {\n *   const res = new NextResponse();\n *   const { accessToken } = await getAccessToken(req, res);\n *   return NextResponse.json({ foo: 'bar' }, res);\n * });\n *\n * export { GET };\n * ```\n *\n * In a page or React Server Component:\n *\n * ```js\n * // app/my-page/page.js\n * import { getAccessToken } from '@auth0/nextjs-auth0';\n *\n * export default async function MyPage({ params, searchParams }) {\n *   const { accessToken } = await getAccessToken();\n *   return <h1>My Page</h1>;\n * }\n * ```\n *\n * **Note:** You can't write to the cookie in a React Server Component, so if\n * the access token is refreshed, it won't be persisted in the session.\n *\n * You can also get the access token in a page or route in the Edge Runtime:\n *\n * ```js\n * // app/my-api/route.js\n * import { NextResponse } from 'next/server';\n * import { getAccessToken } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export async function GET() {\n *   const { accessToken } = await getAccessToken();\n *   return NextResponse.json({ foo: 'bar' });\n * }\n *\n * export const runtime = 'edge';\n * ```\n *\n * **Note:** The Edge runtime features are only supported in the App Router.\n *\n * **In the Page Router:**\n *\n * In an API handler:\n *\n * ```js\n * // pages/api/my-api.js\n * import { getAccessToken } from '@auth0/nextjs-auth0';\n *\n * export default async function MyApi(req, res) {\n *   const { accessToken } = await getAccessToken(req, res);\n *   res.status(200).json({ name: 'John Doe' });\n * }\n * ```\n *\n * In a page:\n *\n * ```js\n * // pages/my-page.js\n * import { getAccessToken } from '@auth0/nextjs-auth0';\n *\n * export default function About() {\n *   return <div>About</div>;\n * }\n *\n * export async function getServerSideProps(ctx) {\n *   const { accessToken } = await getAccessToken(ctx.req, ctx.res);\n *   return { props: { foo: 'bar' } };\n * }\n * ```\n *\n * **In middleware:**\n *\n * ```js\n * import { NextResponse } from 'next/server';\n * import { getAccessToken } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n\n *\n * export async function middleware(req) {\n *   const res = new NextResponse();\n *   const { accessToken } = await getAccessToken(req, res);\n *   return NextResponse.redirect(new URL('/bar', request.url), res);\n * }\n *\n * export const config = {\n *   matcher: '/foo',\n * };\n * ```\n *\n * @throws {@link AccessTokenError}\n *\n * @category Server\n */\nexport type GetAccessToken = (\n  ...args:\n    | [IncomingMessage, ServerResponse, AccessTokenRequest?]\n    | [NextApiRequest, NextApiResponse, AccessTokenRequest?]\n    | [NextRequest, NextResponse, AccessTokenRequest?]\n    | [AccessTokenRequest?]\n) => Promise<GetAccessTokenResult>;\n\n/**\n * @ignore\n */\nexport default function accessTokenFactory(\n  getConfig: GetConfig,\n  getClient: GetClient,\n  sessionCache: SessionCache\n): GetAccessToken {\n  return async (reqOrOpts?, res?, accessTokenRequest?): Promise<GetAccessTokenResult> => {\n    const options = (res ? accessTokenRequest : reqOrOpts) as AccessTokenRequest | undefined;\n    const req = (res ? reqOrOpts : undefined) as IncomingMessage | NextApiRequest | undefined;\n    const config = await getConfig(req ? getAuth0ReqRes(req, res as any)[0] : new Auth0NextRequestCookies());\n    const client = await getClient(config);\n\n    const parts = await get({ sessionCache, req, res });\n    let [session] = parts;\n    const [, iat] = parts;\n    if (!session) {\n      throw new AccessTokenError(AccessTokenErrorCode.MISSING_SESSION, 'The user does not have a valid session.');\n    }\n\n    if (!session.accessToken && !session.refreshToken) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.MISSING_ACCESS_TOKEN,\n        'The user does not have a valid access token.'\n      );\n    }\n\n    if (!session.accessTokenExpiresAt) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.EXPIRED_ACCESS_TOKEN,\n        'Expiration information for the access token is not available. The user will need to sign in again.'\n      );\n    }\n\n    if (options && options.scopes) {\n      const persistedScopes = session.accessTokenScope;\n      if (!persistedScopes || persistedScopes.length === 0) {\n        throw new AccessTokenError(\n          AccessTokenErrorCode.INSUFFICIENT_SCOPE,\n          'An access token with the requested scopes could not be provided. The user will need to sign in again.'\n        );\n      }\n\n      const matchingScopes = intersect(options.scopes, persistedScopes.split(' '));\n      if (!match(options.scopes, [...matchingScopes])) {\n        throw new AccessTokenError(\n          AccessTokenErrorCode.INSUFFICIENT_SCOPE,\n          `Could not retrieve an access token with scopes \"${options.scopes.join(\n            ' '\n          )}\". The user will need to sign in again.`\n        );\n      }\n    }\n\n    // Check if the token has expired.\n    // There is an edge case where we might have some clock skew where our code assumes the token is still valid.\n    // Adding a skew of 1 minute to compensate.\n    if (!session.refreshToken && session.accessTokenExpiresAt * 1000 - 60000 < Date.now()) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.EXPIRED_ACCESS_TOKEN,\n        'The access token expired and a refresh token is not available. The user will need to sign in again.'\n      );\n    }\n\n    if (options?.refresh && !session.refreshToken) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.MISSING_REFRESH_TOKEN,\n        'A refresh token is required to refresh the access token, but none is present.'\n      );\n    }\n\n    // Check if the token has expired.\n    // There is an edge case where we might have some clock skew where our code assumes the token is still valid.\n    // Adding a skew of 1 minute to compensate.\n    if (\n      (session.refreshToken && session.accessTokenExpiresAt * 1000 - 60000 < Date.now()) ||\n      (session.refreshToken && options && options.refresh)\n    ) {\n      const tokenSet = await client.refresh(session.refreshToken, {\n        exchangeBody: options?.authorizationParams\n      });\n\n      // Update the session.\n      const newSession = fromTokenEndpointResponse(tokenSet, config);\n      Object.assign(session, {\n        ...newSession,\n        refreshToken: newSession.refreshToken || session.refreshToken,\n        user: { ...session.user, ...newSession.user }\n      });\n\n      if (options?.afterRefresh) {\n        if (req) {\n          session = await (options.afterRefresh as AfterRefreshPageRoute)(\n            req,\n            res as NextApiResponse | ServerResponse,\n            session\n          );\n        } else {\n          session = await (options.afterRefresh as AfterRefreshAppRoute)(session);\n        }\n      }\n\n      await set({ sessionCache, req, res, session, iat });\n\n      // Return the new access token.\n      return {\n        accessToken: tokenSet.access_token\n      };\n    }\n\n    // We don't have an access token.\n    if (!session.accessToken) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.MISSING_ACCESS_TOKEN,\n        'The user does not have a valid access token.'\n      );\n    }\n\n    // The access token is not expired and has sufficient scopes.\n    return {\n      accessToken: session.accessToken\n    };\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2708, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/touch-session.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { get, set, SessionCache } from '../session';\n\n/**\n * Touch the session object. If rolling sessions are enabled and autoSave is disabled, you will need\n * to call this method to update the session expiry.\n *\n * **In the App Router:**\n *\n * In a route handler:\n *\n * ```js\n * // app/my-api/route.js\n * import { touchSession } from '@auth0/nextjs-auth0';\n *\n * export async function GET() {\n *   await touchSession();\n *   return NextResponse.json({ foo: 'bar' });\n * }\n *\n * // Or, it's slightly more efficient to use the `req`, `res` args if you're\n * // using another part of the SDK like `withApiAuthRequired` or `getSession`.\n * import { touchSession, withApiAuthRequired } from '@auth0/nextjs-auth0';\n *\n * const GET = withApiAuthRequired(async function GET(req) {\n *   const res = new NextResponse();\n *   await touchSession(req, res);\n *   return NextResponse.json({ foo: 'bar' }, res);\n * });\n *\n * export { GET };\n * ```\n *\n * In a page or React Server Component:\n *\n * ```js\n * // app/my-page/page.js\n * import { touchSession } from '@auth0/nextjs-auth0';\n *\n * export default async function MyPage({ params, searchParams }) {\n *   await touchSession();\n *   return <h1>My Page</h1>;\n * }\n * ```\n *\n * **Note:** You can't write to the cookie in a React Server Component, so updates\n * to the session like setting the expiry of the rolling session won't be persisted.\n * For this, we recommend interacting with the session in the middleware.\n *\n * You can also touch the session in a page or route in the Edge Runtime:\n *\n * ```js\n * // app/my-api/route.js\n * import { getSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export default async function MyPage({ params, searchParams }) {\n *   await touchSession();\n *   return <h1>My Page</h1>;\n * }\n *\n * export const runtime = 'edge';\n * ```\n *\n * **Note:** The Edge runtime features are only supported in the App Router.\n *\n * **In the Page Router:**\n *\n * In an API handler:\n *\n * ```js\n * // pages/api/my-api.js\n * import { touchSession } from '@auth0/nextjs-auth0';\n *\n * export default async function MyApi(req, res) {\n *   await touchSession(req, res);\n *   res.status(200).json({ name: user.name });\n * }\n * ```\n *\n * In a page:\n *\n * ```js\n * // pages/my-page.js\n * import { touchSession } from '@auth0/nextjs-auth0';\n *\n * export default function About() {\n *   return <div>About</div>;\n * }\n *\n * export async function getServerSideProps(ctx) {\n *   await touchSession(ctx.req, ctx.res);\n *   return { props: { foo: 'bar' } };\n * }\n * ```\n *\n * **In middleware:**\n *\n * ```js\n * import { NextResponse } from 'next/server';\n * import { touchSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export async function middleware(req) {\n *   const res = new NextResponse();\n *   await touchSession(req, res);\n *   return NextResponse.redirect(new URL('/bar', request.url), res);\n * }\n *\n * export const config = {\n *   matcher: '/foo',\n * };\n *\n * @category Server\n */\nexport type TouchSession = (\n  ...args: [IncomingMessage, ServerResponse] | [NextApiRequest, NextApiResponse] | [NextRequest, NextResponse] | []\n) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function touchSessionFactory(sessionCache: SessionCache): TouchSession {\n  return async (req?, res?) => {\n    const [session, iat] = await get({ sessionCache, req, res });\n    if (!session) {\n      return;\n    }\n    await set({ req, res, session, sessionCache, iat });\n  };\n}\n"],"names":[],"mappings":";;;;AAGA,MAAA;AAoHA;;IAGA,SAAwB,oBAAoB,YAA0B;IACpE,OAAO,OAAO,KAAM;QAClB,MAAM,CAAC,SAAS,IAAI,GAAG,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;YAAE;YAAc;YAAK;QAAG;QACzD,IAAI,CAAC,SAAS;YACZ;;QAEF,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;YAAE;YAAK;YAAK;YAAS;YAAc;QAAG;IAClD;AACF;AARA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2739, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2743, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/update-session.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from 'http';\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { get, set, Session, SessionCache } from '../session';\n\n/**\n * Update the session object. The provided `session` object will replace the existing session.\n *\n * **Note** you can't use this method to login or logout - you should use the login and logout handlers for this.\n * If no session is provided, it doesn't contain a user or the user is not authenticated; this is a no-op.\n *\n * **In the App Router:**\n *\n * In a route handler:\n *\n * ```js\n * // app/my-api/route.js\n * import { getSession, updateSession } from '@auth0/nextjs-auth0';\n *\n * export async function GET() {\n *   const { user } = await getSession();\n *   await updateSession({ ...session, user: { ...session.user, foo: 'bar' }});\n *   return NextResponse.json({ foo: 'bar' });\n * }\n *\n * // Or, it's slightly more efficient to use the `req`, `res` args if you're\n * // using another part of the SDK like `withApiAuthRequired` or `getSession`.\n * import { getSession, updateSession, withApiAuthRequired } from '@auth0/nextjs-auth0';\n *\n * const GET = withApiAuthRequired(async function GET(req) {\n *   const res = new NextResponse();\n *   const { user } = await getSession(req, res);\n *   await updateSession(req, res, { ...session, user: { ...session.user, foo: 'bar' }});\n *   return NextResponse.json({ foo: 'bar' }, res);\n * });\n *\n * export { GET };\n * ```\n *\n * In a Server Action in a page or React Server Component:\n *\n * ```js\n * // app/my-page/page.js\n * import { getSession, updateSession } from '@auth0/nextjs-auth0';\n *\n * export default async function Page() {\n *   async function updateUser(updates) {\n *     'use server';\n *     const { user } = await getSession();\n *     await updateSession(req, res, { ...session, user: { ...session.user, ...updates }});\n *   }\n *   return (\n *     <form action={updateUser}>\n *       <button type=\"submit\">Update User</button>\n *     </form>\n *   );\n * }\n * ```\n *\n * **Note:** You can't write to the cookie in a React Server Component, so updates\n * to the session would need to happen in a Server Action.\n * More info on Server Actions https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions\n *\n * You can also update the session in a page or route in the Edge Runtime:\n *\n * ```js\n * // app/my-page/page.js\n * import { getSession, updateSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export default async function Page() {\n *   async function updateUser(updates) {\n *     'use server';\n *     const { user } = await getSession();\n *     await updateSession(req, res, { ...session, user: { ...session.user, ...updates }});\n *   }\n *   return (\n *     <form action={updateUser}>\n *       <button type=\"submit\">Update User</button>\n *     </form>\n *   );\n * }\n * export const runtime = 'edge';\n * ```\n *\n * **Note:** The Edge runtime features are only supported in the App Router.\n *\n * **In the Page Router:**\n *\n * In an API handler:\n *\n * ```js\n * // pages/api/my-api.js\n * import { getSession, updateSession } from '@auth0/nextjs-auth0';\n *\n * export default async function MyApi(req, res) {\n *   const { user } = await getSession(req, res);\n *   await updateSession(req, res, { ...session, user: { ...session.user, foo: 'bar' }});\n *   res.status(200).json({ name: user.name });\n * }\n * ```\n *\n * In a page:\n *\n * ```js\n * // pages/my-page.js\n * import { getSession, updateSession } from '@auth0/nextjs-auth0';\n *\n * export default function About() {\n *   return <div>About</div>;\n * }\n *\n * export async function getServerSideProps(ctx) {\n *   const { user } = await getSession(ctx.req, ctx.res);\n *   await updateSession(req, res, { ...session, user: { ...session.user, foo: 'bar' }});\n *   return { props: { foo: 'bar' } };\n * }\n * ```\n *\n * **In middleware:**\n *\n * ```js\n * import { NextResponse } from 'next/server';\n * import { getSession, updateSession } from '@auth0/nextjs-auth0/edge'; // Note the /edge import\n *\n * export async function middleware(req) {\n *   const res = new NextResponse();\n *   const { user } = await getSession(req, res);\n *   await updateSession(req, res, { ...session, user: { ...session.user, foo: 'bar' }});\n *   return NextResponse.redirect(new URL('/bar', request.url), res);\n * }\n *\n * // See \"Matching Paths\" below to learn more\n * export const config = {\n *   matcher: '/foo',\n * };\n *\n * @category Server\n */\nexport type UpdateSession = (\n  ...args:\n    | [IncomingMessage, ServerResponse, Session]\n    | [NextApiRequest, NextApiResponse, Session]\n    | [NextRequest, NextResponse, Session]\n    | [Session]\n) => Promise<void>;\n\n/**\n * @ignore\n */\nexport default function updateSessionFactory(sessionCache: SessionCache): UpdateSession {\n  return async (reqOrSession, res?, newSession?) => {\n    const session = (res ? newSession : reqOrSession) as Session | undefined;\n    const req = (res ? reqOrSession : undefined) as IncomingMessage | NextApiRequest | NextRequest | undefined;\n\n    const [prevSession, iat] = await get({ sessionCache, req, res });\n    if (!prevSession || !session || !session.user) {\n      return;\n    }\n    await set({ req, res, session, sessionCache, iat });\n  };\n}\n"],"names":[],"mappings":";;;;AAGA,MAAA;AA+IA;;IAGA,SAAwB,qBAAqB,YAA0B;IACrE,OAAO,OAAO,cAAc,KAAM;QAChC,MAAM,UAAW,MAAM,aAAa;QACpC,MAAM,MAAO,MAAM,eAAe;QAElC,MAAM,CAAC,aAAa,IAAI,GAAG,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;YAAE;YAAc;YAAK;QAAG;QAC7D,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;YAC7C;;QAEF,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;YAAE;YAAK;YAAK;YAAS;YAAc;QAAG;IAClD;AACF;AAXA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2772, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2776, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/session/index.ts"],"sourcesContent":["export { default as Session, Claims, fromJson, fromTokenEndpointResponse } from './session';\nexport { default as sessionFactory, GetSession } from './get-session';\nexport {\n  default as accessTokenFactory,\n  GetAccessToken,\n  AccessTokenRequest,\n  GetAccessTokenResult,\n  AfterRefresh,\n  AfterRefreshPageRoute,\n  AfterRefreshAppRoute\n} from './get-access-token';\nexport { default as SessionCache, get, set } from './cache';\nexport { default as touchSessionFactory, TouchSession } from './touch-session';\nexport { default as updateSessionFactory, UpdateSession } from './update-session';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,WAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,WAAA,OAAO;IAAA;AAAA;AAAqB,OAAA,cAAA,CAAA,SAAA,YAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,QAAQ;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,6BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,yBAAyB;IAAA;AAAA;AACxE,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,eAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,sBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,oBAAA,OAAO;IAAA;AAAA;AAQT,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,SAAA,OAAO;IAAA;AAAA;AAAkB,OAAA,cAAA,CAAA,SAAA,OAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,QAAA,GAAG;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,OAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,QAAA,GAAG;IAAA;AAAA;AAC1C,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,uBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,iBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,kBAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2856, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/profile.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { SessionCache, Session, fromJson, GetAccessToken } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { ProfileHandlerError, HandlerErrorCause } from '../utils/errors';\nimport { AppRouteHandlerFnContext, AuthHandler, getHandler, Handler, OptionsProvider } from './router-helpers';\nimport { GetClient } from '../auth0-session/client/abstract-client';\nimport { GetConfig } from '../config';\nimport { Auth0NextApiRequest, Auth0NextRequest } from '../http';\n\n/**\n * After refetch handler for page router {@link AfterRefetchPageRoute} and app router {@link AfterRefetchAppRoute}.\n *\n * @category Server\n */\nexport type AfterRefetch = AfterRefetchPageRoute | AfterRefetchAppRoute;\n\n/**\n * After refetch handler for page router.\n *\n * @category Server\n */\nexport type AfterRefetchPageRoute = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  session: Session\n) => Promise<Session> | Session;\n\n/**\n * After refetch handler for app router.\n *\n * @category Server\n */\nexport type AfterRefetchAppRoute = (req: NextRequest, session: Session) => Promise<Session> | Session;\n\n/**\n * Options to customize the profile handler.\n *\n * @see {@link HandleProfile}\n *\n * @category Server\n */\nexport type ProfileOptions = {\n  /**\n   * If set to `true` this will refetch the user profile information from `/userinfo` and save it\n   * to the session.\n   */\n  refetch?: boolean;\n\n  /**\n   * Like {@link AfterCallback}  and {@link AfterRefresh} when a session is created, you can use\n   * this function to validate or add/remove claims after the session is updated. Will only run if\n   * {@link ProfileOptions.refetch} is `true`.\n   */\n  afterRefetch?: AfterRefetch;\n};\n\n/**\n * Options provider for the default profile handler.\n * Use this to generate options that depend on values from the request.\n *\n * @category Server\n */\nexport type ProfileOptionsProvider = OptionsProvider<ProfileOptions>;\n\n/**\n * Use this to customize the default profile handler without overriding it.\n * You can still override the handler if needed.\n *\n * @example Pass an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleProfile } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   profile: handleProfile({ refetch: true })\n * });\n * ```\n *\n * @example Pass a function that receives the request and returns an options object\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleProfile } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   profile: handleProfile((req) => {\n *     return { refetch: true };\n *   })\n * });\n * ```\n *\n * This is useful for generating options that depend on values from the request.\n *\n * @example Override the profile handler\n *\n * ```js\n * import { handleAuth, handleProfile } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   profile: async (req, res) => {\n *     try {\n *       await handleProfile(req, res, { refetch: true });\n *     } catch (error) {\n *       console.error(error);\n *     }\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type HandleProfile = AuthHandler<ProfileOptions>;\n\n/**\n * The handler for the `/api/auth/me` API route.\n *\n * @throws {@link HandlerError}\n *\n * @category Server\n */\nexport type ProfileHandler = Handler<ProfileOptions>;\n\n/**\n * @ignore\n */\nexport default function profileHandler(\n  getConfig: GetConfig,\n  getClient: GetClient,\n  getAccessToken: GetAccessToken,\n  sessionCache: SessionCache\n): HandleProfile {\n  const appRouteHandler = appRouteHandlerFactory(getConfig, getClient, getAccessToken, sessionCache);\n  const pageRouteHandler = pageRouteHandlerFactory(getConfig, getClient, getAccessToken, sessionCache);\n\n  return getHandler<ProfileOptions>(appRouteHandler, pageRouteHandler) as HandleProfile;\n}\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory: (\n  getConfig: GetConfig,\n  getClient: GetClient,\n  getAccessToken: GetAccessToken,\n  sessionCache: SessionCache\n) => (req: NextRequest, ctx: AppRouteHandlerFnContext, options?: ProfileOptions) => Promise<Response> | Response =\n  (getConfig, getClient, getAccessToken, sessionCache) =>\n  async (req, _ctx, options = {}) => {\n    try {\n      const config = await getConfig(new Auth0NextRequest(req));\n      const client = await getClient(config);\n      const res = new NextResponse();\n\n      if (!(await sessionCache.isAuthenticated(req, res))) {\n        const emptyRes = new NextResponse(null, { status: 204 });\n        res.headers.forEach((val, key) => emptyRes.headers.set(key, val));\n        return emptyRes;\n      }\n\n      const session = (await sessionCache.get(req, res)) as Session;\n      res.headers.set('Cache-Control', 'no-store');\n\n      if (options.refetch) {\n        const { accessToken } = await getAccessToken(req, res);\n        if (!accessToken) {\n          throw new Error('No access token available to refetch the profile');\n        }\n\n        const userInfo = await client.userinfo(accessToken);\n\n        let newSession = fromJson({\n          ...session,\n          user: {\n            ...session.user,\n            ...userInfo\n          }\n        }) as Session;\n\n        if (options.afterRefetch) {\n          newSession = await (options.afterRefetch as AfterRefetchAppRoute)(req, newSession);\n        }\n\n        await sessionCache.set(req, res, newSession);\n\n        return NextResponse.json(newSession.user, res);\n      }\n\n      return NextResponse.json(session.user, res);\n    } catch (e) {\n      throw new ProfileHandlerError(e as HandlerErrorCause);\n    }\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory: (\n  getConfig: GetConfig,\n  getClient: GetClient,\n  getAccessToken: GetAccessToken,\n  sessionCache: SessionCache\n) => (req: NextApiRequest, res: NextApiResponse, options?: ProfileOptions) => Promise<void> =\n  (getConfig, getClient, getAccessToken, sessionCache) =>\n  async (req: NextApiRequest, res: NextApiResponse, options = {}): Promise<void> => {\n    try {\n      assertReqRes(req, res);\n      const config = await getConfig(new Auth0NextApiRequest(req));\n      const client = await getClient(config);\n\n      if (!(await sessionCache.isAuthenticated(req, res))) {\n        res.status(204).end();\n        return;\n      }\n\n      const session = (await sessionCache.get(req, res)) as Session;\n      res.setHeader('Cache-Control', 'no-store');\n\n      if (options.refetch) {\n        const { accessToken } = await getAccessToken(req, res);\n        if (!accessToken) {\n          throw new Error('No access token available to refetch the profile');\n        }\n\n        const userInfo = await client.userinfo(accessToken);\n\n        let newSession = fromJson({\n          ...session,\n          user: {\n            ...session.user,\n            ...userInfo\n          }\n        }) as Session;\n\n        if (options.afterRefetch) {\n          newSession = await (options.afterRefetch as AfterRefetchPageRoute)(req, res, newSession);\n        }\n\n        await sessionCache.set(req, res, newSession);\n\n        res.json(newSession.user);\n        return;\n      }\n\n      res.json(session.user);\n    } catch (e) {\n      throw new ProfileHandlerError(e as HandlerErrorCause);\n    }\n  };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2944, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2948, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/auth.ts"],"sourcesContent":["import { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';\nimport { NextRequest } from 'next/server';\nimport { HandleLogin } from './login';\nimport { HandleLogout } from './logout';\nimport { HandleCallback } from './callback';\nimport { HandleBackchannelLogout } from './backchannel-logout';\nimport { HandleProfile } from './profile';\nimport { HandlerError } from '../utils/errors';\nimport {\n  AppRouteHandlerFn,\n  AppRouteHandlerFnContext,\n  NextAppRouterHandler,\n  NextPageRouterHandler\n} from './router-helpers';\nimport { isRequest } from '../utils/req-helpers';\n\n/**\n * If you want to add some custom behavior to the default auth handlers, you can pass in custom handlers for\n * `login`, `logout`, `callback`, and `profile`. For example:\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n * import { errorReporter, logger } from '../../../utils';\n *\n * export default handleAuth({\n *   async login(req, res) {\n *     try {\n *        // Pass in custom params to your handler\n *       await handleLogin(req, res, { authorizationParams: { customParam: 'foo' } });\n *       // Add your own custom logging.\n *       logger('Redirecting to login');\n *     } catch (error) {\n *       // Add you own custom error logging.\n *       errorReporter(error);\n *       res.status(error.status || 500).end();\n *     }\n *   }\n * });\n * ```\n *\n * Alternatively, you can customize the default handlers without overriding them. For example:\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   login: handleLogin({\n *     authorizationParams: { customParam: 'foo' } // Pass in custom params\n *   })\n * });\n * ```\n *\n * You can also create new handlers by customizing the default ones. For example:\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth, handleLogin } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth({\n *   signup: handleLogin({\n *     authorizationParams: { screen_hint: 'signup' }\n *   })\n * });\n * ```\n *\n * @category Server\n */\nexport type Handlers = ApiHandlers | ErrorHandlers;\n\n/**\n * @ignore\n */\ntype ApiHandlers = { [key: string]: NextPageRouterHandler | NextAppRouterHandler };\n\n/**\n * @ignore\n */\ntype ErrorHandlers = {\n  onError?: PageRouterOnError | AppRouterOnError;\n};\n\n/**\n * The main way to use the server SDK.\n *\n * *Page Router*\n *\n * Simply set the environment variables per {@link ConfigParameters} then create the file\n * `pages/api/auth/[auth0].js`. For example:\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth } from '@auth0/nextjs-auth0';\n *\n * export default handleAuth();\n * ```\n\n * *App Router*\n *\n * Simply set the environment variables per {@link ConfigParameters} then create the file\n * `app/api/auth/[auth0]/route.js`. For example:\n *\n * ```js\n * // app/api/auth/[auth0]/route.js\n * import { handleAuth } from '@auth0/nextjs-auth0';\n *\n * export const GET = handleAuth();\n * ```\n *\n * This will create 5 handlers for the following urls:\n *\n * - `/api/auth/login`: log the user in to your app by redirecting them to your identity provider.\n * - `/api/auth/callback`: The page that your identity provider will redirect the user back to on login.\n * - `/api/auth/logout`: log the user out of your app.\n * - `/api/auth/me`: View the user profile JSON (used by the {@link UseUser} hook).\n *\n * @category Server\n */\n// any is required for app router ts check\nexport type HandleAuth = (userHandlers?: Handlers) => NextApiHandler | AppRouteHandlerFn | any;\n\n/**\n * Error handler for the default auth routes.\n *\n * Use this to define an error handler for all the default routes in a single place. For example:\n *\n * ```js\n * export default handleAuth({\n *   onError(req, res, error) {\n *     errorLogger(error);\n *     // You can finish the response yourself if you want to customize\n *     // the status code or redirect the user\n *     // res.writeHead(302, {\n *     //     Location: '/custom-error-page'\n *     // });\n *     // res.end();\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type PageRouterOnError = (\n  req: NextApiRequest,\n  res: NextApiResponse,\n  error: HandlerError\n) => Promise<void> | void;\nexport type AppRouterOnError = (req: NextRequest, error: HandlerError) => Promise<Response | void> | Response | void;\n\n/**\n * @ignore\n */\nconst defaultPageRouterOnError: PageRouterOnError = (_req, res, error) => {\n  console.error(error);\n  res.status(error.status || 500).end();\n};\n\n/**\n * @ignore\n */\nconst defaultAppRouterOnError: AppRouterOnError = (_req, error) => {\n  console.error(error);\n};\n\n/**\n * @ignore\n */\nexport default function handlerFactory({\n  handleLogin,\n  handleLogout,\n  handleCallback,\n  handleProfile,\n  handleBackchannelLogout\n}: {\n  handleLogin: HandleLogin;\n  handleLogout: HandleLogout;\n  handleCallback: HandleCallback;\n  handleProfile: HandleProfile;\n  handleBackchannelLogout: HandleBackchannelLogout;\n}): HandleAuth {\n  return ({ onError, ...handlers }: Handlers = {}): NextApiHandler<void> | AppRouteHandlerFn => {\n    const customHandlers: ApiHandlers = {\n      login: handleLogin,\n      logout: handleLogout,\n      callback: handleCallback,\n      'backchannel-logout': handleBackchannelLogout,\n      me: (handlers as ApiHandlers).profile || handleProfile,\n      ...handlers\n    };\n\n    const appRouteHandler = appRouteHandlerFactory(customHandlers, onError as AppRouterOnError);\n    const pageRouteHandler = pageRouteHandlerFactory(customHandlers, onError as PageRouterOnError);\n\n    return (req: NextRequest | NextApiRequest, resOrCtx: NextApiResponse | AppRouteHandlerFnContext) => {\n      if (isRequest(req)) {\n        return appRouteHandler(req as NextRequest, resOrCtx as AppRouteHandlerFnContext);\n      }\n      return pageRouteHandler(req as NextApiRequest, resOrCtx as NextApiResponse);\n    };\n  };\n}\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory: (customHandlers: ApiHandlers, onError?: AppRouterOnError) => AppRouteHandlerFn =\n  (customHandlers, onError) => async (req: NextRequest, ctx) => {\n    const { params } = ctx;\n    let route = params.auth0;\n\n    if (Array.isArray(route)) {\n      let otherRoutes;\n      [route, ...otherRoutes] = route;\n      if (otherRoutes.length) {\n        return new Response(null, { status: 404 });\n      }\n    }\n\n    const handler = route && customHandlers.hasOwnProperty(route) && customHandlers[route];\n    try {\n      if (handler) {\n        return await (handler as AppRouteHandlerFn)(req, ctx);\n      } else {\n        return new Response(null, { status: 404 });\n      }\n    } catch (error) {\n      const res = await (onError || defaultAppRouterOnError)(req, error as HandlerError);\n      return res || new Response(null, { status: error.status || 500 });\n    }\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory: (customHandlers: ApiHandlers, onError?: PageRouterOnError) => NextApiHandler =\n  (customHandlers, onError) =>\n  async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {\n    let {\n      query: { auth0: route }\n    } = req;\n\n    if (Array.isArray(route)) {\n      let otherRoutes;\n      [route, ...otherRoutes] = route;\n      if (otherRoutes.length) {\n        res.status(404).end();\n        return;\n      }\n    }\n\n    try {\n      const handler = route && customHandlers.hasOwnProperty(route) && customHandlers[route];\n      if (handler) {\n        await (handler as NextApiHandler)(req, res);\n      } else {\n        res.status(404).end();\n      }\n    } catch (error) {\n      await (onError || defaultPageRouterOnError)(req, res, error as HandlerError);\n      if (!res.writableEnded) {\n        // 200 is the default, so we assume it has not been set in the custom error handler if it equals 200\n        res.status(res.statusCode === 200 ? 500 : res.statusCode).end();\n      }\n    }\n  };\n"],"names":[],"mappings":";;;;;AAcA,MAAA;AAwIA;;IAGA,MAAM,2BAA8C,CAAC,MAAM,KAAK;IAC9D,QAAQ,KAAK,CAAC;IACd,IAAI,MAAM,CAAC,MAAM,MAAM,IAAI,KAAK,GAAG;AACrC;AAEA;;IAGA,MAAM,0BAA4C,CAAC,MAAM;IACvD,QAAQ,KAAK,CAAC;AAChB;AAEA;;IAGA,SAAwB,eAAe,EACrC,WAAW,EACX,YAAY,EACZ,cAAc,EACd,aAAa,EACb,uBAAuB,EAOxB;IACC,OAAO,CAAC,KAAqC,CAAA,CAAE;YAAvC,EAAE,OAAO,EAAA,GAAA,IAAK,WAAQ,QAAA,MAAA,CAAA,IAAtB;YAAA;SAAwB;QAC9B,MAAM,iBAAc,OAAA,MAAA,CAAA;YAClB,OAAO;YACP,QAAQ;YACR,UAAU;YACV,sBAAsB;YACtB,IAAK,SAAyB,OAAO,IAAI;QAAa,GACnD;QAGL,MAAM,kBAAkB,uBAAuB,gBAAgB;QAC/D,MAAM,mBAAmB,wBAAwB,gBAAgB;QAEjE,OAAO,CAAC,KAAmC;YACzC,IAAI,CAAA,GAAA,cAAA,SAAS,EAAC,MAAM;gBAClB,OAAO,gBAAgB,KAAoB;;YAE7C,OAAO,iBAAiB,KAAuB;QACjD;IACF;AACF;AAjCA,QAAA,OAAA,GAAA;AAmCA;;IAGA,MAAM,yBACJ,CAAC,gBAAgB,UAAY,OAAO,KAAkB;QACpD,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,IAAI,QAAQ,OAAO,KAAK;QAExB,IAAI,MAAM,OAAO,CAAC,QAAQ;YACxB,IAAI;YACJ,CAAC,OAAO,GAAG,YAAY,GAAG;YAC1B,IAAI,YAAY,MAAM,EAAE;gBACtB,OAAO,IAAI,SAAS,MAAM;oBAAE,QAAQ;gBAAG;;;QAI3C,MAAM,UAAU,SAAS,eAAe,cAAc,CAAC,UAAU,cAAc,CAAC,MAAM;QACtF,IAAI;YACF,IAAI,SAAS;gBACX,OAAO,MAAO,QAA8B,KAAK;mBAC5C;gBACL,OAAO,IAAI,SAAS,MAAM;oBAAE,QAAQ;gBAAG;;UAEzC,OAAO,OAAO;YACd,MAAM,MAAM,MAAM,CAAC,WAAW,uBAAuB,EAAE,KAAK;YAC5D,OAAO,OAAO,IAAI,SAAS,MAAM;gBAAE,QAAQ,MAAM,MAAM,IAAI;YAAG;;IAElE;AAEF;;IAGA,MAAM,0BACJ,CAAC,gBAAgB,UACjB,OAAO,KAAqB;QAC1B,IAAI,EACF,OAAO,EAAE,OAAO,KAAK,EAAE,EACxB,GAAG;QAEJ,IAAI,MAAM,OAAO,CAAC,QAAQ;YACxB,IAAI;YACJ,CAAC,OAAO,GAAG,YAAY,GAAG;YAC1B,IAAI,YAAY,MAAM,EAAE;gBACtB,IAAI,MAAM,CAAC,KAAK,GAAG;gBACnB;;;QAIJ,IAAI;YACF,MAAM,UAAU,SAAS,eAAe,cAAc,CAAC,UAAU,cAAc,CAAC,MAAM;YACtF,IAAI,SAAS;gBACX,MAAO,QAA2B,KAAK;mBAClC;gBACL,IAAI,MAAM,CAAC,KAAK,GAAG;;UAErB,OAAO,OAAO;YACd,MAAM,CAAC,WAAW,wBAAwB,EAAE,KAAK,KAAK;YACtD,IAAI,CAAC,IAAI,aAAa,EAAE;gBACtB,oGAAoG;gBACpG,IAAI,MAAM,CAAC,IAAI,UAAU,KAAK,MAAM,MAAM,IAAI,UAAU,EAAE,GAAG;;;IAGnE"}},
    {"offset": {"line": 3047, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3051, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/handlers/index.ts"],"sourcesContent":["export {\n  default as callbackHandler,\n  HandleCallback,\n  CallbackOptions,\n  AfterCallback,\n  AfterCallbackPageRoute,\n  AfterCallbackAppRoute\n} from './callback';\nexport {\n  default as loginHandler,\n  HandleLogin,\n  LoginOptions,\n  GetLoginState,\n  GetLoginStatePageRoute,\n  GetLoginStateAppRoute\n} from './login';\nexport { default as logoutHandler, HandleLogout, LogoutOptions } from './logout';\nexport { default as backchannelLogoutHandler, HandleBackchannelLogout } from './backchannel-logout';\nexport {\n  default as profileHandler,\n  HandleProfile,\n  ProfileOptions,\n  AfterRefetch,\n  AfterRefetchPageRoute,\n  AfterRefetchAppRoute\n} from './profile';\nexport { default as handlerFactory, Handlers, HandleAuth, AppRouterOnError, PageRouterOnError } from './auth';\nexport {\n  AppRouteHandlerFnContext,\n  PageRouterHandler,\n  AppRouterHandler,\n  NextPageRouterHandler,\n  NextAppRouterHandler\n} from './router-helpers';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,YAAA,OAAO;IAAA;AAAA;AAOT,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,SAAA,OAAO;IAAA;AAAA;AAOT,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,iBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,UAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,4BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,sBAAA,OAAO;IAAA;AAAA;AAChB,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,WAAA,OAAO;IAAA;AAAA;AAOT,IAAA;AAAS,OAAA,cAAA,CAAA,SAAA,kBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,QAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 3103, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3107, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/helpers/with-api-auth-required.ts"],"sourcesContent":["import { NextApiResponse, NextApiRequest, NextApiHandler } from 'next';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { get, SessionCache } from '../session';\nimport { assertReqRes } from '../utils/assert';\nimport { isRequest } from '../utils/req-helpers';\n\n/**\n * This contains `param`s, which is an object containing the dynamic route parameters for the current route.\n *\n * See https://nextjs.org/docs/app/api-reference/file-conventions/route#context-optional\n *\n * @category Server\n */\nexport type AppRouteHandlerFnContext = {\n  params?: Record<string, string | string[]>;\n};\n\n/**\n * Handler function for app directory api routes.\n *\n * See: https://nextjs.org/docs/app/api-reference/file-conventions/route\n *\n * @category Server\n */\nexport type AppRouteHandlerFn = (\n  /**\n   * Incoming request object.\n   */\n  req: NextRequest,\n  /**\n   * Context properties on the request (including the parameters if this was a\n   * dynamic route).\n   */\n  ctx: AppRouteHandlerFnContext\n) => Promise<Response> | Response;\n\n/**\n * Wrap an app router API route to check that the user has a valid session. If they're not logged in the\n * handler will return a 401 Unauthorized.\n *\n * ```js\n * // app/protected-api/route.js\n * import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';\n *\n * export default withApiAuthRequired(function Protected(req) {\n *   const session = getSession();\n *   ...\n * });\n * ```\n *\n * If you visit `/protected-api` without a valid session cookie, you will get a 401 response.\n *\n * @category Server\n */\nexport type WithApiAuthRequiredAppRoute = (apiRoute: AppRouteHandlerFn) => AppRouteHandlerFn;\n\n/**\n * Wrap a page router API route to check that the user has a valid session. If they're not logged in the\n * handler will return a 401 Unauthorized.\n *\n * ```js\n * // pages/api/protected-route.js\n * import { withApiAuthRequired, getSession } from '@auth0/nextjs-auth0';\n *\n * export default withApiAuthRequired(function ProtectedRoute(req, res) {\n *   const session = getSession(req, res);\n *   ...\n * });\n * ```\n *\n * If you visit `/api/protected-route` without a valid session cookie, you will get a 401 response.\n *\n * @category Server\n */\nexport type WithApiAuthRequiredPageRoute = (apiRoute: NextApiHandler) => NextApiHandler;\n\n/**\n * Protects API routes for Page router pages {@link WithApiAuthRequiredPageRoute} or\n * App router pages {@link WithApiAuthRequiredAppRoute}\n *\n * @category Server\n */\nexport type WithApiAuthRequired = WithApiAuthRequiredAppRoute & WithApiAuthRequiredPageRoute;\n\n/**\n * @ignore\n */\nexport default function withApiAuthFactory(sessionCache: SessionCache): WithApiAuthRequired {\n  const pageRouteHandler = pageRouteHandlerFactory(sessionCache);\n  const appRouteHandler = appRouteHandlerFactory(sessionCache);\n\n  return (apiRoute: AppRouteHandlerFn | NextApiHandler): any =>\n    (req: NextRequest | NextApiRequest, resOrParams: AppRouteHandlerFnContext | NextApiResponse) => {\n      if (isRequest(req)) {\n        return appRouteHandler(apiRoute as AppRouteHandlerFn)(\n          req as NextRequest,\n          resOrParams as AppRouteHandlerFnContext\n        );\n      }\n      return (pageRouteHandler as WithApiAuthRequiredPageRoute)(apiRoute as NextApiHandler)(\n        req as NextApiRequest,\n        resOrParams as NextApiResponse\n      );\n    };\n}\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory =\n  (sessionCache: SessionCache): WithApiAuthRequiredAppRoute =>\n  (apiRoute) =>\n  async (req, params): Promise<NextResponse> => {\n    const res = new NextResponse();\n    const [session] = await get({ sessionCache, req, res });\n    if (!session || !session.user) {\n      return NextResponse.json(\n        { error: 'not_authenticated', description: 'The user does not have an active session or is not authenticated' },\n        { status: 401 }\n      );\n    }\n    const apiRes: NextResponse | Response = await apiRoute(req, params);\n    const nextApiRes: NextResponse = apiRes instanceof NextResponse ? apiRes : new NextResponse(apiRes.body, apiRes);\n    for (const cookie of res.cookies.getAll()) {\n      if (!nextApiRes.cookies.get(cookie.name)) {\n        nextApiRes.cookies.set(cookie);\n      }\n    }\n    return nextApiRes;\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory =\n  (sessionCache: SessionCache): WithApiAuthRequiredPageRoute =>\n  (apiRoute) =>\n  async (req, res) => {\n    assertReqRes(req, res);\n\n    const session = await sessionCache.get(req, res);\n    if (!session || !session.user) {\n      res.status(401).json({\n        error: 'not_authenticated',\n        description: 'The user does not have an active session or is not authenticated'\n      });\n      return;\n    }\n\n    await apiRoute(req, res);\n  };\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAgFA;;IAGA,SAAwB,mBAAmB,YAA0B;IACnE,MAAM,mBAAmB,wBAAwB;IACjD,MAAM,kBAAkB,uBAAuB;IAE/C,OAAO,CAAC,WACN,CAAC,KAAmC;YAClC,IAAI,CAAA,GAAA,cAAA,SAAS,EAAC,MAAM;gBAClB,OAAO,gBAAgB,UACrB,KACA;;YAGJ,OAAQ,iBAAkD,UACxD,KACA;QAEJ;AACJ;AAjBA,QAAA,OAAA,GAAA;AAmBA;;IAGA,MAAM,yBACJ,CAAC,eACD,CAAC,WACD,OAAO,KAAK;YACV,MAAM,MAAM,IAAI,SAAA,YAAY;YAC5B,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;gBAAE;gBAAc;gBAAK;YAAG;YACpD,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;gBAC7B,OAAO,SAAA,YAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;oBAAqB,aAAa;gBAAkE,GAC7G;oBAAE,QAAQ;gBAAG;;YAGjB,MAAM,SAAkC,MAAM,SAAS,KAAK;YAC5D,MAAM,aAA2B,kBAAkB,SAAA,YAAY,GAAG,SAAS,IAAI,SAAA,YAAY,CAAC,OAAO,IAAI,EAAE;YACzG,KAAK,MAAM,UAAU,IAAI,OAAO,CAAC,MAAM,GAAI;gBACzC,IAAI,CAAC,WAAW,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG;oBACxC,WAAW,OAAO,CAAC,GAAG,CAAC;;;YAG3B,OAAO;QACT;AAEF;;IAGA,MAAM,0BACJ,CAAC,eACD,CAAC,WACD,OAAO,KAAK;YACV,CAAA,GAAA,SAAA,YAAY,EAAC,KAAK;YAElB,MAAM,UAAU,MAAM,aAAa,GAAG,CAAC,KAAK;YAC5C,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;gBAC7B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC;oBACnB,OAAO;oBACP,aAAa;;gBAEf;;YAGF,MAAM,SAAS,KAAK;QACtB"}},
    {"offset": {"line": 3168, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3172, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/helpers/with-page-auth-required.ts"],"sourcesContent":["import type React from 'react';\nimport { GetServerSideProps, GetServerSidePropsContext, GetServerSidePropsResult } from 'next';\nimport { Claims, get, SessionCache } from '../session';\nimport { assertCtx } from '../utils/assert';\nimport { ParsedUrlQuery } from 'querystring';\nimport { GetConfig } from '../config';\nimport { Auth0NextRequestCookies } from '../http';\nimport { NodeRequest } from '../auth0-session/http';\n\n/**\n * If you wrap your `getServerSideProps` with {@link WithPageAuthRequired} your props object will be augmented with\n * the user property, which will be the user's {@link Claims}.\n *\n * ```js\n * // pages/profile.js\n * import { withPageAuthRequired } from '@auth0/nextjs-auth0';\n *\n * export default function Profile({ user }) {\n *   return <div>Hello {user.name}</div>;\n * }\n *\n * export const getServerSideProps = withPageAuthRequired();\n * ```\n *\n * @category Server\n */\nexport type GetServerSidePropsResultWithSession<P = any> = GetServerSidePropsResult<P & { user: Claims }>;\n\n/**\n * A page route that has been augmented with {@link WithPageAuthRequired}.\n *\n * @category Server\n */\nexport type PageRoute<P, Q extends ParsedUrlQuery = ParsedUrlQuery> = (\n  ctx: GetServerSidePropsContext<Q>\n) => Promise<GetServerSidePropsResultWithSession<P>>;\n\n/**\n * Objects containing the route parameters and search parameters of th page.\n *\n * @category Server\n */\nexport type AppRouterPageRouteOpts = {\n  params?: Record<string, string | string[]>;\n  searchParams?: { [key: string]: string | string[] | undefined };\n};\n\n/**\n * An app route that has been augmented with {@link WithPageAuthRequired}.\n *\n * @category Server\n */\nexport type AppRouterPageRoute = (obj: AppRouterPageRouteOpts) => Promise<React.JSX.Element>;\n\n/**\n * If you have a custom returnTo url you should specify it in `returnTo`.\n *\n * You can pass in your own `getServerSideProps` method, the props returned from this will be\n * merged with the user props. You can also access the user session data by calling `getSession`\n * inside of this method. For example:\n *\n * ```js\n * // pages/protected-page.js\n * import { getSession, withPageAuthRequired } from '@auth0/nextjs-auth0';\n *\n * export default function ProtectedPage({ user, customProp }) {\n *   return <div>Protected content</div>;\n * }\n *\n * export const getServerSideProps = withPageAuthRequired({\n *   // returnTo: '/unauthorized',\n *   async getServerSideProps(ctx) {\n *     // access the user session if needed\n *     // const session = await getSession(ctx.req, ctx.res);\n *     return {\n *       props: {\n *         // customProp: 'bar',\n *       }\n *     };\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type WithPageAuthRequiredPageRouterOptions<\n  P extends { [key: string]: any } = { [key: string]: any },\n  Q extends ParsedUrlQuery = ParsedUrlQuery\n> = {\n  getServerSideProps?: GetServerSideProps<P, Q>;\n  returnTo?: string;\n};\n\n/**\n * Wrap your `getServerSideProps` with this method to make sure the user is authenticated before\n * visiting the page.\n *\n * ```js\n * // pages/protected-page.js\n * import { withPageAuthRequired } from '@auth0/nextjs-auth0';\n *\n * export default function ProtectedPage() {\n *   return <div>Protected content</div>;\n * }\n *\n * export const getServerSideProps = withPageAuthRequired();\n * ```\n *\n * If the user visits `/protected-page` without a valid session, it will redirect the user to the\n * login page. Then they will be returned to `/protected-page` after login.\n *\n * @category Server\n */\nexport type WithPageAuthRequiredPageRouter = <\n  P extends { [key: string]: any } = { [key: string]: any },\n  Q extends ParsedUrlQuery = ParsedUrlQuery\n>(\n  opts?: WithPageAuthRequiredPageRouterOptions<P, Q>\n) => PageRoute<P, Q>;\n\n/**\n * Specify the URL to `returnTo` - this is important in app router pages because the server component\n * won't know the URL of the page.\n *\n * @category Server\n */\nexport type WithPageAuthRequiredAppRouterOptions = {\n  returnTo?: string | ((obj: AppRouterPageRouteOpts) => Promise<string> | string);\n};\n\n/**\n * Wrap your Server Component with this method to make sure the user is authenticated before\n * visiting the page.\n *\n * ```js\n * // app/protected-page/page.js\n * import { withPageAuthRequired } from '@auth0/nextjs-auth0';\n *\n * export default function withPageAuthRequired(ProtectedPage() {\n *   return <div>Protected content</div>;\n * }, { returnTo: '/protected-page' });\n * ```\n *\n * If the user visits `/protected-page` without a valid session, it will redirect the user to the\n * login page.\n *\n * Note: Server Components are not aware of the req or the url of the page. So if you want the user to return to the\n * page after login, you must specify the `returnTo` option.\n *\n * You can specify a function to `returnTo` that accepts the `params` (An object containing the dynamic\n * route parameters) and `searchParams` (An object containing the search parameters of the current URL)\n * argument from the page, to preserve dynamic routes and search params.\n *\n * ```js\n * // app/protected-page/[slug]/page.js\n * import { withPageAuthRequired } from '@auth0/nextjs-auth0';\n *\n * export default function withPageAuthRequired(ProtectedPage() {\n *   return <div>Protected content</div>;\n * }, {\n *   returnTo({ params }) {\n *     return `/protected-page/${params.slug}`\n *   }\n * });\n * ```\n *\n * @category Server\n */\nexport type WithPageAuthRequiredAppRouter = (\n  fn: AppRouterPageRoute,\n  opts?: WithPageAuthRequiredAppRouterOptions\n) => AppRouterPageRoute;\n\n/**\n * Protects Page router pages {@link WithPageAuthRequiredPageRouter} or\n * App router pages {@link WithPageAuthRequiredAppRouter}\n *\n * @category Server\n */\nexport type WithPageAuthRequired = WithPageAuthRequiredPageRouter & WithPageAuthRequiredAppRouter;\n\n/**\n * @ignore\n */\nexport default function withPageAuthRequiredFactory(\n  getConfig: GetConfig,\n  sessionCache: SessionCache\n): WithPageAuthRequired {\n  const appRouteHandler = appRouteHandlerFactory(getConfig, sessionCache);\n  const pageRouteHandler = pageRouteHandlerFactory(getConfig, sessionCache);\n\n  return ((\n    fnOrOpts?: WithPageAuthRequiredPageRouterOptions | AppRouterPageRoute,\n    opts?: WithPageAuthRequiredAppRouterOptions\n  ) => {\n    if (typeof fnOrOpts === 'function') {\n      return appRouteHandler(fnOrOpts, opts);\n    }\n    return pageRouteHandler(fnOrOpts);\n  }) as WithPageAuthRequired;\n}\n\n/**\n * @ignore\n */\nconst appRouteHandlerFactory =\n  (getConfig: GetConfig, sessionCache: SessionCache): WithPageAuthRequiredAppRouter =>\n  (handler, opts = {}) =>\n  async (params) => {\n    const {\n      routes: { login: loginUrl }\n    } = await getConfig(new Auth0NextRequestCookies());\n    const [session] = await get({ sessionCache });\n    if (!session?.user) {\n      const returnTo = typeof opts.returnTo === 'function' ? await opts.returnTo(params) : opts.returnTo;\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const { redirect } = require('next/navigation');\n      redirect(`${loginUrl}${opts.returnTo ? `?returnTo=${returnTo}` : ''}`);\n    }\n    return handler(params);\n  };\n\n/**\n * @ignore\n */\nconst pageRouteHandlerFactory =\n  (getConfig: GetConfig, sessionCache: SessionCache): WithPageAuthRequiredPageRouter =>\n  ({ getServerSideProps, returnTo } = {}) =>\n  async (ctx) => {\n    assertCtx(ctx);\n    const {\n      routes: { login: loginUrl }\n    } = await getConfig(new NodeRequest(ctx.req));\n    const session = await sessionCache.get(ctx.req, ctx.res);\n    if (!session?.user) {\n      return {\n        redirect: {\n          destination: `${loginUrl}?returnTo=${encodeURIComponent(returnTo || ctx.resolvedUrl)}`,\n          permanent: false\n        }\n      };\n    }\n    let ret: any = { props: {} };\n    if (getServerSideProps) {\n      ret = await getServerSideProps(ctx);\n    }\n    if (ret.props instanceof Promise) {\n      return { ...ret, props: ret.props.then((props: any) => ({ user: session.user, ...props })) };\n    }\n    return { ...ret, props: { user: session.user, ...ret.props } };\n  };\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AAGA,MAAA;AACA,MAAA;AA8KA;;IAGA,SAAwB,4BACtB,SAAoB,EACpB,YAA0B;IAE1B,MAAM,kBAAkB,uBAAuB,WAAW;IAC1D,MAAM,mBAAmB,wBAAwB,WAAW;IAE5D,OAAQ,CACN,UACA;QAEA,IAAI,OAAO,aAAa,YAAY;YAClC,OAAO,gBAAgB,UAAU;;QAEnC,OAAO,iBAAiB;IAC1B;AACF;AAhBA,QAAA,OAAA,GAAA;AAkBA;;IAGA,MAAM,yBACJ,CAAC,WAAsB,eACvB,CAAC,SAAS,OAAO,CAAA,CAAE,GACnB,OAAO;YACL,MAAM,EACJ,QAAQ,EAAE,OAAO,QAAQ,EAAE,EAC5B,GAAG,MAAM,UAAU,IAAI,OAAA,uBAAuB;YAC/C,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAA,GAAA,UAAA,GAAG,EAAC;gBAAE;YAAY;YAC1C,IAAI,CAAC,CAAA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,IAAI,GAAE;gBAClB,MAAM,WAAW,OAAO,KAAK,QAAQ,KAAK,aAAa,MAAM,KAAK,QAAQ,CAAC,UAAU,KAAK,QAAQ;gBAClG,8DAA8D;gBAC9D,MAAM,EAAE,QAAQ,EAAE;gBAClB,SAAS,CAAA,EAAG,SAAQ,EAAG,KAAK,QAAQ,GAAG,CAAA,UAAA,EAAa,SAAQ,CAAE,GAAG,GAAE,CAAE;;YAEvE,OAAO,QAAQ;QACjB;AAEF;;IAGA,MAAM,0BACJ,CAAC,WAAsB,eACvB,CAAC,EAAE,kBAAkB,EAAE,QAAQ,EAAE,GAAG,CAAA,CAAE,GACtC,OAAO;YACL,CAAA,GAAA,SAAA,SAAS,EAAC;YACV,MAAM,EACJ,QAAQ,EAAE,OAAO,QAAQ,EAAE,EAC5B,GAAG,MAAM,UAAU,IAAI,OAAA,WAAW,CAAC,IAAI,GAAG;YAC3C,MAAM,UAAU,MAAM,aAAa,GAAG,CAAC,IAAI,GAAG,EAAE,IAAI,GAAG;YACvD,IAAI,CAAC,CAAA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,IAAI,GAAE;gBAClB,OAAO;oBACL,UAAU;wBACR,aAAa,CAAA,EAAG,SAAQ,UAAA,EAAa,mBAAmB,YAAY,IAAI,WAAW,EAAC,CAAE;wBACtF,WAAW;;;;YAIjB,IAAI,MAAW;gBAAE,OAAO,CAAA;YAAE;YAC1B,IAAI,oBAAoB;gBACtB,MAAM,MAAM,mBAAmB;;YAEjC,IAAI,IAAI,KAAK,YAAY,SAAS;gBAChC,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAY,MAAG;oBAAE,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC,QAAe,OAAA,MAAA,CAAA;4BAAG,MAAM,QAAQ,IAAI;wBAAA,GAAK;gBAAS;;YAE5F,OAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAY,MAAG;gBAAE,OAAK,OAAA,MAAA,CAAA;oBAAI,MAAM,QAAQ,IAAI;gBAAA,GAAK,IAAI,KAAK;YAAA;QAC5D"}},
    {"offset": {"line": 3241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3245, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/helpers/index.ts"],"sourcesContent":["export {\n  default as withApiAuthRequiredFactory,\n  WithApiAuthRequired,\n  AppRouteHandlerFn,\n  WithApiAuthRequiredAppRoute,\n  WithApiAuthRequiredPageRoute\n} from './with-api-auth-required';\nexport {\n  default as withPageAuthRequiredFactory,\n  GetServerSidePropsResultWithSession,\n  WithPageAuthRequired,\n  WithPageAuthRequiredPageRouterOptions,\n  WithPageAuthRequiredAppRouterOptions,\n  PageRoute,\n  AppRouterPageRouteOpts,\n  AppRouterPageRoute,\n  WithPageAuthRequiredPageRouter,\n  WithPageAuthRequiredAppRouter\n} from './with-page-auth-required';\n"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,8BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,0BAAA,OAAO;IAAA;AAAA;AAMT,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,+BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,2BAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 3269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3273, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/config.ts"],"sourcesContent":["import type { Config as BaseConfig } from './auth0-session/config';\nimport { DeepPartial, get as getBaseConfig } from './auth0-session/get-config';\nimport type { Auth0Request, Auth0RequestCookies } from './auth0-session/http';\n\n/**\n * @category server\n */\nexport interface NextConfig extends BaseConfig {\n  /**\n   * Log users in to a specific organization.\n   *\n   * This will specify an `organization` parameter in your user's login request and will add a step to validate\n   * the `org_id` or `org_name` claim in your user's ID token.\n   *\n   * If your app supports multiple organizations, you should take a look at {@link AuthorizationParams.organization}.\n   */\n  organization?: string;\n  routes: BaseConfig['routes'] & {\n    login: string;\n  };\n}\n\n/**\n * ## Configuration properties.\n *\n * The Server part of the SDK can be configured in 2 ways.\n *\n * ### 1. Environment Variables\n *\n * The simplest way to use the SDK is to use the named exports ({@link HandleAuth}, {@link HandleLogin},\n * {@link HandleLogout}, {@link HandleCallback}, {@link HandleProfile}, {@link GetSession}, {@link GetAccessToken},\n * {@link WithApiAuthRequired}, and {@link WithPageAuthRequired}).\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import { handleAuth } from '@auth0/nextjs-auth0';\n *\n * return handleAuth();\n * ```\n *\n * When you use these named exports, an instance of the SDK is created for you which you can configure using\n * environment variables:\n *\n * ### Required\n *\n * - `AUTH0_SECRET`: See {@link BaseConfig.secret}.\n * - `AUTH0_ISSUER_BASE_URL`: See {@link BaseConfig.issuerBaseURL}.\n * - `AUTH0_BASE_URL`: See {@link BaseConfig.baseURL}.\n * - `AUTH0_CLIENT_ID`: See {@link BaseConfig.clientID}.\n * - `AUTH0_CLIENT_SECRET`: See {@link BaseConfig.clientSecret}.\n *\n * ### Optional\n *\n * - `AUTH0_CLOCK_TOLERANCE`: See {@link BaseConfig.clockTolerance}.\n * - `AUTH0_HTTP_TIMEOUT`: See {@link BaseConfig.httpTimeout}.\n * - `AUTH0_ENABLE_TELEMETRY`: See {@link BaseConfig.enableTelemetry}.\n * - `AUTH0_IDP_LOGOUT`: See {@link BaseConfig.idpLogout}.\n * - `AUTH0_ID_TOKEN_SIGNING_ALG`: See {@link BaseConfig.idTokenSigningAlg}.\n * - `AUTH0_LEGACY_SAME_SITE_COOKIE`: See {@link BaseConfig.legacySameSiteCookie}.\n * - `AUTH0_IDENTITY_CLAIM_FILTER`: See {@link BaseConfig.identityClaimFilter}.\n * - `AUTH0_PUSHED_AUTHORIZATION_REQUESTS` See {@link BaseConfig.pushedAuthorizationRequests}.\n * - `NEXT_PUBLIC_AUTH0_LOGIN`: See {@link NextConfig.routes}.\n * - `AUTH0_CALLBACK`: See {@link BaseConfig.routes}.\n * - `AUTH0_POST_LOGOUT_REDIRECT`: See {@link BaseConfig.routes}.\n * - `AUTH0_AUDIENCE`: See {@link BaseConfig.authorizationParams}.\n * - `AUTH0_SCOPE`: See {@link BaseConfig.authorizationParams}.\n * - `AUTH0_ORGANIZATION`: See {@link NextConfig.organization}.\n * - `AUTH0_SESSION_NAME`: See {@link SessionConfig.name}.\n * - `AUTH0_SESSION_ROLLING`: See {@link SessionConfig.rolling}.\n * - `AUTH0_SESSION_ROLLING_DURATION`: See {@link SessionConfig.rollingDuration}.\n * - `AUTH0_SESSION_ABSOLUTE_DURATION`: See {@link SessionConfig.absoluteDuration}.\n * - `AUTH0_SESSION_AUTO_SAVE`: See {@link SessionConfig.autoSave}.\n * - `AUTH0_COOKIE_DOMAIN`: See {@link CookieConfig.domain}.\n * - `AUTH0_COOKIE_PATH`: See {@link CookieConfig.path}.\n * - `AUTH0_COOKIE_TRANSIENT`: See {@link CookieConfig.transient}.\n * - `AUTH0_COOKIE_HTTP_ONLY`: See {@link CookieConfig.httpOnly}.\n * - `AUTH0_COOKIE_SECURE`: See {@link CookieConfig.secure}.\n * - `AUTH0_COOKIE_SAME_SITE`: See {@link CookieConfig.sameSite}.\n * - `AUTH0_CLIENT_ASSERTION_SIGNING_KEY`: See {@link BaseConfig.clientAssertionSigningKey}\n * - `AUTH0_CLIENT_ASSERTION_SIGNING_ALG`: See {@link BaseConfig.clientAssertionSigningAlg}\n * - `AUTH0_TRANSACTION_COOKIE_NAME` See {@link BaseConfig.transactionCookie}\n * - `AUTH0_TRANSACTION_COOKIE_DOMAIN` See {@link BaseConfig.transactionCookie}\n * - `AUTH0_TRANSACTION_COOKIE_PATH` See {@link BaseConfig.transactionCookie}\n * - `AUTH0_TRANSACTION_COOKIE_SAME_SITE` See {@link BaseConfig.transactionCookie}\n * - `AUTH0_TRANSACTION_COOKIE_SECURE` See {@link BaseConfig.transactionCookie}\n *\n * ### 2. Create your own instance using {@link InitAuth0}\n *\n * If you don't want to configure the SDK with environment variables or you want more fine grained control over the\n * instance, you can create an instance yourself and use the handlers and helpers from that.\n *\n * First, export your configured instance from another module:\n *\n * ```js\n * // utils/auth0.js\n * import { initAuth0 } from '@auth0/nextjs-auth0';\n *\n * export default initAuth0({ ...ConfigParameters... });\n * ```\n *\n * Then import it into your route handler:\n *\n * ```js\n * // pages/api/auth/[auth0].js\n * import auth0 from '../../../../utils/auth0';\n *\n * export default auth0.handleAuth();\n * ```\n *\n * **IMPORTANT** If you use {@link InitAuth0}, you should *not* use the other named exports as they will use a different\n * instance of the SDK. Also note - this is for the server side part of the SDK - you will always use named exports for\n * the front end components: {@link UserProvider}, {@link UseUser} and the\n * front end version of {@link WithPageAuthRequired}\n *\n * @category Server\n */\nexport type ConfigParameters = DeepPartial<NextConfig>;\n\n/**\n * @ignore\n */\nconst FALSEY = ['n', 'no', 'false', '0', 'off'];\n\n/**\n * @ignore\n */\nconst bool = (param?: any, defaultValue?: boolean): boolean | undefined => {\n  if (param === undefined || param === '') return defaultValue;\n  if (param && typeof param === 'string') return !FALSEY.includes(param.toLowerCase().trim());\n  return !!param;\n};\n\n/**\n * @ignore\n */\nconst num = (param?: string): number | undefined => (param === undefined || param === '' ? undefined : +param);\n\n/**\n * @ignore\n */\nconst array = (param?: string): string[] | undefined =>\n  param === undefined || param === '' ? undefined : param.replace(/\\s/g, '').split(',');\n\n/**\n * @ignore\n */\nexport const getConfig = (params: ConfigParameters = {}): NextConfig => {\n  // Don't use destructuring here so that the `DefinePlugin` can replace any env vars specified in `next.config.js`\n  const AUTH0_SECRET = process.env.AUTH0_SECRET;\n  const AUTH0_ISSUER_BASE_URL = process.env.AUTH0_ISSUER_BASE_URL;\n  const AUTH0_BASE_URL = process.env.AUTH0_BASE_URL || process.env.NEXT_PUBLIC_AUTH0_BASE_URL;\n  const AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID;\n  const AUTH0_CLIENT_SECRET = process.env.AUTH0_CLIENT_SECRET;\n  const AUTH0_CLOCK_TOLERANCE = process.env.AUTH0_CLOCK_TOLERANCE;\n  const AUTH0_HTTP_TIMEOUT = process.env.AUTH0_HTTP_TIMEOUT;\n  const AUTH0_ENABLE_TELEMETRY = process.env.AUTH0_ENABLE_TELEMETRY;\n  const AUTH0_IDP_LOGOUT = process.env.AUTH0_IDP_LOGOUT;\n  const AUTH0_LOGOUT = process.env.AUTH0_LOGOUT;\n  const AUTH0_ID_TOKEN_SIGNING_ALG = process.env.AUTH0_ID_TOKEN_SIGNING_ALG;\n  const AUTH0_LEGACY_SAME_SITE_COOKIE = process.env.AUTH0_LEGACY_SAME_SITE_COOKIE;\n  const AUTH0_IDENTITY_CLAIM_FILTER = process.env.AUTH0_IDENTITY_CLAIM_FILTER;\n  const AUTH0_PUSHED_AUTHORIZATION_REQUESTS = process.env.AUTH0_PUSHED_AUTHORIZATION_REQUESTS;\n  const AUTH0_CALLBACK = process.env.AUTH0_CALLBACK;\n  const AUTH0_POST_LOGOUT_REDIRECT = process.env.AUTH0_POST_LOGOUT_REDIRECT;\n  const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;\n  const AUTH0_SCOPE = process.env.AUTH0_SCOPE;\n  const AUTH0_ORGANIZATION = process.env.AUTH0_ORGANIZATION;\n  const AUTH0_SESSION_NAME = process.env.AUTH0_SESSION_NAME;\n  const AUTH0_SESSION_ROLLING = process.env.AUTH0_SESSION_ROLLING;\n  const AUTH0_SESSION_ROLLING_DURATION = process.env.AUTH0_SESSION_ROLLING_DURATION;\n  const AUTH0_SESSION_ABSOLUTE_DURATION = process.env.AUTH0_SESSION_ABSOLUTE_DURATION;\n  const AUTH0_SESSION_AUTO_SAVE = process.env.AUTH0_SESSION_AUTO_SAVE;\n  const AUTH0_SESSION_STORE_ID_TOKEN = process.env.AUTH0_SESSION_STORE_ID_TOKEN;\n  const AUTH0_COOKIE_DOMAIN = process.env.AUTH0_COOKIE_DOMAIN;\n  const AUTH0_COOKIE_PATH = process.env.AUTH0_COOKIE_PATH;\n  const AUTH0_COOKIE_TRANSIENT = process.env.AUTH0_COOKIE_TRANSIENT;\n  const AUTH0_COOKIE_HTTP_ONLY = process.env.AUTH0_COOKIE_HTTP_ONLY;\n  const AUTH0_COOKIE_SECURE = process.env.AUTH0_COOKIE_SECURE;\n  const AUTH0_COOKIE_SAME_SITE = process.env.AUTH0_COOKIE_SAME_SITE;\n  const AUTH0_CLIENT_ASSERTION_SIGNING_KEY = process.env.AUTH0_CLIENT_ASSERTION_SIGNING_KEY;\n  const AUTH0_CLIENT_ASSERTION_SIGNING_ALG = process.env.AUTH0_CLIENT_ASSERTION_SIGNING_ALG;\n  const AUTH0_TRANSACTION_COOKIE_NAME = process.env.AUTH0_TRANSACTION_COOKIE_NAME;\n  const AUTH0_TRANSACTION_COOKIE_DOMAIN = process.env.AUTH0_TRANSACTION_COOKIE_DOMAIN;\n  const AUTH0_TRANSACTION_COOKIE_PATH = process.env.AUTH0_TRANSACTION_COOKIE_PATH;\n  const AUTH0_TRANSACTION_COOKIE_SAME_SITE = process.env.AUTH0_TRANSACTION_COOKIE_SAME_SITE;\n  const AUTH0_TRANSACTION_COOKIE_SECURE = process.env.AUTH0_TRANSACTION_COOKIE_SECURE;\n\n  const baseURL =\n    AUTH0_BASE_URL && !/^https?:\\/\\//.test(AUTH0_BASE_URL as string) ? `https://${AUTH0_BASE_URL}` : AUTH0_BASE_URL;\n\n  const { organization, ...baseParams } = params;\n\n  const baseConfig = getBaseConfig({\n    secret: AUTH0_SECRET,\n    issuerBaseURL: AUTH0_ISSUER_BASE_URL,\n    baseURL: baseURL,\n    clientID: AUTH0_CLIENT_ID,\n    clientSecret: AUTH0_CLIENT_SECRET,\n    clockTolerance: num(AUTH0_CLOCK_TOLERANCE),\n    httpTimeout: num(AUTH0_HTTP_TIMEOUT),\n    enableTelemetry: bool(AUTH0_ENABLE_TELEMETRY),\n    idpLogout: bool(AUTH0_IDP_LOGOUT, true),\n    auth0Logout: bool(AUTH0_LOGOUT, true),\n    idTokenSigningAlg: AUTH0_ID_TOKEN_SIGNING_ALG,\n    legacySameSiteCookie: bool(AUTH0_LEGACY_SAME_SITE_COOKIE),\n    identityClaimFilter: array(AUTH0_IDENTITY_CLAIM_FILTER),\n    pushedAuthorizationRequests: bool(AUTH0_PUSHED_AUTHORIZATION_REQUESTS, false),\n    ...baseParams,\n    authorizationParams: {\n      response_type: 'code',\n      audience: AUTH0_AUDIENCE,\n      scope: AUTH0_SCOPE,\n      ...baseParams.authorizationParams\n    },\n    session: {\n      name: AUTH0_SESSION_NAME,\n      rolling: bool(AUTH0_SESSION_ROLLING),\n      rollingDuration:\n        AUTH0_SESSION_ROLLING_DURATION && isNaN(Number(AUTH0_SESSION_ROLLING_DURATION))\n          ? (bool(AUTH0_SESSION_ROLLING_DURATION) as false)\n          : num(AUTH0_SESSION_ROLLING_DURATION),\n      absoluteDuration:\n        AUTH0_SESSION_ABSOLUTE_DURATION && isNaN(Number(AUTH0_SESSION_ABSOLUTE_DURATION))\n          ? bool(AUTH0_SESSION_ABSOLUTE_DURATION)\n          : num(AUTH0_SESSION_ABSOLUTE_DURATION),\n      autoSave: bool(AUTH0_SESSION_AUTO_SAVE, true),\n      storeIDToken: bool(AUTH0_SESSION_STORE_ID_TOKEN),\n      ...baseParams.session,\n      cookie: {\n        domain: AUTH0_COOKIE_DOMAIN,\n        path: AUTH0_COOKIE_PATH || '/',\n        transient: bool(AUTH0_COOKIE_TRANSIENT),\n        httpOnly: bool(AUTH0_COOKIE_HTTP_ONLY),\n        secure: bool(AUTH0_COOKIE_SECURE),\n        sameSite: AUTH0_COOKIE_SAME_SITE as 'lax' | 'strict' | 'none' | undefined,\n        ...baseParams.session?.cookie\n      }\n    },\n    routes: {\n      callback: baseParams.routes?.callback || AUTH0_CALLBACK || '/api/auth/callback',\n      postLogoutRedirect: baseParams.routes?.postLogoutRedirect || AUTH0_POST_LOGOUT_REDIRECT\n    },\n    clientAssertionSigningKey: AUTH0_CLIENT_ASSERTION_SIGNING_KEY,\n    clientAssertionSigningAlg: AUTH0_CLIENT_ASSERTION_SIGNING_ALG,\n    transactionCookie: {\n      name: AUTH0_TRANSACTION_COOKIE_NAME,\n      domain: AUTH0_TRANSACTION_COOKIE_DOMAIN,\n      path: AUTH0_TRANSACTION_COOKIE_PATH || '/',\n      secure: bool(AUTH0_TRANSACTION_COOKIE_SECURE),\n      sameSite: AUTH0_TRANSACTION_COOKIE_SAME_SITE as 'lax' | 'strict' | 'none' | undefined,\n      ...baseParams.transactionCookie\n    }\n  });\n\n  return {\n    ...baseConfig,\n    organization: organization || AUTH0_ORGANIZATION,\n    routes: {\n      ...baseConfig.routes,\n      login: baseParams.routes?.login || process.env.NEXT_PUBLIC_AUTH0_LOGIN || '/api/auth/login'\n    }\n  };\n};\n\nexport type GetConfig = (req: Auth0Request | Auth0RequestCookies) => Promise<NextConfig> | NextConfig;\n\nexport const configSingletonGetter = (params: ConfigParameters = {}, genId: () => string): GetConfig => {\n  let config: NextConfig;\n  return (req) => {\n    if (!config) {\n      // Bails out of static rendering for Server Components\n      // Need to query cookies because Server Components don't have access to URL\n      req.getCookies();\n      if ('getUrl' in req) {\n        // Bail out of static rendering for API Routes\n        // Reading cookies is not always enough https://github.com/vercel/next.js/issues/49006\n        req.getUrl();\n      }\n      config = getConfig({ ...params, session: { genId, ...params.session } });\n    }\n    return config;\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3431, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3435, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/version.ts"],"sourcesContent":["export default '3.5.0';\n"],"names":[],"mappings":";;;;AAAA,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3440, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3444, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/shared.ts"],"sourcesContent":["import { SessionStore as GenericSessionStore, SessionPayload } from './auth0-session';\nimport {\n  HandleAuth,\n  HandleLogin,\n  HandleProfile,\n  HandleLogout,\n  HandleCallback,\n  HandleBackchannelLogout\n} from './handlers';\nimport { SessionCache, GetSession, GetAccessToken, Session, TouchSession, UpdateSession } from './session/';\nimport { WithApiAuthRequired, WithPageAuthRequired } from './helpers';\nimport { ConfigParameters } from './config';\nimport { WithMiddlewareAuthRequired } from './helpers/with-middleware-auth-required';\nimport version from './version';\n\nexport const telemetry = { name: 'nextjs-auth0', version };\n\n/**\n * The SDK server instance.\n *\n * This is created for you when you use the named exports, or you can create your own using {@link InitAuth0}.\n *\n * See {@link ConfigParameters} for more info.\n *\n * @category Server\n */\nexport interface Auth0Server {\n  /**\n   * Session getter.\n   */\n  getSession: GetSession;\n\n  /**\n   * Update the expiry of a rolling session when autoSave is disabled.\n   */\n  touchSession: TouchSession;\n\n  /**\n   * Append properties to the user.\n   */\n  updateSession: UpdateSession;\n\n  /**\n   * Access token getter.\n   */\n  getAccessToken: GetAccessToken;\n\n  /**\n   * Login handler which will redirect the user to Auth0.\n   */\n  handleLogin: HandleLogin;\n\n  /**\n   * Callback handler which will complete the transaction and create a local session.\n   */\n  handleCallback: HandleCallback;\n\n  /**\n   * Logout handler which will clear the local session and the Auth0 session.\n   */\n  handleLogout: HandleLogout;\n\n  /**\n   * Logout handler which will clear the local session and the Auth0 session.\n   */\n  handleBackchannelLogout: HandleBackchannelLogout;\n\n  /**\n   * Profile handler which return profile information about the user.\n   */\n  handleProfile: HandleProfile;\n\n  /**\n   * Helper that adds auth to an API route.\n   */\n  withApiAuthRequired: WithApiAuthRequired;\n\n  /**\n   * Helper that adds auth to a Page route.\n   */\n  withPageAuthRequired: WithPageAuthRequired;\n\n  /**\n   * Create the main handlers for your api routes.\n   */\n  handleAuth: HandleAuth;\n\n  /**\n   * Add auth to your middleware functions.\n   */\n  withMiddlewareAuthRequired: WithMiddlewareAuthRequired;\n}\n\nexport {\n  AuthError,\n  AccessTokenErrorCode,\n  AccessTokenError,\n  HandlerError,\n  CallbackHandlerError,\n  LoginHandlerError,\n  LogoutHandlerError,\n  ProfileHandlerError\n} from './utils/errors';\n\nexport {\n  Handlers,\n  LoginOptions,\n  LogoutOptions,\n  GetLoginState,\n  GetLoginStatePageRoute,\n  GetLoginStateAppRoute,\n  ProfileOptions,\n  CallbackOptions,\n  AfterCallback,\n  AfterCallbackPageRoute,\n  AfterCallbackAppRoute,\n  AfterRefetch,\n  AfterRefetchPageRoute,\n  AfterRefetchAppRoute,\n  AppRouterOnError,\n  PageRouterOnError,\n  AppRouteHandlerFnContext,\n  NextAppRouterHandler,\n  NextPageRouterHandler,\n  AppRouterHandler,\n  PageRouterHandler\n} from './handlers';\n\nexport {\n  AppRouterPageRouteOpts,\n  AppRouterPageRoute,\n  WithPageAuthRequiredPageRouter,\n  WithPageAuthRequiredAppRouter,\n  GetServerSidePropsResultWithSession,\n  WithPageAuthRequiredPageRouterOptions,\n  WithPageAuthRequiredAppRouterOptions,\n  PageRoute,\n  AppRouteHandlerFn,\n  WithApiAuthRequiredAppRoute,\n  WithApiAuthRequiredPageRoute\n} from './helpers';\n\nexport {\n  AccessTokenRequest,\n  GetAccessTokenResult,\n  Claims,\n  AfterRefresh,\n  AfterRefreshPageRoute,\n  AfterRefreshAppRoute\n} from './session';\n\nexport {\n  MissingStateCookieError,\n  MalformedStateCookieError,\n  MissingStateParamError,\n  IdentityProviderError,\n  ApplicationError\n} from './auth0-session';\n\nexport {\n  ConfigParameters,\n  HandleAuth,\n  HandleLogin,\n  HandleProfile,\n  HandleLogout,\n  HandleCallback,\n  HandleBackchannelLogout,\n  WithApiAuthRequired,\n  WithPageAuthRequired,\n  SessionCache,\n  GetSession,\n  TouchSession,\n  UpdateSession,\n  GetAccessToken,\n  Session\n};\n\nexport type SessionStore = GenericSessionStore<Session>;\nexport type SessionStorePayload = SessionPayload<Session>;\n"],"names":[],"mappings":";;;;;;AASA,MAAA;AAgKE,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAhKO,UAAA,YAAY;IAAA;AAAA;AAqKnB,OAAA,cAAA,CAAA,SAAA,WAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OArKiD,UAAA,OAAO;IAAA;AAAA;AAI1D,MAAA,YAAA,QAAA,eAAA;AAEa,QAAA,SAAS,GAAG;IAAE,MAAM;IAAgB,SAAA,UAAA,OAAO;AAAA;AA8ExD,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,SAAS;IAAA;AAAA;AACT,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,oBAAoB;IAAA;AAAA;AACpB,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,gBAAgB;IAAA;AAAA;AAChB,OAAA,cAAA,CAAA,SAAA,gBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,YAAY;IAAA;AAAA;AACZ,OAAA,cAAA,CAAA,SAAA,wBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,oBAAoB;IAAA;AAAA;AACpB,OAAA,cAAA,CAAA,SAAA,qBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,iBAAiB;IAAA;AAAA;AACjB,OAAA,cAAA,CAAA,SAAA,sBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,kBAAkB;IAAA;AAAA;AAClB,OAAA,cAAA,CAAA,SAAA,uBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,SAAA,mBAAmB;IAAA;AAAA;AAkDrB,IAAA;AACE,OAAA,cAAA,CAAA,SAAA,2BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,uBAAuB;IAAA;AAAA;AACvB,OAAA,cAAA,CAAA,SAAA,6BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,yBAAyB;IAAA;AAAA;AACzB,OAAA,cAAA,CAAA,SAAA,0BAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,sBAAsB;IAAA;AAAA;AACtB,OAAA,cAAA,CAAA,SAAA,yBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,qBAAqB;IAAA;AAAA;AACrB,OAAA,cAAA,CAAA,SAAA,oBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,gBAAA,gBAAgB;IAAA;AAAA"}},
    {"offset": {"line": 3548, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3552, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/helpers/with-middleware-auth-required.ts"],"sourcesContent":["import { NextMiddleware, NextRequest, NextResponse } from 'next/server';\nimport { SessionCache } from '../session';\nimport { GetConfig } from '../config';\nimport { Auth0NextRequest } from '../http';\n\n/**\n * Pass custom options to {@link WithMiddlewareAuthRequired}.\n *\n * @category Server\n */\nexport type WithMiddlewareAuthRequiredOptions = {\n  middleware?: NextMiddleware;\n  returnTo?: string | ((req: NextRequest) => Promise<string> | string);\n};\n\n/**\n * Protect your pages with Next.js Middleware. For example:\n *\n * To protect all your routes:\n *\n * ```js\n * // middleware.js\n * import { withMiddlewareAuthRequired } from '@auth0/nextjs-auth0/edge';\n *\n * export default withMiddlewareAuthRequired();\n * ```\n *\n * To protect specific routes:\n *\n * ```js\n * // middleware.js\n * import { withMiddlewareAuthRequired } from '@auth0/nextjs-auth0/edge';\n *\n * export default withMiddlewareAuthRequired();\n *\n * export const config = {\n *   matcher: '/about/:path*',\n * };\n * ```\n * For more info see: https://nextjs.org/docs/advanced-features/middleware#matching-paths\n *\n * To run custom middleware for authenticated users:\n *\n * ```js\n * // middleware.js\n * import { withMiddlewareAuthRequired, getSession } from '@auth0/nextjs-auth0/edge';\n *\n * export default withMiddlewareAuthRequired(async function middleware(req) {\n *   const res = NextResponse.next();\n *   const user = await getSession(req, res);\n *   res.cookies.set('hl', user.language);\n *   return res;\n * });\n * ```\n *\n * To provide a custom `returnTo` url to login:\n *\n * ```js\n * // middleware.js\n * import { withMiddlewareAuthRequired, getSession } from '@auth0/nextjs-auth0/edge';\n *\n * export default withMiddlewareAuthRequired({\n *   returnTo: '/foo',\n *   // Custom middleware is provided with the `middleware` config option\n *   async middleware(req) { return NextResponse.next(); }\n * });\n * ```\n *\n * You can also provide a method for `returnTo` that takes the req as an argument.\n *\n * ```js\n * // middleware.js\n * import { withMiddlewareAuthRequired, getSession } from '@auth0/nextjs-auth0/edge';\n *\n * export default withMiddlewareAuthRequired({\n *   returnTo(req) { return `${req.nextURL.basePath}${req.nextURL.pathname}`};\n * });\n * ```\n *\n * @category Server\n */\nexport type WithMiddlewareAuthRequired = (\n  middlewareOrOpts?: NextMiddleware | WithMiddlewareAuthRequiredOptions\n) => NextMiddleware;\n\n/**\n * @ignore\n */\nexport default function withMiddlewareAuthRequiredFactory(\n  getConfig: GetConfig,\n  sessionCache: SessionCache\n): WithMiddlewareAuthRequired {\n  return function withMiddlewareAuthRequired(opts?): NextMiddleware {\n    return async function wrappedMiddleware(...args) {\n      const [req] = args;\n      const {\n        routes: { login, callback }\n      } = await getConfig(new Auth0NextRequest(req));\n      let middleware: NextMiddleware | undefined;\n      const { pathname, origin, search } = req.nextUrl;\n      let returnTo = `${pathname}${search}`;\n      if (typeof opts === 'function') {\n        middleware = opts;\n      } else if (opts) {\n        middleware = opts.middleware;\n        returnTo = (typeof opts.returnTo === 'function' ? await opts.returnTo(req) : opts.returnTo) || returnTo;\n      }\n      const ignorePaths = [login, callback, '/_next', '/favicon.ico'];\n      if (ignorePaths.some((p) => pathname.startsWith(p))) {\n        return;\n      }\n\n      const authRes = NextResponse.next();\n      const session = await sessionCache.get(req, authRes);\n      if (!session?.user) {\n        if (pathname.startsWith('/api')) {\n          return NextResponse.json(\n            {\n              error: 'not_authenticated',\n              description: 'The user does not have an active session or is not authenticated'\n            },\n            { status: 401 }\n          );\n        }\n        return NextResponse.redirect(new URL(`${login}?returnTo=${encodeURIComponent(returnTo)}`, origin));\n      }\n      const res = await (middleware && middleware(...args));\n\n      if (res) {\n        const nextRes = new NextResponse(res.body, res);\n        const cookies = authRes.cookies.getAll();\n        if ('cookies' in res) {\n          for (const cookie of res.cookies.getAll()) {\n            nextRes.cookies.set(cookie);\n          }\n        }\n        for (const cookie of cookies) {\n          if (!nextRes.cookies.get(cookie.name)) {\n            nextRes.cookies.set(cookie);\n          }\n        }\n        return nextRes;\n      } else {\n        return authRes;\n      }\n    };\n  };\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGA,MAAA;AAkFA;;IAGA,SAAwB,kCACtB,SAAoB,EACpB,YAA0B;IAE1B,OAAO,SAAS,2BAA2B,IAAK;QAC9C,OAAO,eAAe,kBAAkB,GAAG,IAAI;YAC7C,MAAM,CAAC,IAAI,GAAG;YACd,MAAM,EACJ,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,EAC5B,GAAG,MAAM,UAAU,IAAI,OAAA,gBAAgB,CAAC;YACzC,IAAI;YACJ,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,OAAO;YAChD,IAAI,WAAW,CAAA,EAAG,SAAQ,EAAG,OAAM,CAAE;YACrC,IAAI,OAAO,SAAS,YAAY;gBAC9B,aAAa;mBACR,IAAI,MAAM;gBACf,aAAa,KAAK,UAAU;gBAC5B,WAAW,CAAC,OAAO,KAAK,QAAQ,KAAK,aAAa,MAAM,KAAK,QAAQ,CAAC,OAAO,KAAK,QAAQ,KAAK;;YAEjG,MAAM,cAAc;gBAAC;gBAAO;gBAAU;gBAAU;aAAe;YAC/D,IAAI,YAAY,IAAI,CAAC,CAAC,IAAM,SAAS,UAAU,CAAC,KAAK;gBACnD;;YAGF,MAAM,UAAU,SAAA,YAAY,CAAC,IAAI;YACjC,MAAM,UAAU,MAAM,aAAa,GAAG,CAAC,KAAK;YAC5C,IAAI,CAAC,CAAA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,IAAI,GAAE;gBAClB,IAAI,SAAS,UAAU,CAAC,SAAS;oBAC/B,OAAO,SAAA,YAAY,CAAC,IAAI,CACtB;wBACE,OAAO;wBACP,aAAa;uBAEf;wBAAE,QAAQ;oBAAG;;gBAGjB,OAAO,SAAA,YAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAA,EAAG,MAAK,UAAA,EAAa,mBAAmB,UAAS,CAAE,EAAE;;YAE5F,MAAM,MAAM,MAAM,CAAC,cAAc,cAAc,KAAK;YAEpD,IAAI,KAAK;gBACP,MAAM,UAAU,IAAI,SAAA,YAAY,CAAC,IAAI,IAAI,EAAE;gBAC3C,MAAM,UAAU,QAAQ,OAAO,CAAC,MAAM;gBACtC,IAAI,aAAa,KAAK;oBACpB,KAAK,MAAM,UAAU,IAAI,OAAO,CAAC,MAAM,GAAI;wBACzC,QAAQ,OAAO,CAAC,GAAG,CAAC;;;gBAGxB,KAAK,MAAM,UAAU,QAAS;oBAC5B,IAAI,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG;wBACrC,QAAQ,OAAO,CAAC,GAAG,CAAC;;;gBAGxB,OAAO;mBACF;gBACL,OAAO;;QAEX;IACF;AACF;AA3DA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 3618, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3622, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/init.ts"],"sourcesContent":["import {\n  TransientStore,\n  loginHandler as baseLoginHandler,\n  logoutHandler as baseLogoutHandler,\n  callbackHandler as baseCallbackHandler,\n  backchannelLogoutHandler as baseBackchannelLogoutHandler,\n  Telemetry\n} from './auth0-session';\nimport {\n  handlerFactory,\n  callbackHandler,\n  loginHandler,\n  logoutHandler,\n  profileHandler,\n  backchannelLogoutHandler\n} from './handlers';\nimport {\n  sessionFactory,\n  accessTokenFactory,\n  SessionCache,\n  touchSessionFactory,\n  updateSessionFactory\n} from './session/';\nimport { withPageAuthRequiredFactory, withApiAuthRequiredFactory } from './helpers';\nimport { configSingletonGetter, ConfigParameters } from './config';\nimport { Auth0Server, telemetry } from './shared';\nimport withMiddlewareAuthRequiredFactory from './helpers/with-middleware-auth-required';\nimport { GetClient } from './auth0-session/client/abstract-client';\n\n/**\n * Initialise your own instance of the SDK.\n *\n * See {@link ConfigParameters}.\n *\n * @category Server\n */\nexport type InitAuth0 = (params?: ConfigParameters) => Auth0Server;\n\nexport const _initAuth = ({\n  params,\n  genId,\n  clientGetter\n}: {\n  params?: ConfigParameters;\n  genId: () => string;\n  clientGetter: (telemetry: Telemetry) => GetClient;\n}): Auth0Server => {\n  const getConfig = configSingletonGetter(params, genId);\n  const getClient = clientGetter(telemetry);\n\n  // Init base layer (with base config)\n  const transientStore = new TransientStore(getConfig);\n\n  const sessionCache = new SessionCache(getConfig);\n  const baseHandleLogin = baseLoginHandler(getConfig, getClient, transientStore);\n  const baseHandleLogout = baseLogoutHandler(getConfig, getClient, sessionCache);\n  const baseHandleCallback = baseCallbackHandler(getConfig, getClient, sessionCache, transientStore);\n  const baseHandleBackchannelLogout = baseBackchannelLogoutHandler(getConfig, getClient);\n\n  // Init Next layer (with next config)\n  const getSession = sessionFactory(sessionCache);\n  const touchSession = touchSessionFactory(sessionCache);\n  const updateSession = updateSessionFactory(sessionCache);\n  const getAccessToken = accessTokenFactory(getConfig, getClient, sessionCache);\n  const withApiAuthRequired = withApiAuthRequiredFactory(sessionCache);\n  const withPageAuthRequired = withPageAuthRequiredFactory(getConfig, sessionCache);\n  const handleLogin = loginHandler(baseHandleLogin, getConfig);\n  const handleLogout = logoutHandler(baseHandleLogout);\n  const handleCallback = callbackHandler(baseHandleCallback, getConfig);\n  const handleBackchannelLogout = backchannelLogoutHandler(baseHandleBackchannelLogout, getConfig);\n  const handleProfile = profileHandler(getConfig, getClient, getAccessToken, sessionCache);\n  const handleAuth = handlerFactory({\n    handleLogin,\n    handleLogout,\n    handleCallback,\n    handleProfile,\n    handleBackchannelLogout\n  });\n  const withMiddlewareAuthRequired = withMiddlewareAuthRequiredFactory(getConfig, sessionCache);\n\n  return {\n    getSession,\n    touchSession,\n    updateSession,\n    getAccessToken,\n    withApiAuthRequired,\n    withPageAuthRequired,\n    handleLogin,\n    handleLogout,\n    handleCallback,\n    handleBackchannelLogout,\n    handleProfile,\n    handleAuth,\n    withMiddlewareAuthRequired\n  };\n};\n"],"names":[],"mappings":";;;;;;AAAA,MAAA;AAQA,MAAA;AAQA,MAAA;AAOA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA,kCAAA,QAAA,eAAA;AAYO,MAAM,YAAY,CAAC,EACxB,MAAM,EACN,KAAK,EACL,YAAY,EAKb;IACC,MAAM,YAAY,CAAA,GAAA,SAAA,qBAAqB,EAAC,QAAQ;IAChD,MAAM,YAAY,aAAa,SAAA,SAAS;IAExC,qCAAqC;IACrC,MAAM,iBAAiB,IAAI,gBAAA,cAAc,CAAC;IAE1C,MAAM,eAAe,IAAI,UAAA,YAAY,CAAC;IACtC,MAAM,kBAAkB,CAAA,GAAA,gBAAA,YAAgB,EAAC,WAAW,WAAW;IAC/D,MAAM,mBAAmB,CAAA,GAAA,gBAAA,aAAiB,EAAC,WAAW,WAAW;IACjE,MAAM,qBAAqB,CAAA,GAAA,gBAAA,eAAmB,EAAC,WAAW,WAAW,cAAc;IACnF,MAAM,8BAA8B,CAAA,GAAA,gBAAA,wBAA4B,EAAC,WAAW;IAE5E,qCAAqC;IACrC,MAAM,aAAa,CAAA,GAAA,UAAA,cAAc,EAAC;IAClC,MAAM,eAAe,CAAA,GAAA,UAAA,mBAAmB,EAAC;IACzC,MAAM,gBAAgB,CAAA,GAAA,UAAA,oBAAoB,EAAC;IAC3C,MAAM,iBAAiB,CAAA,GAAA,UAAA,kBAAkB,EAAC,WAAW,WAAW;IAChE,MAAM,sBAAsB,CAAA,GAAA,UAAA,0BAA0B,EAAC;IACvD,MAAM,uBAAuB,CAAA,GAAA,UAAA,2BAA2B,EAAC,WAAW;IACpE,MAAM,cAAc,CAAA,GAAA,WAAA,YAAY,EAAC,iBAAiB;IAClD,MAAM,eAAe,CAAA,GAAA,WAAA,aAAa,EAAC;IACnC,MAAM,iBAAiB,CAAA,GAAA,WAAA,eAAe,EAAC,oBAAoB;IAC3D,MAAM,0BAA0B,CAAA,GAAA,WAAA,wBAAwB,EAAC,6BAA6B;IACtF,MAAM,gBAAgB,CAAA,GAAA,WAAA,cAAc,EAAC,WAAW,WAAW,gBAAgB;IAC3E,MAAM,aAAa,CAAA,GAAA,WAAA,cAAc,EAAC;QAChC;QACA;QACA;QACA;QACA;;IAEF,MAAM,6BAA6B,CAAA,GAAA,gCAAA,OAAiC,EAAC,WAAW;IAEhF,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;AAEJ;AAzDa,QAAA,SAAS,GAAA"}},
    {"offset": {"line": 3682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3686, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/utils/instance-check.ts"],"sourcesContent":["let isUsingNamedExports = false;\nlet isUsingOwnInstance = false;\n\nconst instanceCheck = () => {\n  if (isUsingNamedExports && isUsingOwnInstance) {\n    throw new Error(\n      'You cannot mix creating your own instance with `initAuth0` and using named ' +\n        \"exports like `import { handleAuth } from '@auth0/nextjs-auth0'`\"\n    );\n  }\n};\n\nexport const setIsUsingNamedExports = (): void => {\n  isUsingNamedExports = true;\n  instanceCheck();\n};\n\nexport const setIsUsingOwnInstance = (): void => {\n  isUsingOwnInstance = true;\n  instanceCheck();\n};\n"],"names":[],"mappings":";;;;;AAAA,IAAI,sBAAsB;AAC1B,IAAI,qBAAqB;AAEzB,MAAM,gBAAgB;IACpB,IAAI,uBAAuB,oBAAoB;QAC7C,MAAM,IAAI,MACR,gFACE;;AAGR;AAEO,MAAM,yBAAyB;IACpC,sBAAsB;IACtB;AACF;AAHa,QAAA,sBAAsB,GAAA;AAK5B,MAAM,wBAAwB;IACnC,qBAAqB;IACrB;AACF;AAHa,QAAA,qBAAqB,GAAA"}},
    {"offset": {"line": 3708, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3712, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/auth0-session/client/node-client.ts"],"sourcesContent":["import { Auth0Request } from '../http';\nimport {\n  CallbackExtras,\n  CallbackParamsType,\n  OpenIDCallbackChecks,\n  TokenEndpointResponse,\n  AbstractClient,\n  Telemetry\n} from './abstract-client';\nimport {\n  Client,\n  ClientAuthMethod,\n  custom,\n  CustomHttpOptionsProvider,\n  EndSessionParameters,\n  errors,\n  generators,\n  Issuer,\n  IssuerMetadata\n} from 'openid-client';\nimport { ApplicationError, DiscoveryError, EscapedError, IdentityProviderError, UserInfoError } from '../utils/errors';\nimport { createPrivateKey } from 'crypto';\nimport { exportJWK } from 'jose';\nimport urlJoin from 'url-join';\nimport createDebug from '../utils/debug';\nimport { IncomingMessage } from 'http';\nimport { AccessTokenError, AccessTokenErrorCode } from '../../utils/errors';\nimport { Config } from '../config';\n\nconst debug = createDebug('client');\n\nfunction sortSpaceDelimitedString(str: string): string {\n  return str.split(' ').sort().join(' ');\n}\n\nexport class NodeClient extends AbstractClient {\n  private client?: Client;\n\n  private async getClient(): Promise<Client> {\n    if (this.client) {\n      return this.client;\n    }\n    const {\n      config,\n      telemetry: { name, version }\n    } = this;\n\n    const defaultHttpOptions: CustomHttpOptionsProvider = (_url, options) => ({\n      ...options,\n      headers: {\n        ...options.headers,\n        'User-Agent': `${name}/${version}`,\n        ...(config.enableTelemetry\n          ? {\n              'Auth0-Client': Buffer.from(\n                JSON.stringify({\n                  name,\n                  version,\n                  env: {\n                    node: process.version\n                  }\n                })\n              ).toString('base64')\n            }\n          : undefined)\n      },\n      timeout: config.httpTimeout,\n      agent: config.httpAgent\n    });\n    const applyHttpOptionsCustom = (entity: Issuer<Client> | typeof Issuer | Client) => {\n      entity[custom.http_options] = defaultHttpOptions;\n    };\n\n    applyHttpOptionsCustom(Issuer);\n    let issuer: Issuer<Client>;\n    try {\n      issuer = await Issuer.discover(config.issuerBaseURL);\n    } catch (e) {\n      throw new DiscoveryError(e, config.issuerBaseURL);\n    }\n    applyHttpOptionsCustom(issuer);\n\n    const issuerTokenAlgs = Array.isArray(issuer.id_token_signing_alg_values_supported)\n      ? issuer.id_token_signing_alg_values_supported\n      : [];\n    if (!issuerTokenAlgs.includes(config.idTokenSigningAlg)) {\n      debug(\n        'ID token algorithm %o is not supported by the issuer. Supported ID token algorithms are: %o.',\n        config.idTokenSigningAlg,\n        issuerTokenAlgs\n      );\n    }\n\n    const configRespType = sortSpaceDelimitedString(config.authorizationParams.response_type);\n    const issuerRespTypes = Array.isArray(issuer.response_types_supported) ? issuer.response_types_supported : [];\n    issuerRespTypes.map(sortSpaceDelimitedString);\n    if (!issuerRespTypes.includes(configRespType)) {\n      debug(\n        'Response type %o is not supported by the issuer. Supported response types are: %o.',\n        configRespType,\n        issuerRespTypes\n      );\n    }\n\n    const configRespMode = config.authorizationParams.response_mode;\n    const issuerRespModes = Array.isArray(issuer.response_modes_supported) ? issuer.response_modes_supported : [];\n    if (configRespMode && !issuerRespModes.includes(configRespMode)) {\n      debug(\n        'Response mode %o is not supported by the issuer. Supported response modes are %o.',\n        configRespMode,\n        issuerRespModes\n      );\n    }\n\n    if (config.pushedAuthorizationRequests && !issuer.pushed_authorization_request_endpoint) {\n      throw new TypeError(\n        'pushed_authorization_request_endpoint must be configured on the issuer to use pushedAuthorizationRequests'\n      );\n    }\n\n    let jwks;\n    if (config.clientAssertionSigningKey) {\n      const privateKey = createPrivateKey({ key: config.clientAssertionSigningKey as string });\n      const jwk = await exportJWK(privateKey);\n      jwks = { keys: [jwk] };\n    }\n\n    this.client = new issuer.Client(\n      {\n        client_id: config.clientID,\n        client_secret: config.clientSecret,\n        id_token_signed_response_alg: config.idTokenSigningAlg,\n        token_endpoint_auth_method: config.clientAuthMethod as ClientAuthMethod,\n        token_endpoint_auth_signing_alg: config.clientAssertionSigningAlg\n      },\n      jwks\n    );\n    applyHttpOptionsCustom(this.client);\n\n    this.client[custom.clock_tolerance] = config.clockTolerance;\n    const issuerUrl = new URL(issuer.metadata.issuer);\n\n    if (config.idpLogout) {\n      if (\n        this.config.idpLogout &&\n        (this.config.auth0Logout || (issuerUrl.hostname.match('\\\\.auth0\\\\.com$') && this.config.auth0Logout !== false))\n      ) {\n        Object.defineProperty(this.client, 'endSessionUrl', {\n          value(params: EndSessionParameters) {\n            const { id_token_hint, post_logout_redirect_uri, ...extraParams } = params;\n            const parsedUrl = new URL(urlJoin(issuer.metadata.issuer, '/v2/logout'));\n            parsedUrl.searchParams.set('client_id', config.clientID);\n            post_logout_redirect_uri && parsedUrl.searchParams.set('returnTo', post_logout_redirect_uri);\n            Object.entries(extraParams).forEach(([key, value]) => {\n              if (value === null || value === undefined) {\n                return;\n              }\n              parsedUrl.searchParams.set(key, value as string);\n            });\n            return parsedUrl.toString();\n          }\n        });\n      } else if (!issuer.end_session_endpoint) {\n        debug('the issuer does not support RP-Initiated Logout');\n      }\n    }\n\n    return this.client;\n  }\n\n  async authorizationUrl(parameters: Record<string, unknown>): Promise<string> {\n    const client = await this.getClient();\n\n    if (this.config.pushedAuthorizationRequests) {\n      const { request_uri } = await client.pushedAuthorizationRequest(parameters);\n      parameters = { request_uri };\n    }\n\n    return client.authorizationUrl(parameters);\n  }\n\n  async callbackParams(req: Auth0Request) {\n    const client = await this.getClient();\n    const obj: CallbackParamsType = client.callbackParams({\n      method: req.getMethod(),\n      url: req.getUrl(),\n      body: await req.getBody()\n    } as unknown as IncomingMessage);\n    return new URLSearchParams(obj);\n  }\n\n  async callback(\n    redirectUri: string,\n    parameters: URLSearchParams,\n    checks: OpenIDCallbackChecks,\n    extras: CallbackExtras\n  ): Promise<TokenEndpointResponse> {\n    const params = Object.fromEntries(parameters.entries());\n    const client = await this.getClient();\n    try {\n      return await client.callback(redirectUri, params, checks, extras);\n    } catch (err) {\n      if (err instanceof errors.OPError) {\n        throw new IdentityProviderError(err);\n      } else if (err instanceof errors.RPError) {\n        throw new ApplicationError(err);\n        /* c8 ignore next 3 */\n      } else {\n        throw new EscapedError(err.message);\n      }\n    }\n  }\n\n  async endSessionUrl(parameters: EndSessionParameters): Promise<string> {\n    const client = await this.getClient();\n    return client.endSessionUrl(parameters);\n  }\n\n  async userinfo(accessToken: string): Promise<Record<string, unknown>> {\n    const client = await this.getClient();\n    try {\n      return await client.userinfo(accessToken);\n    } catch (e) {\n      throw new UserInfoError(e.message);\n    }\n  }\n\n  async refresh(refreshToken: string, extras: { exchangeBody: Record<string, any> }): Promise<TokenEndpointResponse> {\n    const client = await this.getClient();\n    try {\n      return await client.refresh(refreshToken, extras);\n    } catch (e) {\n      throw new AccessTokenError(\n        AccessTokenErrorCode.FAILED_REFRESH_GRANT,\n        'The request to refresh the access token failed.',\n        new IdentityProviderError(e as errors.OPError)\n      );\n    }\n  }\n\n  generateRandomCodeVerifier(): string {\n    return generators.codeVerifier();\n  }\n\n  generateRandomNonce(): string {\n    return generators.nonce();\n  }\n\n  calculateCodeChallenge(codeVerifier: string): string {\n    return generators.codeChallenge(codeVerifier);\n  }\n\n  async getIssuerMetadata(): Promise<IssuerMetadata> {\n    const { issuer } = await this.getClient();\n    return issuer.metadata;\n  }\n}\n\nexport const clientGetter = (telemetry: Telemetry): ((config: Config) => Promise<NodeClient>) => {\n  let client: NodeClient;\n  return async (config) => {\n    if (!client) {\n      client = new NodeClient(config, telemetry);\n    }\n    return client;\n  };\n};\n"],"names":[],"mappings":";;;;;;AACA,MAAA;AAQA,MAAA;AAWA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA,aAAA,QAAA,eAAA;AACA,MAAA,UAAA,QAAA,eAAA;AAEA,MAAA;AAGA,MAAM,QAAQ,CAAA,GAAA,QAAA,OAAW,EAAC;AAE1B,SAAS,yBAAyB,GAAW;IAC3C,OAAO,IAAI,KAAK,CAAC,KAAK,IAAI,GAAG,IAAI,CAAC;AACpC;AAEA,MAAa,mBAAmB,kBAAA,cAAc;IAGpC,MAAM,YAAS;QACrB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,CAAC,MAAM;;QAEpB,MAAM,EACJ,MAAM,EACN,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,EAC7B,GAAG,IAAI;QAER,MAAM,qBAAgD,CAAC,MAAM,UAAY,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACpE,UAAO;gBACV,SAAO,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GACF,QAAQ,OAAO,GAAA;oBAClB,cAAc,CAAA,EAAG,KAAI,CAAA,EAAI,QAAO,CAAE;gBAAA,IAC9B,OAAO,eAAe,GACtB;oBACE,gBAAgB,OAAO,IAAI,CACzB,KAAK,SAAS,CAAC;wBACb;wBACA;wBACA,KAAK;4BACH,MAAM,QAAQ,OAAO;;wBAGzB,QAAQ,CAAC;oBAEb;gBAEN,SAAS,OAAO,WAAW;gBAC3B,OAAO,OAAO,SAAS;YAAA;QAEzB,MAAM,yBAAyB,CAAC;YAC9B,MAAM,CAAC,gBAAA,MAAM,CAAC,YAAY,CAAC,GAAG;QAChC;QAEA,uBAAuB,gBAAA,MAAM;QAC7B,IAAI;QACJ,IAAI;YACF,SAAS,MAAM,gBAAA,MAAM,CAAC,QAAQ,CAAC,OAAO,aAAa;UACnD,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,cAAc,CAAC,GAAG,OAAO,aAAa;;QAElD,uBAAuB;QAEvB,MAAM,kBAAkB,MAAM,OAAO,CAAC,OAAO,qCAAqC,IAC9E,OAAO,qCAAqC,GAC5C,EAAE;QACN,IAAI,CAAC,gBAAgB,QAAQ,CAAC,OAAO,iBAAiB,GAAG;YACvD,MACE,gGACA,OAAO,iBAAiB,EACxB;;QAIJ,MAAM,iBAAiB,yBAAyB,OAAO,mBAAmB,CAAC,aAAa;QACxF,MAAM,kBAAkB,MAAM,OAAO,CAAC,OAAO,wBAAwB,IAAI,OAAO,wBAAwB,GAAG,EAAE;QAC7G,gBAAgB,GAAG,CAAC;QACpB,IAAI,CAAC,gBAAgB,QAAQ,CAAC,iBAAiB;YAC7C,MACE,sFACA,gBACA;;QAIJ,MAAM,iBAAiB,OAAO,mBAAmB,CAAC,aAAa;QAC/D,MAAM,kBAAkB,MAAM,OAAO,CAAC,OAAO,wBAAwB,IAAI,OAAO,wBAAwB,GAAG,EAAE;QAC7G,IAAI,kBAAkB,CAAC,gBAAgB,QAAQ,CAAC,iBAAiB;YAC/D,MACE,qFACA,gBACA;;QAIJ,IAAI,OAAO,2BAA2B,IAAI,CAAC,OAAO,qCAAqC,EAAE;YACvF,MAAM,IAAI,UACR;;QAIJ,IAAI;QACJ,IAAI,OAAO,yBAAyB,EAAE;YACpC,MAAM,aAAa,CAAA,GAAA,SAAA,gBAAgB,EAAC;gBAAE,KAAK,OAAO,yBAAmC;YAAA;YACrF,MAAM,MAAM,MAAM,CAAA,GAAA,OAAA,SAAS,EAAC;YAC5B,OAAO;gBAAE,MAAM;oBAAC;iBAAI;YAAA;;QAGtB,IAAI,CAAC,MAAM,GAAG,IAAI,OAAO,MAAM,CAC7B;YACE,WAAW,OAAO,QAAQ;YAC1B,eAAe,OAAO,YAAY;YAClC,8BAA8B,OAAO,iBAAiB;YACtD,4BAA4B,OAAO,gBAAoC;YACvE,iCAAiC,OAAO,yBAAyB;WAEnE;QAEF,uBAAuB,IAAI,CAAC,MAAM;QAElC,IAAI,CAAC,MAAM,CAAC,gBAAA,MAAM,CAAC,eAAe,CAAC,GAAG,OAAO,cAAc;QAC3D,MAAM,YAAY,IAAI,IAAI,OAAO,QAAQ,CAAC,MAAM;QAEhD,IAAI,OAAO,SAAS,EAAE;YACpB,IACE,IAAI,CAAC,MAAM,CAAC,SAAS,IACrB,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,IAAK,UAAU,QAAQ,CAAC,KAAK,CAAC,sBAAsB,IAAI,CAAC,MAAM,CAAC,WAAW,KAAK,KAAM,GAC9G;gBACA,OAAO,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,iBAAiB;oBAClD,OAAM,MAA4B;wBAChC,MAAM,EAAE,aAAa,EAAE,wBAAwB,EAAA,GAAqB,QAAhB,cAAW,QAAA,MAAA,CAAK,QAA9D;4BAAA;4BAAA;yBAA2D;wBACjE,MAAM,YAAY,IAAI,IAAI,CAAA,GAAA,WAAA,OAAO,EAAC,OAAO,QAAQ,CAAC,MAAM,EAAE;wBAC1D,UAAU,YAAY,CAAC,GAAG,CAAC,aAAa,OAAO,QAAQ;wBACvD,4BAA4B,UAAU,YAAY,CAAC,GAAG,CAAC,YAAY;wBACnE,OAAO,OAAO,CAAC,aAAa,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;4BAC/C,IAAI,UAAU,QAAQ,UAAU,WAAW;gCACzC;;4BAEF,UAAU,YAAY,CAAC,GAAG,CAAC,KAAK;wBAClC;wBACA,OAAO,UAAU,QAAQ;oBAC3B;;mBAEG,IAAI,CAAC,OAAO,oBAAoB,EAAE;gBACvC,MAAM;;;QAIV,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,MAAM,iBAAiB,UAAmC,EAAA;QACxD,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QAEnC,IAAI,IAAI,CAAC,MAAM,CAAC,2BAA2B,EAAE;YAC3C,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,OAAO,0BAA0B,CAAC;YAChE,aAAa;gBAAE;YAAW;;QAG5B,OAAO,OAAO,gBAAgB,CAAC;IACjC;IAEA,MAAM,eAAe,GAAiB,EAAA;QACpC,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,MAAM,MAA0B,OAAO,cAAc,CAAC;YACpD,QAAQ,IAAI,SAAS;YACrB,KAAK,IAAI,MAAM;YACf,MAAM,MAAM,IAAI,OAAO;;QAEzB,OAAO,IAAI,gBAAgB;IAC7B;IAEA,MAAM,SACJ,WAAmB,EACnB,UAA2B,EAC3B,MAA4B,EAC5B,MAAsB,EAAA;QAEtB,MAAM,SAAS,OAAO,WAAW,CAAC,WAAW,OAAO;QACpD,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,IAAI;YACF,OAAO,MAAM,OAAO,QAAQ,CAAC,aAAa,QAAQ,QAAQ;UAC1D,OAAO,KAAK;YACZ,IAAI,eAAe,gBAAA,MAAM,CAAC,OAAO,EAAE;gBACjC,MAAM,IAAI,SAAA,qBAAqB,CAAC;mBAC3B,IAAI,eAAe,gBAAA,MAAM,CAAC,OAAO,EAAE;gBACxC,MAAM,IAAI,SAAA,gBAAgB,CAAC;YAC3B,oBAAA,UACK;gBACL,MAAM,IAAI,SAAA,YAAY,CAAC,IAAI,OAAO;;;IAGxC;IAEA,MAAM,cAAc,UAAgC,EAAA;QAClD,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,OAAO,OAAO,aAAa,CAAC;IAC9B;IAEA,MAAM,SAAS,WAAmB,EAAA;QAChC,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,IAAI;YACF,OAAO,MAAM,OAAO,QAAQ,CAAC;UAC7B,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,aAAa,CAAC,EAAE,OAAO;;IAErC;IAEA,MAAM,QAAQ,YAAoB,EAAE,MAA6C,EAAA;QAC/E,MAAM,SAAS,MAAM,IAAI,CAAC,SAAS;QACnC,IAAI;YACF,OAAO,MAAM,OAAO,OAAO,CAAC,cAAc;UAC1C,OAAO,GAAG;YACV,MAAM,IAAI,SAAA,gBAAgB,CACxB,SAAA,oBAAoB,CAAC,oBAAoB,EACzC,mDACA,IAAI,SAAA,qBAAqB,CAAC;;IAGhC;IAEA,6BAA0B;QACxB,OAAO,gBAAA,UAAU,CAAC,YAAY;IAChC;IAEA,sBAAmB;QACjB,OAAO,gBAAA,UAAU,CAAC,KAAK;IACzB;IAEA,uBAAuB,YAAoB,EAAA;QACzC,OAAO,gBAAA,UAAU,CAAC,aAAa,CAAC;IAClC;IAEA,MAAM,oBAAiB;QACrB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAI,CAAC,SAAS;QACvC,OAAO,OAAO,QAAQ;IACxB;;AA5NF,QAAA,UAAA,GAAA;AA+NO,MAAM,eAAe,CAAC;IAC3B,IAAI;IACJ,OAAO,OAAO;QACZ,IAAI,CAAC,QAAQ;YACX,SAAS,IAAI,WAAW,QAAQ;;QAElC,OAAO;IACT;AACF;AARa,QAAA,YAAY,GAAA"}},
    {"offset": {"line": 3907, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3911, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@auth0/nextjs-auth0/src/index.ts"],"sourcesContent":["import crypto from 'crypto';\nimport {\n  Auth0Server as Auth0ServerShared,\n  ConfigParameters,\n  GetAccessToken,\n  GetSession,\n  HandleAuth,\n  HandleCallback,\n  HandleLogin,\n  HandleLogout,\n  HandleProfile,\n  TouchSession,\n  UpdateSession,\n  WithApiAuthRequired,\n  WithPageAuthRequired\n} from './shared';\nimport { _initAuth } from './init';\nimport { setIsUsingNamedExports, setIsUsingOwnInstance } from './utils/instance-check';\nimport { clientGetter } from './auth0-session/client/node-client';\n\nconst genId = () => crypto.randomBytes(16).toString('hex');\n\nexport type Auth0Server = Omit<Auth0ServerShared, 'withMiddlewareAuthRequired'>;\n\nlet instance: Auth0ServerShared;\n\n/**\n * Initialise your own instance of the SDK.\n *\n * See {@link ConfigParameters}.\n *\n * @category Server\n */\nexport type InitAuth0 = (params?: ConfigParameters) => Omit<Auth0Server, 'withMiddlewareAuthRequired'>;\n\n// For using managed instance with named exports.\nfunction getInstance(): Auth0ServerShared {\n  setIsUsingNamedExports();\n  if (instance) {\n    return instance;\n  }\n  instance = _initAuth({ genId, clientGetter });\n  return instance;\n}\n\n// For creating own instance.\nexport const initAuth0: InitAuth0 = (params) => {\n  setIsUsingOwnInstance();\n  const { withMiddlewareAuthRequired, ...publicApi } = _initAuth({\n    genId,\n    params,\n    clientGetter\n  });\n  return publicApi;\n};\n\nexport const getSession: GetSession = (...args) => getInstance().getSession(...args);\nexport const updateSession: UpdateSession = (...args) => getInstance().updateSession(...args);\nexport const getAccessToken: GetAccessToken = (...args) => getInstance().getAccessToken(...args);\nexport const touchSession: TouchSession = (...args) => getInstance().touchSession(...args);\nexport const withApiAuthRequired: WithApiAuthRequired = (...args) =>\n  (getInstance().withApiAuthRequired as any)(...args);\nexport const withPageAuthRequired: WithPageAuthRequired = ((...args: Parameters<WithPageAuthRequired>) =>\n  getInstance().withPageAuthRequired(...args)) as WithPageAuthRequired;\nexport const handleLogin: HandleLogin = ((...args: Parameters<HandleLogin>) =>\n  getInstance().handleLogin(...args)) as HandleLogin;\nexport const handleLogout: HandleLogout = ((...args: Parameters<HandleLogout>) =>\n  getInstance().handleLogout(...args)) as HandleLogout;\nexport const handleCallback: HandleCallback = ((...args: Parameters<HandleCallback>) =>\n  getInstance().handleCallback(...args)) as HandleCallback;\nexport const handleProfile: HandleProfile = ((...args: Parameters<HandleProfile>) =>\n  getInstance().handleProfile(...args)) as HandleProfile;\nexport const handleAuth: HandleAuth = (...args) => getInstance().handleAuth(...args);\n\nexport * from './shared';\n"],"names":[],"mappings":";;;;;;AAAA,MAAA,WAAA,QAAA,eAAA;AAgBA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,QAAQ,IAAM,SAAA,OAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;AAIpD,IAAI;AAWJ,iDAAiD;AACjD,SAAS;IACP,CAAA,GAAA,iBAAA,sBAAsB;IACtB,IAAI,UAAU;QACZ,OAAO;;IAET,WAAW,CAAA,GAAA,OAAA,SAAS,EAAC;QAAE;QAAO,cAAA,cAAA,YAAY;IAAA;IAC1C,OAAO;AACT;AAEA,6BAA6B;AACtB,MAAM,YAAuB,CAAC;IACnC,CAAA,GAAA,iBAAA,qBAAqB;IACrB,MAAM,KAA+C,CAAA,GAAA,OAAA,SAAS,EAAC;QAC7D;QACA;QACA,cAAA,cAAA,YAAY;QAHR,EAAE,0BAA0B,EAAA,GAAA,IAAK,YAAS,QAAA,MAAA,CAAA,IAA1C;QAAA;KAA4C;IAKlD,OAAO;AACT;AARa,QAAA,SAAS,GAAA;AAUf,MAAM,aAAyB,CAAC,GAAG,OAAS,cAAc,UAAU,IAAI;AAAlE,QAAA,UAAU,GAAA;AAChB,MAAM,gBAA+B,CAAC,GAAG,OAAS,cAAc,aAAa,IAAI;AAA3E,QAAA,aAAa,GAAA;AACnB,MAAM,iBAAiC,CAAC,GAAG,OAAS,cAAc,cAAc,IAAI;AAA9E,QAAA,cAAc,GAAA;AACpB,MAAM,eAA6B,CAAC,GAAG,OAAS,cAAc,YAAY,IAAI;AAAxE,QAAA,YAAY,GAAA;AAClB,MAAM,sBAA2C,CAAC,GAAG,OACzD,cAAc,mBAA2B,IAAI;AADnC,QAAA,mBAAmB,GAAA;AAEnB,QAAA,oBAAoB,GAA0B,CAAC,GAAG,OAC7D,cAAc,oBAAoB,IAAI;AAC3B,QAAA,WAAW,GAAiB,CAAC,GAAG,OAC3C,cAAc,WAAW,IAAI;AAClB,QAAA,YAAY,GAAkB,CAAC,GAAG,OAC7C,cAAc,YAAY,IAAI;AACnB,QAAA,cAAc,GAAoB,CAAC,GAAG,OACjD,cAAc,cAAc,IAAI;AACrB,QAAA,aAAa,GAAmB,CAAC,GAAG,OAC/C,cAAc,aAAa,IAAI;AAC1B,MAAM,aAAyB,CAAC,GAAG,OAAS,cAAc,UAAU,IAAI;AAAlE,QAAA,UAAU,GAAA;AAEvB,QAAA,YAAA,8GAAA"}},
    {"offset": {"line": 3966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}